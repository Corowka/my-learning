<!DOCTYPE html>
<html>

<head>
    <meta charset="uft-8">
    <title> Подготовка к экзамену по дисциплине ОАИП </title>
</head>

<body>
    <h3> Список вопросов: </h3>
    <ol>
        <li> История создания ЭВМ. </li>
        <li> Поколения компьютеров. </li>
        <li> Архитектура Фон – Неймана. Принципы фон Неймана. </li>
        <li> Языки программирования и их классификация. </li>
        <li> Размещение данных и программ в памяти ПЭВМ. </li>
        <li> Программные модули. Понятие транслятора, компилятора и интерпретатора. </li>
        <li> Этапы решения задач на ЭВМ. </li>
        <li> Алгоритм. Способы записи алгоритмов. </li>
        <li> Алгоритм. Свойства алгоритма. Принципы построения алгоритмов при
            решении сложных задач. Пример алгоритма. </li>
        <li> Правила применения символов и выполнения блок-схем. Описание символов </li>
        <li> Типовые алгоритмические структуры. </li>
        <li> Синтаксис языка СИ. Алфавит. Лексемы. </li>
        <li> Идентификаторы. Ключевые слова. </li>
        <li> Литералы (константы). Комментарии. Директивы. </li>
        <li> Структура программы на языке СИ. </li>
        <li> Основные типы данных. </li>
        <li> Целый тип. Внутреннее представление в языке Си. Переполнение. </li>
        <li> Типы с плавающей (фиксированной) точкой. Внутреннее представление в
            языке Си. </li>
        <li> Объявление объектов. </li>
        <li> Преобразование типов. Приведение типов. </li>
        <li> Константы в программах (целочисленные, вещественные, символьные,
            строковые) </li>
        <li> Операции и выражения. Унарные, бинарные и тернарные операции.
            Приоритет в выражениях. Приоритет операций. </li>
        <li> Операции и выражения. Арифметические операции. Операция присваивания и
            ее сокращенная запись. </li>
        <li> Операции и выражения. Операции сравнения. Логические операции.
            Операция запятая. </li>
        <li> Операции и выражения. Побитовые логические операции. Операции над
            битами. </li>
        <li> Стандартные математические функции. Файлы math.h, stdlib.h </li>
        <li> Функции форматного ввода. Управляющая строка. Управляющие символы.
            Спецификаторы формата. </li>
        <li> Функции форматного вывода. Управляющая строка. Спецификаторы формата. </li>
        <li> Категории операторов. Синтаксис и семантика операторов. Пустой
            оператор. Составной оператор. </li>
        <li> Операторы цикла. Цель использования операторов цикла. Итерация.
            Параметры цикла. </li>
        <li> Условные операторы. Тернанрая операция. </li>
        <li> Оператор выбора альтернатив switch. Операторы передачи управления
            (goto, continue, break, return) </li>
        <li> Массивы. Объявления. Инициализация. Доступ к элементам массива.
            Действия над элементами массива. </li>
        <li> Одномерный, двумерный и многомерный массив. </li>
        <li> Указатели. Инициализация указателей. Примеры работы. Область
            применения. </li>
        <li> Операторы адреса и разыменования. Операции над указателями. Область
            применения указателей. </li>
        <li> Указатели и const. </li>
        <li> Ссылки. </li>
        <li> Применение указателей для работы с массивами. Одномерный динамический
            массив. Выделение/высвобождение памяти. </li>
        <li> Двумерный динамический массив. Выделение/высвобождение памяти. </li>
        <li> Многомерные массивы и указатели на указатели. </li>
        <li> Динамическая память, функции malloc(), calloc(), realloc(), free() </li>
        <li> Строки. Объявление. Инициализация. Действия над строками и элементами
            строки. </li>
        <li> Строки. Ввод/вывод строк. </li>
        <li> Строки. Библиотека string.h. Прототипы функций для работы со строкой. </li>
        <li> Модульное программирование. </li>
        <li> Подпрограммы. Виды подпрограмм. </li>
        <li> Функции. Объявление и вызов. </li>
        <li> Обмен информацией между функциями. </li>
        <li> Передача массивов в качестве параметров функции. </li>
        <li> Указатель на функцию. </li>
    </ol>
    <ol>
        <li>
            <h4> История создания ЭВМ.</h4>
            <p>Первое устройство для счёта – пальцы рук человека. Первое домеханическое устройство – абак. Основные
                отличия ВМ от других устройств заключается в том, что вся последовательность команд на вычисление
                предварительно записывается в память ВМ и выполняются автоматически. Первая счётная машина с хранимой
                памятью была построена Паскалем в 1642 г. Она была механическая и могла выполнять 2 операции: сложение и
                вычитание. Лейбниц в 1672 г. Построил механическую машину, которая могла выполнять 4 операции: сложение,
                вычитание, умножение и деление. Лейбницу принадлежит идея использование двоичной системы счисления в ВМ.
                Он первым описал систему с цифрами 0 и 1. Впервые машину, работающую на программе, разработал в 1834 г.
                Бэббидж. Она содержала запоминающее устройство и запись в память результатов вычисления. Машина
                реализовывала любые программы записанные на перфокарте, поэтому впервые потребовался программист. Первым
                программистом была математик Ада Ловлейс
                //Первые гражданские ЭВМ Z1 и Z2 были созданы в конце 1930-х годов в Германии. 1941 год — Конрад Цузе
                создал вычислительную машину Z3, которая имела все свойства современного компьютера. ... 1946 год стал
                годом создания первой американской гражданской универсальной электронной цифровой вычислительной машины
                ЭНИАК.
            </p>
        </li>
        <li>
            <h4>Поколения компьютеров. </h4>
            <p>I поколение компьютеров
                ПК на электронных лампах (≈ 1940-1955гг). Могли производить десятки тысяч операций в секунду, лампочка
                имела существенный размер, машины огромные, лампы перегорали и выделяют много тепла, поэтому сделали
                охладительную систему. Операционных систем не было, выполнялся либо ввод либо вывод после обработки
                данных. Основной язык был assembler.
                II поколение компьютеров
                ПК на транзисторе (≈ 1955-1965гг). Могли производить сотни тысяч операций в секунду. По сравнению с
                лампами транзистор уменьшил размер, повисел скорость, не так опасен, тк нет теплоотдачи. Появились
                служебные программы и математическая библиотека. Использовали языки высокого уровня. Главный принцип
                структуры - централизация.
                III поколение компьютеров
                ПК на интегральных схемах (≈ 1965-1980гг). Могли производить миллионы операций в секунду. В интегральной
                схеме вмещается тысяча транзисторов. ПК стали меньше дешевле быстрее. Начали быть более
                специализированными. Стало возможным мультипрограммирование — способ организации вычислительного
                процесса, когда у 1 поколения попеременно происходили выполнения. Была проблема совместимости
                выпускаемых моделей и ПО для них, поэтому появился совместимый ПК IBM.
                IV поколение компьютеров
                ПК на больших интегральных схемах (устройства несколько сотен радио элементов соединённых между собой),
                поэтому можно было создавать функционально быструю ЭВМ на 1 кристалле сотни миллионов действий. Началась
                эра ПВМ, они были дешевле и с ПО. В конце 70 начале 80 популярен ПК от Apple. В середине 80 было
                развитие сети ПК.
                V поколение компьютеров
                ПК с двухъядерными процессорами. Появились в 1990 г. Главный упор при создании компьютеров сделан на их
                "интеллектуальность". Внимание акцентируется на архитектуре, ориентированной на обработку знаний.
                Обработка знаний - это одна из областей практического применения искусственного интеллекта,
                предполагающая использование и обработку компьютером знаний, которыми владеет человек для решения
                проблем и принятия решений.
            </p>
        </li>
        <li>
            <h4>Архитектура Фон – Неймана. Принципы фон Неймана.</h4>
            <p>Архитектура фон Неймана — широко известный принцип совместного хранения команд и данных в памяти
                компьютера. Вычислительные машины такого рода часто обозначают термином «машина фон Неймана», однако
                соответствие этих понятий не всегда однозначно. В общем случае, когда говорят об архитектуре фон
                Неймана, подразумевают принцип хранения данных и инструкций в одной памяти.
                1) Принцип двоичности. Для представления данных и команд используется двоичная система счисления. 2)
                Принцип программного управления. Программа состоит из набора команд, которые выполняются процессором
                друг за другом в определённой последовательности. 3) Принцип однородности памяти. Как программы
                (команды), так и данные хранятся в одной и той же памяти. Над командами можно выполнять такие же
                действия, как и над данными. 4) Принцип адресуемости памяти. Структурно основная память состоит из
                пронумерованных ячеек; процессору в произвольный момент времени доступна любая ячейка. 5) Принцип
                последовательного программного управления. Все команды располагаются в памяти и выполняются
                последовательно, одна после завершения другой. 6) Принцип условного перехода. Команды из программы не
                всегда выполняются одна за другой. Возможно присутствие в программе команд условного перехода, которые
                изменяют последовательность выполнения команд в зависимости от значений данных.
            </p>
        </li>
        <li>
            <h4>Языки программирования и их классификация.</h4>
            <p>ПК называют тем что чётко формулирует задания пользуясь инструкцией. Для представления ПК алгоритма в
                понятном виде и нужны языки программирования. Совокупность требований для записи команд образуют
                синтаксис языка. Нарушение формы записи программы приводит к синтаксической ошибке. Классификация
                происходит по степени абстракции, по архитектуре ПК бывают: •Машинные очень ограниченный набор
                инструкций, каждая команда состоит из последовательности 0 и 1, писать на машинном языке – неудобно и
                долго, надо знать архитектуру ЭВМ, •Язык ассемблера каждая команда идентифицировалась особым именем и
                переменно можно было управлять через их имена, писать стало легче, но процессор не понимал язык, поэтому
                переводили в машинный код, стала лучше производительность, •Высокого уровня создан для решения проблем
                читабельности и скорости, можно писать программы не переживая о совместимости кода с процессором и тоже
                переводятся в машинный код. По структурному строению программы, бывают: •Объектные, •Процедурные.</p>
        </li>
        <li>
            <h4>Размещение данных и программ в памяти ПЭВМ.</h4>
            <p>Данные и программы во время работы ПЭВМ размещаются в оперативной памяти, которая представляет собой
                последовательность пронумерованных ячеек. По указанному номеру процессор находит нужную ячейку, поэтому
                номер ячейки называется ее адресом. Минимальная адресованная ячейка (согласно стандарту IBM), с точки
                зрения программиста, состоит из 8 двоичных позиций, т.е. в каждую позицию могут быть записаны либо 0,
                либо 1. Объем информации, который помещается в одну двоичную позицию, называется битом. Объем
                информации, равный 8 битам, называется байтом. В одной ячейке из 8 двоичных разрядов помещается объем
                информации в один байт. Поэтому объем памяти принято оценивать количеством байт (210 байт = 1024 байт =
                1 Кб, 210 Кб = 1048576 байт = 1 Мб).</p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
        <li>
            <h4></h4>
            <p></p>
        </li>
    </ol>
</body>

</html>