export const text = `
  Изучение React Native для создания мобильных приложений на JavaScript Бонни Эйзенман Изучение React Native от Бонни Эйзенман Авторские права © 2016 Бонни Эйзенман. Все права защищены. Напечатано в Соединенных Штатах Америки. Опубликовано O'Reilly Media, Inc., Северное шоссе Грейвенштейн, 1005, Севастополь, КАЛИФОРНИЯ 95472. Книги О'Рейли можно приобрести в образовательных, деловых или рекламных целях. Для большинства изданий также доступны онлайн-издания (http://safaribooksonline.com). За дополнительной информацией обращайтесь в наш отдел корпоративных/институциональных продаж: 800-998-9938 или corporate@oreilly.com. Редактор: Мэг Фоули Редактор-постановщик: Николас Адамс Редактор-переписчик: Жасмин Квитин Корректор: Кристина Эдвардс Индексатор: Эллен Траутман-Заиг Дизайнер интерьера: Дэвид Футато КоувДизайнер r: Рэнди Комер Иллюстратор: Ребекка Демарест Декабрь 2015 г.: История редакций первого издания 2015-12-01: Первый выпуск Смотрите http://oreilly.com/catalog/errata.csp?isbn=9781491929001 для получения подробной информации о выпуске. Логотип O'Reilly является зарегистрированнымтоварным знаком O'Reilly Media, Inc. Learning React Native, изображение на обложке и связанный с ним фирменный стиль являются товарными знаками O'Reilly Media, Inc. Хотя издатель и автор приложили добросовестные усилия для обеспечения точности информации и инструкций, содержащихся в этой работе, издатель и автор снимают с себя всякую ответственность за ошибки или упущения, включая, помимо прочего, ответственность за ущерб, возникший в результате использования этой работы или доверия к ней. Вы используете информацию иинструкции, содержащиеся в этой работе, на свой страх и риск. Если какие-либо образцы кода или другие технологии, содержащиеся или описываемые в этой работе, подпадают под действие лицензий с открытым исходным кодом или прав интеллектуальной собственности других лиц, вы несете ответственность за то, чтобы их использование соответствовало таким лицензиям и / или правам. 978-1-491-92900-1 [LSI] Предисловие Эта книга представляет собой введение в React Native, Facebook JavaScript Framework для создания мобильных приложений. Используя имеющиеся у вас знания JavaScript и React, высможете создавать и развертывать полнофункциональные мобильные приложения как для iOS, так и для Android, которые действительно визуализируются изначально. Просто потому, что это JavaScript, не означает, что мы должны соглашаться на меньшее. Работа с React Native имеет множество преимуществ по сравнению страдиционными средствами мобильной разработки, и нам не нужно жертвовать нативным внешним видом. Мы начнем с основ и пройдем путь к развертыванию полноценного приложения как в iOS App Store, так и в Google Play Store со 100% повторнымиспользованием кода между двумя платформами. В дополнение к основам фреймворка, мы обсудим, как работать за его пределами, в том числе как использовать библиотеки сторонних производителей и даже как написать свои собственные библиотеки Java или Objective-C для расширения React Native. Если выподходите к разработке мобильных приложений с точки зрения инженера-программиста или веб-разработчика, эта книга для вас. React Native - довольно удивительная штука, и я надеюсь, что вы так же взволнованы ее изучением, как и я! Предварительные требования Эта книга не являетсявведением в React в целом. Мы предположим, что вы обладаете некоторыми практическими знаниями о React. Если вы новичок в React, я предлагаю прочитать одно-два руководства, прежде чем возвращаться к мобильной разработке. В частности, вы должныбыть знакомы с ролью реквизитов и состояния, жизненным циклом компонента и тем, как создавать компоненты React. Мы также будем использовать некоторый синтаксис ES6, а также JSX. Если вы не знакомы с ними, не волнуйтесь; мы рассмотрим JSX в главе 2, а синтаксис ES6 в Приложении A. Эти функции, по сути, представляют собой переводы 1: 1 кода JavaScript, к написанию которого вы уже привыкли. В этой книге предполагается, что вы разрабатываете на OS X. Разработка на OS X является обязательным условием для написания приложений для iOS. Linux и Windows поддерживаютr написание приложений для Android находится в стадии разработки. Подробнее о поддержке Linux и Android вы можете прочитать здесь. Условные обозначения, используемые в этой книге В этой книге используются следующие типографские обозначения: Курсивом выделены новые термины, URL-адреса, адреса электронной почты, filenames и расширения файлов. Постоянная ширина, используемая для списков программ, а также внутри абзацев для обозначения программных элементов, таких как имена переменных или функций, базы данных, типы данных, переменные среды, операторы и ключевые слова. Постоянная ширина bold Показывает команды или другой текст, который пользователь должен вводить буквально. Курсивом постоянной ширины Показан текст, который следует заменить значениями, заданными пользователем, или значениями, определяемыми контекстом. СОВЕТ Этот элемент обозначает подсказку или предложение. ПРИМЕЧАНИЕ Этот элементозначает общее замечание. ПРЕДУПРЕЖДЕНИЕ Этот элемент обозначает предупреждение или предостережение. Использование примеров кода Дополнительный материал (примеры кода, упражнения и т.д.) Доступен для скачивания по адресу: https://github.com/bonniee/learning-react-native. Эта книга находится здесь, чтобы помочь вам выполнить вашу работу. Как правило, если в этой книге предлагается пример кода, вы можете использовать его в своих программах и документации. Вам не нужно обращаться к нам за разрешением, если вы не воспроизводите значительную часть кода. Например,для написания программы, использующей несколько фрагментов кода из этой книги, не требуется разрешения. Для продажи или распространения компакт-диска с примерами из книг О'Рейли требуется разрешение. Для ответа на вопрос путем цитирования этой книги и примера кода не требуется разрешения. Включение значительного количества примеров кода из этой книги в документацию вашего продукта требует разрешения. Мы ценим, но не требуем указания авторства. Указание авторства обычно включает название, автора, публикациюer и ISBN. Например: “Изучение языка React Native Бонни Эйзенман (О'Рейли). Авторское право 2016 Бонни Айзенман, 978-1-491-92900-1.” Если вы чувствуете, что использование вами примеров кода выходит за рамки добросовестного использования или разрешения, данного выше, не стесняйтесь обращаться к нам по адресу permissions@oreilly.com. Safari® Books Online ПРИМЕЧАНИЕ Safari Books Online - это электронная библиотека по запросу, которая предоставляет экспертный контент как в виде книг, так и в виде видео от ведущих мировых авторов в области технологий и бизнеса. Специалисты в области технологий, разработчики программного обеспечения, веб-дизайнеры, а также профессионалы бизнеса и креатива используют онлайн-книги Safari в качестве основного ресурса для исследований, решения проблем, обучения и сертификации. Safari Books Online предлагает широкий выбор планов и цен для предприятий, бизнеса, образования и частных лиц. Участники имеют доступ к тысячам книг, обучающих видеороликов и рукописей, подготовленных к публикации, в одной базе данных с возможностью полного поиска от таких издательств, как O'Reilly Media, Prentice Hall Professional, Addison-Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, Course Technology и сотен других. Для получения дополнительной информации о Safari Books Online, пожалуйста, посетите наш сайт онлайн. Как связаться с нами Пожалуйста, присылайте комментарии и вопросы, касающиеся этой книги, издателю: O'Reilly Media, Inc. 1005 Gravenstein Highway North Севастополь, КАЛИФОРНИЯ 95472 800-998-9938 (в Соединенных Штатах или Канаде) 707-829-0515 (международный или местный) 707-829-0104 (факс) У нас есть веб-страница этой книги, где перечислены ошибки, примеры и любая дополнительная информация. Вы можете получить доступ к этой странице по адресу http://bit.ly/learning-react-native. Чтобыпрокомментировать или задать технические вопросы об этой книге, отправьте электронное письмо по адресу bookquestions@oreilly.com. Для получения дополнительной информации о наших книгах, курсах, конференциях и новостях посетите наш веб-сайт по адресу http://www.oreilly.com. Найдите нас на Facebook: http://facebook.com/oreilly Следитеза нами в Twitter: http://twitter.com/oreillymedia Следите за нами на YouTube: http://www.youtube.com/oreillymedia Ресурсы Ходить в одиночку опасно! Ну, не совсем, но это не значит, что вы должны. Вот некоторые ресурсы, которые могут оказаться полезными при работе с книгой: Репозиторий GitHub для этой книги содержит все примеры кода, которые мы будем обсуждать. Если вы зашли в тупик или хотите получить больше информации, попробуйте сначала заглянуть сюда. Присоединяйтесь к списку рассылки по адресу LearningReactNative.com для получения последующих статей, предложенийns и полезных ресурсов. В официальной документации содержится много хорошего справочного материала. Кроме того, полезным ресурсом является сообщество React Native: информационный бюллетень Брента Ватна React Native С тегом react-native в Stack Overflow #reactnative (irc://чат.freenode.net/reactnative ) традиционное признание Freenode: эта книга была бы невозможна без помощи и поддержки многих других. Спасибо моему редактору Мэг Фоули и остальным членам команды O'Reilly за то, что представили этот проектмиру. Спасибо также моим техническим рецензентам за ваше время и ценные отзывы: Дэвиду Биберу, Джейсону Брауну, Эрике Портной и Джонатану Старку. Я также хотел бы поблагодарить команду разработчиков React Native, без чьей выдающейся работы эта книга была бы, естественно, невозможна.Также спасибо Захари Эллиоту за его помощь с приложением Zebreto и Android в целом. И я хочу выразить огромную благодарность моим дорогим друзьям, которые терпели меня на протяжении всего этого процесса и оказывали моральную поддержку, направляли и отвлекали, как того требовала ситуация. Спасибо. Глава 1. Что такое React Native? React Native - это JavaScript-фреймворк для написания реальных мобильных приложений с нативным рендерингом для iOS и Android. Он основан на React, библиотеке JavaScript Facebook для создания user интерфейсов, но нацелен не на браузер, а на мобильные платформы. Другими словами: веб-разработчики теперь могут писать мобильные приложения, которые выглядят и ощущаются по-настоящему “родными”, и все это с комфортом благодаря библиотеке JavaScript, которую мы уже знаем и любим. Кроме того, поскольку большая часть написанного вами кода может использоваться совместно между платформами, React Native упрощает одновременную разработку как для Android, так и для iOS. Подобно React для Интернета, приложения React Native пишутся с использованием смеси JavaScript и XML-разметки, известной как JSX. Затем, под капотом, “мост” React Native вызывает собственные API рендеринга в Objective-C (для iOS) или Java (для Android). Таким образом, ваше приложение будет отрисовываться с использованием реальных компонентов мобильного пользовательского интерфейса, а не веб-просмотров, и будет выглядетьнормально и ощущаться как любое другое мобильное приложение. React Native также предоставляет интерфейсы JavaScript для API-интерфейсов платформы, поэтому ваши приложения React Native могут получать доступ к функциям платформы, таким как камера телефона или местоположение пользователя. В настоящее время React Native поддерживает как iOS, так и Android, и имеет потенциал для распространения на будущие платформы. В этой книге мы рассмотрим как iOS, так и Android. Подавляющее большинство кода, который мы напишем, будет кроссплатформенным. И да: вы действительно можете использовать React Native для создания готовых к работе мобильныхприложений! Небольшой анекдот: Facebook, Palantir и TaskRabbit уже используют его в производстве для пользовательских приложений. Преимущества React Native Тот факт, что React Native фактически выполняет рендеринг с использованием стандартных API рендеринга своей хост-платформы,позволяет ему выделяться среди большинства существующих методов разработки кроссплатформенных приложений, таких как Cordova или Ionic. Существующие методы написания мобильных приложений с использованием комбинаций JavaScript, HTML и CSS обычно визуализируются с использованием webviews. Хотя этотподход может работать, у него также есть недостатки, особенно в отношении производительности. Кроме того, они обычно не имеют доступа к набору собственных элементов пользовательского интерфейса хост-платформы. Когда эти фреймворки действительно пытаются имитировать элементы собственного пользовательского интерфейса, результаты обычно немного “feel”; обратный инжиниринг всех мелких деталей таких вещей, как анимация, требует огромных усилий, и они могут быстро устареть. Напротив, React Native фактически преобразует вашу разметку в реальные, собственные элементы пользовательского интерфейса, используясуществующие средства рендеринга представлений на любой платформе, с которой вы работаете. Кроме того, React работает отдельно от основного потока пользовательского интерфейса, поэтому ваше приложение может поддерживать высокую производительность без ущерба для возможностей. Цикл обновления в React Native такой же, как и в React: при изменении реквизитов или состояния React Native повторно отображает представления. Основное различие между React Native и React в браузере заключается в том, что React Native делает это, используя библиотеки пользовательского интерфейса своей основной платформы, а нене используя разметку HTML и CSS. Для разработчиков, привыкших работать в Интернете с React, это означает, что вы можете писать мобильные приложения с производительностью и внешним видом нативного приложения, используя при этом знакомые инструменты. Реагировать родной и представляет собой импровизациюхарактеристиками по сравнению с обычной мобильной разработки в двух других областях: разработки и разработки кроссплатформенных потенциал. Опыт разработчика Если вы когда-либо раньше занимались разработкой для мобильных устройств, то, возможно, будете удивлены тем, насколько легко работать с React Native.Команда React Native встроила в фреймворк мощные инструменты разработчика и значимые сообщения об ошибках, поэтому работа с надежными инструментами является естественной частью вашего опыта разработки. Например, поскольку React Native - это “просто” JavaScript, вам не нужно перестраивать ваше приложение, чтобы увидеть отражение ваших изменений; вместо этого вы можете нажать Command + R, чтобы обновить ваше приложение точно так же, как вы обновили бы любую другую веб-страницу. Все эти минуты, потраченные на ожидание сборки вашего приложения, действительно могут накапливаться, и в coбыстрый цикл итераций ntrast React Native кажется подарком судьбы. Кроме того, React Native позволяет вам воспользоваться преимуществами интеллектуальных инструментов отладки и создания отчетов об ошибках. Если вам знакомы инструменты разработчика Chrome или Safari (рис. 1-1), вы будетерады узнать, что их можно использовать и для мобильной разработки. Аналогично, вы можете использовать любой текстовый редактор, который вы предпочитаете для редактирования JavaScript: React Native не заставляет вас работать в Xcode для разработки под iOS или Android Studio для разработки под Androident. Рисунок 1-1. Использование Chrome Debugger Помимо повседневных улучшений в процессе разработки, React Native также может положительно повлиять на цикл выпуска вашего продукта. Например, Apple разрешает загружать изменения поведения app на основе JavaScript по воздуху без необходимости дополнительного цикла проверки. Все эти небольшие льготы в совокупности экономят время и энергию вам и вашим коллегам-разработчикам, позволяя вам сосредоточиться на более интересных участках вашей работы и быть более продуктивнымив целом. Повторное использование кода и обмен знаниями При работе с React Native может значительно сократить ресурсы, необходимые для создания мобильных приложений. Любой разработчик, который знает, как писать код React, теперь может работать в Интернете, на iOS и Android, и все это с набором навыков same. Устраняя необходимость изолировать разработчиков в зависимости от их целевой платформы, React Native позволяет вашей команде выполнять итерации быстрее и более эффективно обмениваться знаниями и ресурсами. Помимо общих знаний, большая часть вашего кода также может быть общедоступной. Не весь код, который вы пишете, будет кроссплатформенным, и в зависимости от того, какая функциональность вам нужна на конкретной платформе, вам может иногда потребоваться погрузиться в Objective-C или Java. (К счастью, это не так уж плохо, и мы рассмотрим, как работают так называемые собственные модули, вглаве 7.) Но повторное использование кода на разных платформах на удивление просто с React Native. Например, приложение Facebook Ads Manager для Android использует 87% своей кодовой базы совместно с версией для iOS, как отмечается в докладе React Europe 2015. Окончательный заявлобработки мы рассмотрим в этой книге, флэш-приложение, имеет общую повторного использования кода между iOS и Android. Трудно побить. Риски и недостатки Как и во всем остальном, использование React Native не лишено недостатков, и подходит ли React Native для вашей команды или нет, действительно зависит от вашей индивидуальной ситуации. Вероятно, наибольший риск связан со зрелостью React Native, поскольку проект все еще относительно молод. Поддержка iOS была выпущена в марте 2015 года, а Android - в сентябре 2015 года. У документа, безусловно, есть возможности для улучшения, и он продолжает развиваться. Некоторые функции на iOS и Android по-прежнему не поддерживаются, и сообщество все еще изучает лучшие практики. Хорошей новостью является то, что в подавляющем большинстве случаев вы можете самостоятельно реализовать поддержкупорта для отсутствующих API, о чем мы расскажем в главе 7. Поскольку React Native привносит в ваш проект еще один уровень, он также может упростить отладку, особенно на пересечении React и хост-платформы. Мы более подробно рассмотрим отладку для React Native в главе 8 и попытаемся решить некоторые из наиболее распространенных проблем. React Native все еще молод, и здесь применимы обычные предостережения, связанные с работой с новыми технологиями. Тем не менее, в целом, я думаю, вы увидите, что выгодаперевешивает риски. Краткое описание React Native - это захватывающий фреймворк, который позволяет веб-разработчикам создавать надежные мобильные приложения, используя имеющиеся у них знания JavaScript. Он обеспечивает более быструю мобильную разработку и более эффективный обмен кодом между iOS, Android и Интернетом без ущерба для опыта конечного пользователя или качества приложения. Компромисс заключается в том, что это ново и все еще находится в стадии разработки. Если ваша команда может справиться с неопределенностью, возникающей при работе с новой технологией, и хочетбыстро создавать мобильные приложения не только для одной платформы, вам следует обратить внимание на React Native. В следующей главе мы рассмотрим некоторые основные отличия React Native от React для Интернета и рассмотрим некоторые ключевые концепции. Если вы хотитесразу перейти к разработке, смело переходите к главе 3, в которой мы разберемся с настройкой нашей среды разработки и напишем наше самое первое приложение React Native. Глава 2. Работа с React Native В этой главе мы рассмотрим “мост” и рассмотрим, как React Native работает под капотом. Затем мы рассмотрим, чем компоненты React Native отличаются от своих веб-аналогов, и расскажем о том, что вам нужно знать, чтобы создавать компоненты для мобильных устройств и стилизовать их. Обратите внимание, если вы предпочитаете копать в Deразвитие процесса и ознакомиться с реагировать родной в действии, не стесняйтесь сразу перейти к следующей главе! Как Реагировать Родной Работу? Идея написания мобильных приложений на JavaScript кажется немного странной. Как можно использовать React в мобильной среде? В чтобы понять техническую основу React Native, сначала нам нужно вспомнить одну из функций React - Виртуальный DOM. В React виртуальный DOM действует как слой между описанием разработчиком того, как все должно выглядеть, и работой, выполняемойдля фактического отображения вашего приложения на странице. Чтобы отобразить интерактивные пользовательские интерфейсы в браузере, разработчики должны отредактировать DOM браузера, или объектную модель документа. Это дорогостоящий шаг, и чрезмерные операции записи в DOM оказывают значительное влияние напроизводительность. Вместо того, чтобы напрямую отображать изменения на странице, React вычисляет необходимые изменения, используя версию DOM в памяти, и повторно отображает минимально необходимый объем. На рисунке 2-1 показано, как это работает. Рис. 2-1. Выполнение вычисленийns в виртуальном DOM ограничивает повторный рендеринг в DOM браузера В контексте React в Интернете большинство разработчиков рассматривают виртуальный DOM в первую очередь как оптимизацию производительности. Виртуальный DOM, безусловно, имеет преимущества в производительности, но его реальный потенциал заключаетсяв силе его абстракции. Размещение чистого слоя абстракции между кодом разработчика и фактическим рендерингом открывает множество интересных возможностей. Что, если React сможет выполнять рендеринг для цели, отличной от DOM браузера? В конце концов, React already “понимает”, как должно выглядеть ваше приложение. Действительно, именно так работает React Native, как показано на рисунке 2-2. Вместо рендеринга в DOM браузера React Native вызывает API Objective-C для рендеринга компонентов iOS или Java API длярендеринга компонентов Android. Это отличает React Native от других вариантов разработки кроссплатформенных приложений, которые часто заканчиваются отображением веб-представлений. Рисунок 2-2. React может выполнять рендеринг для разных целей. Все это возможно благодаря “мосту”, которыйпредоставляет React интерфейс к собственным элементам пользовательского интерфейса хост-платформы. Компоненты React возвращают разметку из своей функции рендеринга, которая описывает, как они должны выглядеть. С React для Интернета это преобразуется непосредственно в DOM браузера. Для React Native эта разметка преобразуется в соответствии с платформой хоста, поэтому <View> может стать UIView для конкретной iOS. React Native в настоящее время поддерживает iOS и Android. Из—за уровня абстракции, предоставляемого виртуальным DOM, React Native может быть нацелен и на другиеr-платформы - кому-то просто нужно написать мост. Жизненный цикл рендеринга Если вы привыкли работать в React, жизненный цикл React должен быть вам знаком. Когда React запускается в браузере, жизненный цикл рендеринга начинается с установки компонентов вашего компьютера React (рис. 2-3). Рис. 2-3. Монтирование компонентов в React После этого React обрабатывает рендеринг и повторную визуализацию вашего компонента по мере необходимости (рис. 2-4). Рис. 2-4. При повторном рендеринге компонентов в React На этапе рендеринга разработчик возвращает HTML разметку из метода рендеринга компонента React, который React затем рендерит непосредственно на странице по мере необходимости. Для React Native жизненный цикл тот же, но процесс рендеринга немного отличается, потому что React Native зависит от моста. Мы кратко рассмотрели мост ранее на рисунке 2-2. Мост переводит вызовы JavaScript и вызывает базовые API-интерфейсы хост-платформы и элементы пользовательского интерфейса (т. Е. на Objective-C или Java, в зависимости от обстоятельств). Поскольку React Native не запускается в основном потоке пользовательского интерфейса, он может выполнять эти асинхронные вызовы, не влияя на работу пользователя. Создание компонентов в React Native Весь код React хранится в компонентах React. Собственные компоненты React в основном такие же, как обычные компоненты React, с некоторыми важными отличиямив отношении рендеринга и стиля. Работа с представлениями При написании в React для Web вы визуализируете обычные HTML-элементы (<div>, <p>,ble 2-1). The most basic is the cross-platform <View>, a simple and flexible UI element that can be thought of as analogous to the <div>. On iOS, for instance, the <View> component renders to a UIView, while on Android it renders to a View. Table 2-1. Basic elements for the Web, compared with React Native React React Native <div> <View> <span> <Text> <li>, <ul> <ListView> <img> <Image> Other components are platform-specific. For instance, the <DatePickerIOS> component (predictably) renders the iOS standard <Text> <li>, <ul> <ListView> <img> <Image> Другие компоненты зависят от платформы. Например, компонент <DatePickerIOS> (как и ожидалось) отображает стандартный для iOSсредство выбора даты. Вот выдержка из примера приложения UIExplorer, демонстрирующего средство выбора даты для iOS. Использование, как и следовало ожидать, простое: <DatePickerIOS date={this.state.date} mode="date" timeZoneOffsetInMinutes={this.state.timeZoneOffsetInHours * 60} /> Это отображается в стандартном средстве выбора даты iOS (рис. 2-5). Рис. 2-5. DatePickerIOS, как следует из названия, зависит от iOS, поскольку все элементы нашего пользовательского интерфейса теперь являются компонентами React, а не базовыми элементами HTML, такими как <div>, вам нужно будет явно импортировать каждый компонент, который вы хотите использовать. Например, нам нужно было импортировать компонент <DatePickerIOS> следующим образом: var React = require('react-native'); var { DatePickerIOS } = React; Приложение UIExplorer, которое входит в stи содержит примеры React Native, позволяет просматривать все поддерживаемые элементы пользовательского интерфейса. Я рекомендую вам изучить различные элементы, включенные в приложение UIExplorer. Оно также демонстрирует множество вариантов оформления и взаимодействия. СОВЕТ Компоненты, зависящие от платформы,и API-интерфейсы имеют специальные теги в документации и обычно используют название платформы в качестве суффикса — например, <SwitchAndroid> и <SwitchIOS>. Поскольку эти компоненты различаются от платформы к платформе, то, как вы структурируете свои компоненты React, становится еще болееважным при работе в React Native. В React для Интернета у нас часто есть сочетание компонентов React: некоторые управляют логикой и их дочерними компонентами, в то время как другие компоненты отображают необработанную разметку. Если вы хотите повторно использовать код при работе в React Native, постоянноеразделение между этими типами компонентов становится критичным. Компонент React, который отображает элемент <DatePickerIOS>, очевидно, не может быть повторно использован для Android. Однако компонент, который инкапсулирует связанную логику, может быть использован повторно. Затем компонент viewможно заменить в зависимости от вашей платформы. Вы также можете указать версии компонентов, зависящие от платформы, если хотите, чтобы у вас могли быть, например, файлы a picker.ios.js и a picker.android.js. Мы рассмотрим это в разделе “Компоненты сэффективными версиями для платформы Sp”. Использование JSX В React Native, как и в React, мы пишем наши представления с использованием JSX, объединяя разметку и JavaScript, который управляет ею, в один файл. JSX вызвал бурную реакцию, когда React впервые дебютировал. Для многих веб-разработчиков разделениефайлов на основе технологий является само собой разумеющимся: вы храните свои файлы CSS, HTML и JavaScript отдельно. Идея объединения разметки, управляющей логики и даже стилизации в одном языке может сбивать с толку. JSX уделяет приоритетное внимание разделению интересов, а неразделению технологий. В React Native это соблюдается еще строже. В мире без браузера еще более разумно унифицировать наши стили, разметку и поведение в одном файле для каждого компонента. Соответственно, ваши файлы .js в React Native на самом деле являются файлами JSX. Если вы использовали ванильный JavaScript при работе с React для Web, вам захочется перейти к синтаксису JSX для вашей работы в React Native. Если вы никогда раньше не видели JSX, не волнуйтесь: это довольно просто. В качестве примера, компонент pure- JavaScript React для Интернета может выглядеть примерно так: var HelloMessage = React.createClass({ DisplayName: "HelloMessage", render: функция render() { возвращает React.createElement( "div", null, "Hello", this.props.name ); } }); React.render(React.createElement(HelloMessage, { имя: "Бонни" }), mountNode); Мы можем отобразить это более кратко, используя JSX. Вместо вызова React.createElement и передачи списка HTML-атрибутов мы используем XML-подобную разметку: var HelloMessage = React.createClass({ render: function() { // Вместо вызова createElement мы возвращаем разметку return <div>Hello {this.props.name }</div>; } }); // Нам больше не нужен вызов createElement здесь React.render(<HelloMessage name="Bonnie" />, mountNode); Оба этих вызовадобавят на страницу следующий HTML-код: <div>Привет, Бонни</div> Создавая собственные компоненты в Интернете, мы оформляем компоненты React с помощью CSS, как и любой другой HTML-элемент. Любите вы это или ненавидите, CSS - необходимая часть Интернета. Реакция на насв принципе не влияет на то, как мы пишем CSS. Это действительно упрощает использование (разумных, полезных) встроенных стилей и динамическое построение имен классов на основе реквизитов и состояния, но в остальном React в основном не зависит от того, как мы обрабатываем стили в Интернете. Не веб-platforms имеют широкий спектр подходов к верстке и стилю. К счастью, когда мы работаем с React Native, мы используем один стандартизированный подход к стилю. Часть моста между React и хост-платформой включает в себя реализацию сильно урезанногорасширенного подмножества CSS. Эта узкая реализация CSS опирается в первую очередь на flexbox для верстки и фокусируется на простоте, а не на реализации всего спектра правил CSS. В отличие от Интернета, где поддержка CSS варьируется в зависимости от браузера, React Native способен обеспечитьсогласованную поддержку правил стиля. Подобно различным элементам пользовательского интерфейса, вы можете увидеть множество примеров поддерживаемых стилей в приложении UIExplorer, которое является одним из примеров, поставляемых с React Native. React Native также настаивает на использовании встроенныхстилей e, которые существуют как объекты JavaScript. Команда React ранее выступала за этот подход в React для веб-приложений. Если вы ранее экспериментировали со встроенными стилями в React, синтаксис покажется вам знакомым: // Define a style… varstyle = { backgroundColor: 'белый', FontSize: '16px'}; // ... а затем примените его. var tv = ( <Text style={style}> Стилизованный текст </Text>); React Native также предоставляет нам некоторые утилиты для создания и расширения объектов стилей, которые делают работу со встроеннымистилями более управляемым процессом. Мы рассмотрим их позже, в главе 5. Заставляет ли вас дергаться при просмотре встроенных стилей? Исходя из опыта работы в Интернете, это, по общему признанию, отход от стандартных практик. Работа с объектами стилей, в отличие оттаблиц стилей, требует некоторых ментальных настроек и меняет подход к написанию стилей. Однако в контексте React Native это полезный сдвиг. Мы обсудим рекомендации по стилю и рабочий процесс позже, в главе 5. Просто неудивляйтесь, когда увидите их в действии! API-интерфейсы платформы хостинга Возможно, самое большое различие между React для Интернета и React Native заключается в том, как мы относимся к API-интерфейсам платформы хостинга. В Интернете рассматриваемая проблема часто носит фрагментарный характер и противоречитряду стандартов; тем не менее, большинство браузеров поддерживают общее ядро общих функций. Однако в React Native API, зависящие от платформы, играют гораздо большую роль в создании превосходного, естественного пользовательского интерфейса. Также можно рассмотретьгораздо больше возможностей. Мобильные API включают в себя все - от хранилища данных до служб определения местоположения и доступа к оборудованию, такому как камера. По мере распространения React Native на другие платформы мы можем ожидать появления и других видов API; как, например, будет выглядеть интерфейс между React Native и гарнитурой виртуальной реальности? По умолчанию React Native для iOS и Android включает поддержку многих часто используемых функций, а React Native может поддерживать любой асинхронный собственный API. Мы рассмотрим многие из них на протяжении этой книги. React Native упрощает использование API-интерфейсов хост-платформы, так что вы можете свободно экспериментировать. Обязательно подумайте о том, что кажется “правильным” для вашей целевой платформы, и проектируйте с учетом естественных взаимодействий. Неизбежно,мост React Native bridge не будет предоставлять всю функциональность хост-платформы. Если вам понадобится неподдерживаемая функция, у вас есть возможность добавить ее в React Native самостоятельно. С другой стороны, велика вероятность, что кто-то другой ужесделал это, поэтому обязательно свяжитесь с сообществом, чтобы узнать, будет ли оказана поддержка. Мы рассмотрим это в главе 7. Также стоит отметить, что использование API-интерфейсов хост-платформы имеет последствия для повторного использования кода. Компоненты React, которым требуются спецификации платформы,функциональность ific также будет зависеть от платформы. Изоляция и инкапсуляция этих компонентов обеспечит дополнительную гибкость вашего приложения. Конечно, это относится и к Интернету: если вы планируете совместно использовать код между React Native и React,имейте в виду, что таких вещей, как DOM, на самом деле не существует в React Native. Написание компонентов для мобильных устройств в React Native немного отличается от React для Интернета. JSX является обязательным, и нашими основными строительными блоками теперь являются такие компоненты, какs <View> вместо HTML-элементов, таких как <div>. Стиль также сильно отличается, он основан на подмножестве CSS, и мы назначаем стили с помощью встроенного синтаксиса. Тем не менее, этими настройками вполне можно управлять. В следующей главе мы применим это на практике при создании нашего первого приложения! Глава 3. Создание вашего первого приложения В этой главе мы расскажем, как настроить вашу локальную среду разработки для работы с React Native. Затем мы рассмотрим основы создания простого приложения, которое вы затем сможете развернуть на своем собственном устройстве с iOS или Android. Настройка среды Настройка среды разработки позволит вам следовать примерам, приведенным в книге, и позволит вам писать свои собственные приложения! Инструкции по установке React Native можно найти в официальной документации React Native. Официальный сайт будет для вас самым актуальным справочником по конкретным шагам установки, но мы также рассмотрим их здесь. Вам нужно будет использовать Homebrew,распространенный менеджер пакетов для OS X, чтобы установить зависимости React Native. На протяжении всей этой книги мы будем исходить из того, что вы разрабатываете на OS X, которая позволяет вам писать приложения как для iOS, так и для Android. После установки Homebrew запустите fкоманду из командной строки: brew install node, brew install watchman, brew install flow Упаковщик React Native использует как node, так и watchman, поэтому, если в будущем с упаковщиком возникнут проблемы, стоит обновить эти зависимости. flow - это библиотека Facebook для проверки type, которая также используется React Native. (Если вы хотите включить проверку типов в своих проектах React Native, вы можете использовать flow!) Если вы столкнетесь с трудностями, вам может потребоваться обновить brew и любые пакеты (обратите внимание, что выполнение этих команд можетзанять некоторое время): brew update brew upgrade Если после выполнения этого вы увидите ошибки, вам необходимо исправить локальную настройку brew. brew doctor может указать вам на возможные проблемы. Установка React Native Теперь, когда у вас установлен node, вы можете использовать npm (диспетчер пакетов Node) для установки средств командной строки React Native: npm install -g react-native-cli Это устанавливает средства командной строки React Native глобально в вашей системе. После этого поздравляем; React Native установлен! Далее вам нужно будетвыполнить настройку для конкретной платформы. Чтобы разрабатывать для данной мобильной платформы, вам необходимо установить зависимости разработки для этой платформы. Чтобы продолжить чтение этой главы, вы можете выбрать iOS, Android или обе. Зависимости от iOS Для разработкиelop и выпуска приложений для iOS вам необходимо будет приобрести учетную запись разработчика iOS. Учетная запись бесплатна, и ее достаточно для разработки. Для развертывания приложений в iOS App Store вам в конечном итоге понадобится лицензия, стоимость которой составляет 99 долларов в год. Если выеще этого не сделали, вам потребуется загрузить и установить Xcode, который включает в себя Xcode IDE, симуляторы iOS и iOS SDK. Вы можете загрузить Xcode из App Store или с веб-сайта Xcode. После установки Xcode примите лицензию, ивсе будет готово. Зависимости Android Установка Android - это многоступенчатый процесс. Вам следует ознакомиться с официальной документацией для получения самых актуальных инструкций. Обратите внимание, что в этих инструкциях предполагается, что у вас еще нет настроенной среды дляразработки droid. В общих чертах, существует три основных этапа: установка SDK, установка инструментов моделирования и создание симуляторов для использования. Сначала вам необходимо установить JDK (Java Development Kit) и SDK для Android: 1. Установите последнюю версию JDK. 2. Установите Android SDK, используя brew install android-sdk. 3. Экспортируйте вашу переменную ANDROID_HOME соответствующим образом в файл конфигурации вашей оболочки (~ /.bashrc, ~ /.zshrc или в зависимости от того, что использует ваша оболочка): export ANDROID_HOME = / usr / local / opt / android-sdk Этапеременная среды используется для многих задач разработки, связанных с Android; обязательно укажите исходный код вашей конфигурации оболочки после ее добавления. Затем запустите Android из командной строки, чтобы открыть Android SDK Manager. Это покажет вам доступные пакеты, которые вы можете установить (см.Рисунок 3-1). Рисунок 3-1. Android SDK Manager позволяет вам выбирать, какие пакеты устанавливать, дождитесь обновления SDK Manager и загрузите список пакетов. Некоторые пакеты уже будут проверены по умолчанию. Также не забудьте установить флажки для: Android SDK Build-tools версии 23.0.1 Android 6.0 (API 23) Репозиторий поддержки Android Затем нажмите Установить пакеты и примите все применимые лицензии. Установка всего этого займет некоторое время. Затем вам потребуется установить симулятор и связанные с ниминструменты редактирования. Запустите новую оболочку и снова запустите Android, чтобы запустить Android SDK Manager. Мы собираемся установить еще несколько пакетов: Системный образ Intel x86 Atom (для Android 5.1.1–API 22) Intel x86 Emulator Accelerator (установщик HAXM) Еще раз нажмите "Установить"l пакетов и примите все применимые лицензии. Эти пакеты дают нам возможность создавать виртуальные устройства Android (AVD) или эмуляторы, но на самом деле у нас пока нет созданных эмуляторов. Давайте исправим это. Запустите AVD Manager (показан на рисунке 3-2) запустив: android avd Рисунок 3-2. Менеджер AVD позволяет создавать и запускать эмуляторы, затем нажмите Создать… и заполните форму создания эмулятора, показанную на рисунке 3-3. Для получения информации о параметрах эмуляции обязательно установите флажок Использовать графический процессор хоста (см. Рисунок 3-4). Рисунок 3-3. Выможете создавать любые эмуляторы, какие захотите (в этом примере я создал эмулятор Galaxy Nexus) Рис. 3-4. Обязательно установите флажок Использовать графический процессор хоста - в противном случае ваш эмулятор будет работать очень медленно! Вы можете создавать столько AVD, сколько захотите. Поскольку устройства Android сильно различаются по размеру экрана, разрешению и возможностям, часто бывает полезно использовать несколько эмуляторов для тестирования. Однако для начала нам понадобится только одно. Создание нового приложения Вы можете использовать инструменты командной строки React Native для создания нового приложенияlication. Это создаст для вас новый проект со всеми стандартными настройками React Native, iOS и Android: react-native init FirstProject Результирующий каталог должен иметь структуру, показанную на рисунке 3-5. Рисунок 3-5. Файловая структура в проекте по умолчанию Каталоги ios/ и android/ содержат шаблон, соответствующий этим платформам. Ваш код React находится в файлах index.ios.js и android.ios.js, которые являются соответствующими точками входа для вашего приложения React. Зависимости, установленные черезnpm, как обычно, можно найти в папке node_modules/ . Если вы предпочитаете, вы можете загрузить проект из репозитория GitHub для этой книги. Запуск приложения React Native для iOS Для начала мы попробуем запустить версию нашего приложения React Nдля iOS как в симуляторе, так и на физическом устройстве. Откройте файл FirstProject.xcodeproj, расположенный в каталоге ios/, в Xcode. В левом верхнем углу вы заметите кнопку "Выполнить", как показано на рисунке 3-6. Нажатие этой кнопки приведет к сборке и запуску вашего приложенияlication. Вы также можете изменить цель развертывания здесь на другой симулятор iOS. Рисунок 3-6. Кнопка Run с выбором цели развертывания При нажатии кнопки Run упаковщик React должен автоматически запуститься в новом окне терминала. Если не удается запустить, or выдает сообщение об ошибке, попробуйте запустить npm install и npm start из каталога FirstProject/ . Это должно выглядеть как скриншот, показанный на рисунке 3-7. Рисунок 3-7. Упаковщик React После того, как упаковщик будет готов, симулятор iOS запустится с приложением по умолчаниюlication. Это должно выглядеть примерно как на рисунке 3-8. Рисунок 3-8. Снимок экрана приложения по умолчанию Вам нужно, чтобы упаковщик работал постоянно во время разработки, чтобы изменения в вашем коде отражались в приложении. Если упаковщик выйдет из строя, вы можете перезапустить егоt, перейдя в каталог вашего проекта и запустив npm start. Загрузка на устройство iOS Чтобы загрузить приложение React Native на физическое устройство iOS, вам потребуется учетная запись разработчика iOS в Apple. Затем вам нужно будет сгенерировать сертификатe и зарегистрировать свое устройство. После регистрации в Apple откройте настройки Xcode и добавьте свою учетную запись, как показано на рисунке 3-9. Рисунок 3-9. Добавьте свою учетную запись в Xcode предпочтения по области Далее вам будет нужно получить сертификат для вашей учетной записи. В ЕАСИесть способ сделать это, чтобы проверить общие панели в Xcode. Как показано на рисунке 3-10, вы увидите предупреждающий символ. Нажмите на кнопку "Исправить проблему", чтобы устранить эту проблему. Xcode проведет вас по следующим нескольким шагам, необходимым для получения сертификатаот Apple. Рисунок 3-10. Скриншот приложения по умолчанию После получения сертификата вы почти закончили. Последний шаг - войти в Apple Developer и зарегистрировать свое устройство (см. Рисунок 3-11). Рисунок 3-11. Зарегистрируйте свое устройство в центре участников iOS developmenter Для получения UDID вашего устройства очень просто. Откройте iTunes и выберите свое устройство. Затем нажмите на серийный номер; теперь вместо него должен отображаться UDID, и UDID будет скопирован в ваш буфер обмена. После регистрации вашего устройства в Apple оно должно появиться в вашем списке одобренных устройств. Этот процесс регистрации также можно использовать позже, если вы хотите распространить раннюю версию на другие тестируемые устройства. Для индивидуальных разработчиков Apple выделяет вам 100 устройств в год в рамках программы разработчика.в год. Наконец, нам нужно быстро внести изменения в наш код, прежде чем мы сможем приступить к развертыванию. Вам нужно будет изменить ваш файл AppDelegate.m, чтобы включить IP-адрес вашего Mac вместо localhost. Если вы не знаете, как найти IP-адрес вашего computer, вы можете запустить ifconfig, а затем использовать значение inet в en0 . Например, если ваш IP-адрес был 10.10.12.345, вам следует отредактировать jsCodeLocation, чтобы он выглядел следующим образом: jsCodeLocation = [NSURL URLWithString:@"http://10.10.12.345:8081/index.ios.bразвернуть"]; Фу! После всего этого мы можем выбрать физическое устройство в качестве цели развертывания в Xcode (см. Рисунок 3-12). Рисунок 3-12. Выберите свое устройство iOS в качестве цели развертывания, как только это будет сделано, нажмите кнопку "Выполнить". Приложение должно загрузиться на ваше устройство точно так же, как это было в симуляторе! Если вы закроете приложение, вы увидите, что оно тоже было загружено на ваш главный экран. Запуск приложения React Native для Android Чтобы запустить приложение React Native для Android, вам нужно будет сделать две вещи: запустить эмулятор, а затем запустить ваше приложение. Ранее, на рисунке 3-2, мы видели, что мы можем запустить AVD Manager, выполнив команду: android avd Выберите эмулятор, который вы хотели бы запустить, а затем нажмите кнопку Пуск ... В качестве альтернативы вы можете запустить свои эмуляторы из командной строки. Чтобы просмотреть доступные эмуляторы, введите: emulator -list-avds, затем запустите их по имени с префиксом @. Например, у меня есть AVD с именем “galaxy”, поэтому я могу запустить следующее: emulator @galaxy Независимо от того, как вы решили запустить ваш эмулятор, после его запуска запустите ваше приложение React Native, выполнив следующее из корневого каталога вашего проекта: react-native run-android Краткое описание: Создание и запуск проектов Здесь мы рассмотрели много вопросов! Поскольку нам нужно было установить зависимости для разработки React Native, iOS и Android, это могло показаться большой работой. Хорошей новостью является то, что теперь, когда вы проделали начальную работу, в будущем все будет проще. Создать эквивалент “Hello, Worldd” в React Native так же просто, как запустить react-native init HelloWorld из командной строки. Изучение примера кода Теперь, когда вы запустили и развернули приложение по умолчанию из предыдущего раздела, давайте разберемся, как оно работает. В этом разделе мы углубимся висходный код приложения по умолчанию и исследуем структуру проекта React Native. Прикрепление компонента к представлению Когда запускается приложение React Native, каким образом компонент React привязывается к представлению? Что определяет, какой компонент отображается? Этот ответ зависит от платформы. Мы начнем с рассмотрения версии нашего проекта для iOS. Мы можем найти ответ внутри AppDelegate.m . Обратите внимание, в частности, на строки, показанные в примере 3-1. Пример 3-1. Объявление корневого представления в ios/AppDelegate.m RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@"FirstProject" launchOptions:launchOptions]; Библиотека React Native добавляет ко всем своим классам префикс RCT, что означает, что RCTRootView является классом React Native.В этом случае RCTRootView представляет корневое представление React. Оставшаяся часть стандартного кода в AppDelegate.m обрабатывает прикрепление этого представления к UIViewController и вывод представления на экран. Эти шаги аналогичны подключению компонента Reactent к DOM-узлу с вызовом React.render. На данный момент файл AppDelegate.m содержит две вещи, которые вы должны знать, как изменить. Первая - это строка jsCodeLocation , которую мы отредактировали ранее для развертывания на физическом устройстве. Как поясняют комментарии к сгенерированному файлу, первый вариант используется для разработки, в то время как второй вариант используется для развертывания с предварительно собранным файлом на диске. Пока мы оставим первый вариант без комментариев. Позже, когда мы подготовимся к развертыванию приложений в App Store, мы обсудим эти два подхода более подробно. Вам также нужно будет изменить moduleName , которое передается в RCTRootView и определяет, какой компонент будет смонтирован в представлении. Здесь вы можете выбрать, какой компонент должен бытьотрисован вашим приложением. Чтобы использовать здесь компонент FirstProject, вам необходимо зарегистрировать компонент React с таким же именем. Если вы откроете его index.ios.js, вы увидите, что это выполнено в последней строке (пример 3-2). Пример 3-2. Регистрируемкомпонент верхнего уровня AppRegistry.registerComponent('FirstProject', () => FirstProject); Это предоставляет компонент FirstProject, чтобы мы могли использовать его в AppDelegate.m . По большей части вам не нужно будет изменять этот шаблон, но полезно знать, что он там есть. Как насчет Android? История довольно похожа. Если вы посмотрите на MainActivity.java, вы заметите строку, показанную в примере 3-3. Пример 3-3. Точка входа React для Android находится в MainActivity.java mReactRootView.startReactApplication(mReactInstanceManager, "FirstProject", null); Подобно AppDelegate.m для iOS, MainActivity.java file для Android будет искать в AppRegistry компонент React, привязанный к имени FirstProject. Импорт в React Native Давайте подробнее рассмотрим файл index.ios.js . Как вы можете видеть в примере 3-4, используемые инструкции require немного отличаются от обычных. Пример 3-4. операторы require в React Native и импорт элементов пользовательского интерфейса var React = require('react-native'); var { AppRegistry, таблица стилей, Text, View, } = React; Здесь используется интересный синтаксис. React требуется, как обычно, но что происходит в следующей строке? Одна из особенностей работы с React Native заключается в том, что вам нужно явно запрашивать каждый модуль, предоставляемый с помощью React Native, с которым вы работаете. Такие вещи, как <div>, просто не существуют; вместо этого вам нужно явно импортировать компоненты, такие как <View> и <Text>. Библиотечные функции, такие как таблица стилей и AppRegistry, также явно импортируются с использованием этого синтаксиса. Как только мы начнем строить наши собственные станаций, мы будем изучать другие реагируют встроенные функции, которые могут понадобиться для импорта. Если синтаксис вам незнаком, ознакомьтесь с Примером A-2 в Приложении A для объяснения деструктурирования в ES6. Компонент FirstProject Давайте посмотрим на компонент <FПервый проект> (пример 3-5), который дублируется между index.ios.js и index.android.js (другими словами, вы можете изучить любой из них, поскольку они идентичны). Все это должно выглядеть достаточно знакомо, потому что <FirstProject> написан точно так же, как илибинарный компонент React. Основным отличием является использование компонентов <Text> и <View> вместо <div> и, а также использование объектов стиля. Пример 3-5. Компонент FirstProject со стилями var FirstProject = React.createClass({ render: function() { return ( <Стиль представления={styles.container}> <Стиль текста={styles.добро пожаловать}> Добро пожаловать на React Native! </Text> <Стиль текста={styles.instructions}> Чтобы начать, отредактируйте index.ios.js </Text> <Text style={styles.instructions}> Нажмите Cmd+R для перезагрузки,{'\n'} Cmd+D или shake для меню разработки </Text> </View> ); } }); var styles = StyleSheet.create({ контейнер: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, добро пожаловать: { Размер шрифта: 20, TextAlign: 'center', поле: 10, } , инструкции: { textAlign: 'center', color: '#333333', marginBottom: 5, }, }); Как я упоминал ранее, все стили в React Native выполняются с помощью объектов стилей, а не таблиц стилей. Стандартный способ сделать это - использовать библиотеку таблиц стилей. Вы можете видеть, какобъекты стилей определены в нижней части файла. Обратите внимание, что только компоненты <Text> могут использовать текстовые стили, такие как FontSize , и что вся логика компоновки обрабатывается flexbox. Позже мы более подробно обсудим, как создавать макеты с помощью flexbox,в главе 5. Пример приложения является хорошей демонстрацией основных функций, которые вам понадобятся для создания приложений React Native. Он монтирует компонент React для рендеринга и демонстрирует основы стилизации и рендеринга в React Native. Этотакже дало нам простой способ протестировать наши настройки разработки и попробовать развертывание на реальном устройстве. Тем не менее, это все еще очень простое приложение без взаимодействия с пользователем. Давайте попробуем создать более полнофункциональное приложение. Создание приложения погоды Мы будем использоватьобразец приложения для создания приложения погоды (вы можете создать новое для этого примера с помощью react-native init WeatherProject). Это даст нам возможность изучить, как использовать и комбинировать таблицы стилей, flexbox, сетевое взаимодействие, использоватьr-ввод и изображения в полезном приложении, которое затем мы можем развернуть на устройстве Android или iOS. Этот раздел может показаться немного размытым, поскольку мы сосредоточимся на обзоре этих функций, а не на их глубоком объяснении. Приложение "Погода" послужит вамполезным справочником в будущих разделах, когда мы будем обсуждать эти функции более подробно. Не волнуйтесь, если вам покажется, что мы продвигаемся быстро! Как показано на рисунке 3-13, окончательное приложение включает текстовое поле, в котором пользователи могут вводить почтовый индекс. Затем оно получит данныеa из API OpenWeatherMap и отобразит текущую погоду. Рисунок 3-13. Готовое приложение "Погода" Первое, что мы сделаем, это заменим код по умолчанию. Переместите исходный компонент в его собственный файл, WeatherProject.js, и замените содержимое index.ios.js и index.android.js. Пример 3-6. Упрощенное содержание index.ios.js и index.android.js (они должны быть идентичными) var React = require('react-native'); var { AppRegistry } = React; var WeatherProject = require('./WeatherProject'); AppRegistry.registerComponent('WeatherProject', () => WeatherProject); Обработка пользовательского ввода Мы хотим, чтобы пользователь мог ввести почтовый индекс и получить прогноз для этой области, поэтому нам нужно добавить текстовое поле для пользовательского ввода. Мы можем начать с добавления информации о почтовом индексе вначальное состояние нашего компонента (см. Пример 3-7). Пример 3-7. Добавьте это в свой компонент перед функцией рендеринга getInitialState: function() { return { zip: " }; } Помните, что getInitialState - это способ настройки значений начального состояния для компонентов React. Если вам нужен обзор жизненного цикла компонента React, обратитесь к документации React . Затем нам также следует изменить один из компонентов <Text> для отображения this.state.zip: <Стиль текста={стили.добро пожаловать}> Вы вводите {this.state.zip}. </Text> С учетом вышесказанногоy, давайте добавим компонент <TextInput> (это базовый компонент, который позволяет пользователю вводить текст): <TextInput style={styles.input} onSubmitEditing={this._handleTextChange}/> Компонент <TextInput> задокументирован на сайте React Native вместе с его свойствами. Вы также можете передать <TextInput> дополнительные обратные вызовы, чтобы прослушать другие события, такие как onChange или onFocus, но в данный момент они нам не нужны. Обратите внимание, что мы добавили простой стиль в <TextInput>. Добавьте стиль ввода в свою таблицу стилей: var styles = Таблица стилей.create({ ... входные данные: { Размер шрифта: 20, ширина границы: 2, высота: 40 } ... }); Обратный вызов, который мы передали как реквизит onSubmitEditing , выглядит следующим образом и должен быть добавлен как функция в компоненте: _handleTextChange(event) {console.log(event.nativeEvent.text); this.setState({zip: event.nativeEvent.text}) } Оператор консоли посторонний, но он позволит вам протестировать инструменты отладчика, если вы того пожелаете. Вам также потребуется обновить инструкции импорта: var React= require('react-native'); var { ... TextInput ... } = React; Теперь попробуйте запустить свое приложение с помощью симулятора iOS. Это будет не очень приятно, но вы должны быть в состоянии успешно отправить почтовый индекс и отразить его в компоненте <Text>. Если Вашингтон мыхотели, мы могли бы добавить некоторые простые проверки входных данных здесь, чтобы убедиться, что пользователь ввел в пятизначное число, но мы будем это пропустить. В примере 3-8 показан полный код для компонента WeatherProject.js. Пример 3-8. WeatherProject.js : эта версия простопринимает и записывает пользовательский ввод var React = require('react-native'); var { Таблица стилей, текст, Вид, ввод текста, изображение } = React; var WeatherProject = React.createClass({ // Если вы хотите иметь почтовый индекс по умолчанию, вы могли бы добавить его сюда getInitialState() {return ({ zip: " }); }, // Мы передадим этот обратный вызов в <TextInput> _handleTextChange(событие) { // журнал инструкции доступны для просмотра в Xcode, // или в консоли инструментов отладки Chrome.log(event.nativeEvent.text); this.setState({ zip: event.nativeEvent.text }); }, render() { return ( <Стиль представления={styles.container}> <Стиль текста={styles.добро пожаловать}> Вы вводите {this.state.zip}. </Text> <TextInput style={стили.ввод} onSubmitEditing={это._handleTextChange}/> </View> ); } }); var styles = Таблица стилей.create({ контейнер: {flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, добро пожаловать: { Размер шрифта: 20, TextAlign: 'center', поле: 10, }, ввод: { Размер шрифта: 20, ширина границы: 2, высота: 40 } }); module.exports = WeatherProject; Отображение данных Nоу, давайте поработаем над отображением прогноза для этого почтового индекса. Мы начнем с добавления некоторых макет данных для getInitialState в WeatherProject.js: getInitialState() { возвращение { молнии: ", прогноз: { главный: 'облака', описание: 'облака', температура: 45.7 } } } для SAНюты ради, давайте тянуть прогноз рендеринга в свой собственный компонент. Создайте новый файл с именем Forecast.js (см. Пример 3-9). Пример 3-9. Прогнозируемый компонент в Forecast.js var React = require('react-native'); var { таблица стилей, текст, просмотр } = React; var Прогноз = React.createClass({ render: функция() { return ( <View> <Text style={styles.bigText}> {this.props.main} </Текст> <Text style={styles.mainText}> Текущие условия: {this.props.description} </Текст> <Text style={styles.bigText}> {this.props.temp}°F </Текст> </View > ); } }); var styles = Таблица стилей.create({ bigText: { flex: 2, размер шрифта: 20, TextAlign: 'center', margin: 10, color: '#FFFFFF' }, mainText: { flex: 1, размер шрифта: 16, TextAlign: 'center', цвет: '#FFFFFF' } }) module.exports = Прогноз; Этоткомпонент <Прогноз> просто отображает некоторый <Текст> на основе своих реквизитов. Мы также включили несколько простых стилей в нижней части файла, чтобы управлять такими вещами, как цвет текста. Запросите компонент <Forecast>, а затем добавьте его в метод рендеринга вашего приложения, передавая it реквизиты на основе this.state.forecast (см. Пример 3-10). Позже мы рассмотрим проблемы с макетом и оформлением. Вы можете увидеть, как компонент <Прогноз> отображается в результирующем приложении на рисунке 3-14. Пример 3-10. WeatherProject.js необходимо обновить с новым состоянием и компонентом прогноза var React = require('react-native'); var { таблица стилей, текст, Вид, ввод текста, изображение } = React; var Forecast = require('./Прогноз'); var WeatherProject = React.createClass({ getInitialState() { return { zip: ", forecast: { main: 'Облака', описание: 'несколько облаков', temp: 45.7 } } }, _handleTextChange(событие) { console.log(событие .nativeEvent.text); this.setState({ zip: event.nativeEvent.text }); }, render() { return ( <Стиль представления={styles.container}> <Стиль текста={styles.добро пожаловать}> Вы вводите {this.state.zip}. </Text> <Forecast main={this.state.forecast.main} описание={this.state.forecast.description} temp={this.state.forecast.temp}/> <TextInput style={styles.input} returnKeyType='go' onSubmitEditing={this._handleTextChange}/> </View> ); } }); var styles = Таблица стилей.create({ контейнер: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#4D4D4D', }, добро пожаловать: { Размер шрифта: 20, TextAlign: 'center', поле: 10, }, ввод: { Размер шрифта: 20, ширина границы: 2, высота: 40 } }); module.exports = Прогноз погоды; Рис. 3-14. Приложение "Погода" пока добавляет фоновое изображение, простые цвета фона кажутся скучными. Давайте отобразим фоновое изображение, чтобы оно соответствовало нашему прогнозу. ВКЛЮЧЕНИЕ РЕСУРСОВ ЗАВИСИТ ОТ ПЛАТФОРМЫ, иroid и iOS предъявляют разные требования к добавлению ресурсов в ваши проекты. Здесь мы рассмотрим оба варианта. Ресурсы, такие как изображения, необходимо добавлять в ваш проект в зависимости от платформы, для которой вы создаете. Начнем с Xcode. Выберите опцию Images.xcassets/ fold, а затем выберите опцию New Image Set, как показано на рисунке 3-15. Затем вы можете перетащить изображение в набор. На рисунке 3-16 показан результирующий набор изображений. Убедитесь, что имя набора изображений совпадает с именем файла, в противном случае React Native будет с трудомимпортировать его. Рисунок 3-15. Добавьте новый набор изображений Рисунок 3-16. Перетащите файлы изображений в набор изображений, чтобы добавить их. Декораторы @2x и @3x указывают на изображение с разрешением, вдвое и втрое превышающим базовое разрешение, соответственно. Поскольку приложение "Погода"обозначено как универсальное приложение (то есть такое, которое может работать на iPhone или iPad), Xcode предоставляет нам возможность загружать изображения в различных соответствующих разрешениях. Для Android мы должны добавить наши файлы в виде ресурсов для рисования растровых изображений в соответствующиепапки в WeatherProject / android / app / src / main / res. Вам потребуется скопировать файл .png в следующие каталоги, зависящие от разрешения (см. Рисунок 3-17): drawable-mdpi/ (1x) drawable-hdpi/ (1.5x) drawable-xhdpi/ (2x) drawable-xxhdpi/ (3x) Рисунок 3-17. Добавление файлов изображений на Android После этого изображение будет доступно для вашего приложения Android. Если этот рабочий процесс кажется неоптимальным, то это потому, что так оно и есть. Вероятно, он изменится в будущих версиях React Native. Теперь, когда файлы изображений были импортированы в оба наших проекта для Android и iOS, давайте вернемся к нашему коду React. Чтобы добавить фоновое изображение, мы не устанавливаем свойство background для <div>, как мы можем сделать в Интернете. Вместо этого мы используем компонент <Image> в качестве контейнера: <Источник изображения={require('изображение!цветы")} ResizeMode='обложка' style={styles.background}> // Ваш контент здесь </Image> Компонент <Image> ожидает исходный реквизит, который мы получаем с помощью require . Запрос require(изображение!цветы) заставит React Native выполнить поиск файла с именем цветы. Не забудьте оформить его с помощью flexDirection, чтобы его дочерние элементы отображались так, как мы бы хотели: background: { flex: 1, flexDirection: 'column' } Теперь давайте дадим <Image> несколько дочерних элементов. Обновите метод визуализации компонента <WeatherProject> до r, используя следующее: <Источник изображения={require('изображение!цветы")} ResizeMode='обложка' style={styles.background}> <Стиль просмотра={styles.overlay}> <Стиль просмотра={styles.row}> <Стиль текста={styles.mainText}> Текущая погода для </Text> <Стиль просмотра={styles.zipContainer}> <Стиль ввода текста={[styles.zipCode, styles.mainText]} returnKeyType='go' onSubmitEditing={this._handleTextChange}/> </View> </View> <Прогноз main={this.state.forecast.main} описание={this.state.forecast.description} temp={this.state.forecast.temp}/> </View> </Изображение> Вы заметите, что я использую некоторые дополнительные стили, которые мы еще не обсуждали, такие как row , overlay , а также стили zipContainer и zipCode. Вы можете перейти к концу этого раздела, чтобы увидеть полную таблицу стилей. Извлечение данных из Интернета Далее давайте рассмотрим использование сетевых API, доступных в React Native. Вы не будете использовать jQuery для отправки AJAX-запросов с мобильных устройств! Вместо этого React Native реализует Fetch API. Синтаксис, основанный на обещаниях, довольно прост: fetch('http://www.somesite.com ') .then((response) => response.text()) .then((responseText) => { console.log(responseText); }); Мы будем использовать OpenWeatherMap API, который предоставляет нам простую конечную точку, которая возвращает текущую погоду для данного почтового индекса. Чтобы интегрироватьв этот API, мы можем изменить обратный вызов компонента <TextInput> для запроса OpenWeatherMap API: _handleTextChange: функция(событие) { var zip = event.nativeEvent.text; this.setState({zip: zip}); fetch('http://api.openweathermap.org/data/2.5/weather ?q=' + zip + '&units=imperial') .затем((response) => response.json()) .затем((responseJSON) => { // Взгляните на формат, если хотите. console.log(responseJSON); this.setState({ прогноз: { main: responseJSON.weather[0].main, описание: responseJSON.weather[0].описание, temp: responseJSON.main.temp } }); }) .catch((ошибка) => { console.warn(ошибка); }); } Обратите внимание, что нам нужен JSON из ответа. С Fetch API довольно просто работать, так что это все, что нам нужно будет сделать. Другая вещь, которую мы можем сделать, это удалить данные-заполнители и убедиться, что прогноз не отображается, если у нас еще нет данных. Сначала очистите фиктивные данные из getInitialState: getInitialState: function() { return { zip: ", прогноз: null }; } Затем в функции рендеринга обновите логику рендеринга: var content = null; if (this.state.forecast !== null) { content = <Forecast main={this.state.forecast.main} description={this.state.forecast.description} temp={this.state.forecast.temp}/>; } Наконец, замените вашr визуализированный компонент <Forecast> на {content} в функция рендеринга. Собрав все это для окончательной версии приложения, я реорганизовал функцию рендеринга компонента <WeatherProject> и изменил стили. Основное изменение касается логики компоновки , представленной на рисунке 3-18. Рисунок 3-18. Компоновка готового приложения погоды в порядке. Готовы увидеть все это в одном месте? В примере 3-11 показан готовый код для компонента <WeatherProject> полностью, включая таблицы стилей. Состав <Прогноз>будет таким же, как указано выше в примере 3-9. Пример 3-11. Готовый код для WeatherProject.js var React = требовать('react-native'); var { таблица стилей, текст, Вид, текстовый ввод, изображение } = реагировать; var Прогноз = требовать('./Прогноз'); var WeatherProject = реагировать.createClass({ getInitialState: функция() { return { zip: ", прогноз: null }; }, _handleTextChange: функция(событие) { var zip = event.nativeEvent.text; this.setState({zip: zip}); выборка( 'http://api.openweathermap.org/data/2.5/weather ?q=' + zip +'&units=imperial') .then((response) => response.json()) .then((responseJSON) => { this.setState({ прогноз: { main: responseJSON.weather[0].main, описание: responseJSON.weather[0].description, temp: responseJSON.main.temp } }); }) .catch((ошибка) => { console.warn(ошибка); }); }, визуализация: функция() { var content = null; if (this.state.forecast !== null) { content = <Прогноз main={this.state.forecast.main} описание={this.state.forecast.description} temp={this.state.forecast.temp}/>; } возврат ( <View style={styles.container}> <Источник изображения={require('изображение!цветы")} ResizeMode='обложка' style={styles.background}> <Стиль просмотра={styles.overlay}> <Стиль просмотра={styles.row}> <Стиль текста={styles.mainText}> Текущая погода для </Text> <Стиль просмотра={styles.zipContainer}> <TextInput style={[styles.zipCode, styles.mainText]} returnKeyType='go' onSubmitEditing={this._handleTextChange}/> </View> </View> {content} </View> </Image> </View> ); } }); var baseFontSize = 16; var styles = StyleSheet.create({ контейнер: { flex: 1, alignItems: 'center', paddingTop: 30 }, background: { flex: 1, flexDirection: 'column' }, overlay: { paddingTop: 5, backgroundColor: '#000000', непрозрачность : 0.5, flexDirection: 'column', alignItems: 'center' }, row: { flex: 1, flexDirection: 'row', flexWrap: 'nowrap', alignItems: 'flex-start', padding: 30 }, zipContainer: { flex: 1, borderBottomColor: '#DDDDDD', borderBottomWidth: 1, marginLeft: 5, marginTop: 3 }, zipCode: { width: 50, height: baseFontSize, }, mainText: { flex: 1, FontSize: baseFontSize, color: '#FFFFFF' } }}); module.exports = WeatherProject; Теперь, когда мы закончили, попробуйте запустить приложение. Это должно работать как на Android, так и на iOS, в эмуляторе или на вашем физическом устройстве. Что бы вы хотели изменить или улучшить? Вы можете просмотреть готовое приложение врепозитории GitHub. Краткое описание Для нашего первого реального приложения мы уже проделали большую работу. Мы представили новый компонент пользовательского интерфейса, <TextInput>, и узнали, как использовать его для получения информации от пользователя. Мы продемонстрировали, как реализовать базовый стильg в React Native, а также как использовать изображения и включать ресурсы в наше приложение. Наконец, мы узнали, как использовать сетевой API React Native для запроса данных из внешних веб-источников. Неплохо для первого приложения! Надеюсь, это продемонстрировало,насколько быстро вы можете создавать приложения React Native с полезными функциями, которые будут чувствовать себя как дома на мобильном устройстве. Если вы хотите расширить свое приложение дальше, вот несколько советов, которые стоит попробовать: Добавьте больше изображений и измените их в зависимости от прогноза Добавьте значениев поле почтовый индекс Переключитесь на использование более подходящей клавиатуры для ввода почтового индекса Отобразите прогноз погоды на пять дней Как только мы рассмотрим больше тем, таких как геолокация, вы сможете расширить приложение погода еще большим количеством способов. Конечно,это был довольно быстрый опрос. В следующих нескольких главах мы сосредоточимся на более глубоком понимании лучших практик React Native, а также рассмотрим, как использовать гораздо больше функций! Глава 4. Компоненты для мобильных устройств В главе 3 мы создали простоеприложение погоды. При этом мы затронули основы построения интерфейсов с React Native. В этой главе мы подробнее рассмотрим мобильные компоненты, используемые для React Native, и их сравнение с базовыми элементами HTML. Мобильные интерфейсыоснованы на других примитивных элементах пользовательского интерфейса, чем веб-страницы, и поэтому нам нужно использовать другие компоненты. Эта глава начинается с более подробного обзора самых основных компонентов: <Вид>, <Изображение> и <Текст>. Затем мы обсудим, как прикосновения и жесты учитываются в компонентах React Native и как обрабатывать события касания. Далее мы рассмотрим компоненты более высокого уровня, такие как <ListView>, <TabView> и <NavigatorView>, которые позволяют вам объединять другие представления в стандартные шаблоны мобильного интерфейса. Аналогии между элементами HTML и нативными компонентами При разработке для Интернета мы используем множество базовых элементов HTML. К ним относятся <div>,lude a consideration of elements such as <audio>, <svg>, <canvas>, and so on, but we’ll ignore them for now.) When dealing with React Native, we don’t use these HTML elements, but we use a variety of components that are nearly analogous to them (Table 4-1). Table 4-1. Analogous HTML and Native components HTML React Native div View img Image span, p Text ul/ol, li ListView, child items Although these elements serve roughly the same purposes, they are not interchangeable. Let’s take a look at how these components work on mobile with React Native, and how they differ from their browser-based counterparts. CAN I SHARE CODE BETWEEN REACT NATIVE AND MY WEB APP? Unfortunately, React Native’s basic components currently can’t render to basic HTML elements. Your React Native code can be reused across iOS and Android (and any future React Native platforms), but it can’t render to web- compatible views. However, any JavaScript code, including React components, which don’t render any basic elements can be shared. So, if your business logic is isolated from your rendering code, you can see some reuse there. The Text Component Rendering text is a deceptively basic function; nearly any application will need to render text somewhere. However, text within the context of React Native and mobile development works differently from text rendering for the Web. When working with text in HTML, you can include raw text strings in a variety of elements. Furthermore, you can style them with child tags such as <strong> and <em>. So, you might end up with an HTML snippet that looks like this: <p>The quick <em>brown</em> fox jumped over the lazy <strong>dog</strong>.</p> In React Native, only <Text> components may have plain text nodes as children. In other words, this is not valid: <View> Text doesn't go here! </View> Instead, wrap your text in a <Text> component: <View> <Text>This is OK!</Text> </View> When dealing with <Text> components in React Native, you no longer have access to subtags such as <strong> and <em>, though you can apply styles to achieve similar effects through use of attributes such as fontWeight and fontStyle. Here’s how you might achieve a similar effect by making use of inline styles: <Text> The quick <Text style={{fontStyle: "italic"}}>brown</Text> fox jumped over the lazy <Text style={{fontWeight: "bold"}}>dog</Text>. </Text> This approach could quickly become verbose. You’ll likely want to create styled components as a sort of shorthand when dealing with text, as shown in Example 4-1. Example 4-1. Creating reusable components for styling text var styles = StyleSheet.create({ bold: { fontWeight: "bold" }, italic: { fontStyle: "italic" } }); var Strong = React.createClass({ render: function() { return ( <Text style={styles.bold}> {this.props.children} </Text>); } }); var Em = React.createClass({ render: function() { return ( <Text style={styles.italic}> {this.props.children} </Text>); } }); Once you have declared these styled components, you can freely make use of styled nesting. Now the React Native version looks quite similar to the HTML version (see Example 4-2). Example 4-2. Using styled components for rendering text <Text> The quick <Em>brown</Em> fox jumped over the lazy <Strong>dog</Strong>. </Text> Similarly, React Native does not inherently have any concept of header elements (h1, h2, etc.), but it’s easy to declare your own styled <Text> elements and use them as needed. In general, when dealing with styled text, React Native forces you to change your approach. Style inheritance is limited, so you lose the ability to have default font settings for all text nodes in the tree. One again, Facebook recommends solving this by using styled components: You also lose the ability to set up a default font for an entire subtree. The recommended way to use consistent fonts and sizes across your application is to create a component MyAppText that includes them and use this component across your app. You can also use this component to make more specific components like MyAppHeaderText for other kinds of text. React Native Documentation The Text component documentation has more details on this. You’ve probably noticed a pattern here: React Native is very opinionated in its preference for the reuse of styled components over the reuse of styles. We’ll discuss this further in the next chapter. The Image Component If text is the most basic element in an application, images are a close contender, for both mobile and for the Web. When writing HTML and CSS for the Web, we include images in a variety of ways: sometimes we use the <img> tag, while at other times we apply images via CSS, such as when we use the background-image property. In React Native, we have a similar <Image> component, but it behaves a little differently. The basic usage of the <Image> component is straightforward; just set the source prop: <Image source={require('image!puppies')} /> How does that require call work? Where does this resource live? Here’s one part of React Native that you’ll have to adjust based on which platform you’re targeting. On iOS, this means that you’ll need to import it into the assets folder within your Xcode project. By providing the appropriate @2x and @3x resolution files, you will enable Xcode to serve the correct asset file for the correct platform. This is a nice change from web development: the relatively limited possible combinations of screen size and resolution on iOS means that it’s easier to create targeted assets. For React Native on other platforms, we can expect that the image! require syntax will point to a similar assets directory. It’s worth mentioning that it is also possible to include web-based image sources instead of bundling your assets with your application. Facebook does this as one of the examples in the UIExplorer application: <Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} style={{width: 400, height: 400}} /> When utilizing network resources, you will need to specify dimensions manually. Downloading images via the network rather than including them as assets has some advantages. During development, for instance, it may be easier to use this approach while prototyping, rather than carefully importing all of your assets ahead of time. It also reduces the size of your bundled mobile application, so that users needn’t download all of your assets. However, it means that instead you’ll be relying on the user’s data plan whenever they access your application in the future. For most cases, you’ll want to avoid using the URI-based method. If you’re wondering about working with the user’s own images, we’ll cover the camera roll in Chapter 6. Because React Native emphasizes a component-based approach, images must be included as an <Image> component instead of being referenced via styles. For instance, in Chapter 3, we wanted to use an image as a background for our приложение для определения погоды. В то время как в обычном HTML и CSS вы, скорее всего, использовали бы свойство background-image для применения фонового изображения, в React Native вы вместо этого используете <Image> в качестве компонента контейнера, например так: <Image source={require('изображение!щенки')}> {/* Ваш контент здесь ... */} </Image> Оформление самих изображений довольно простое. Помимо применения стилей, определенные реквизиты определяют способ отображения изображения. Например, вы часто будете использовать реквизит ResizeMode, который может иметь значение изменять размер, покрывать или содержать. Приложение UIExplorer хорошо демонстрирует это (рис. 4-1). Рис. 4-1. Разница между изменением размера, обложкой и содержанием компонента <Изображение> проста в работе и очень гибка. Скорее всего, вы будете широко использовать его в своих собственных приложениях. Работа с касаниями и жестами Веб-интерфейсы обычно предназначены для контроллеров на базе мыши. Мы используем такие вещи, как состояние наведения, чтобы указывать на интерактивность и реагировать на взаимодействие с пользователем. Для мобильных устройств важно прикосновение. У мобильных платформ есть свои нормы взаимодействия, для которых вы захотите разработать дизайн. Это несколько варьируется от платформы к платформе: iOS ведет себя иначе, чем Android, который, опять же, ведет себя иначе, чем Windows Phone. React Native предоставляет ряд API, которые вы можете использовать при создании сенсорных интерфейсов. В этом разделе мы рассмотрим контейнерный компонент <TouchableHighlight>, а также API более низкого уровня, предоставляемые PanResponder и системой реагирования на жесты. Использование TouchableHighlight Любые элементы интерфейса, которые реагируют на прикосновения пользователя (например, кнопки, элементы управления и т.д.), Обычно должны иметь оболочку <TouchableHighlight>. <TouchableHighlight> вызывает появление наложения при касании вида, предоставляя пользователю визуальную обратную связь. Это одно из ключевых взаимодействий, благодаря которому мобильное приложение кажется нативным, в отличие от веб-сайта, оптимизированного для мобильных устройств, где обратная связь при касании ограничена. Как общее эмпирическое правило, вы должны использовать <TouchableHighlight> везде, где есть кнопка или ссылка в Интернете. При самом простом использовании вам просто нужно обернуть свой компонент в <TouchableHighlight> , который добавит простое наложение при нажатии. Компонент <TouchableHighlight> также предоставляет вам перехваты для таких событий, как onPressIn, onPressOut, onLongPress и т.п., так что вы можете использовать эти события в своих приложениях React. В примере 4-3 показано, как можно обернуть компонент в <TouchableHighlight>, чтобы дать пользователю обратную связь. Пример 4-3. Использование компонента <TouchableHighlight> <TouchableHighlight onPressIn={this._onPressIn} onPressOut={this._onPressOut} style={styles.touchable}> <Стиль просмотра={styles.button}> <Стиль текста={styles.добро пожаловать}> {this.state.pressing ? 'EEK!' : 'PUSH ME'} </Текст> </Вид> </TouchableHighlight> Когда пользователь нажимает на кнопку, появляется наложение, и текст меняется (рис. 4-2). Рисунок 4-2. Использование <TouchableHighlight> для визуальной обратной связи с пользователем — состояние без нажатия (слева) и нажатое состояние с подсветкой (справа) Это надуманный пример, но он иллюстрирует основные взаимодействия, благодаря которым кнопка “ощущается” на ощупь на мобильном устройстве. Наложение - это ключевой элемент обратной связи, который информирует пользователя о том, что элемент можно нажать. Обратите внимание, что для применения наложения нам не нужно применять какую-либо логику к нашим стилям; <TouchableHighlight> обрабатывает логику этого за нас. В примере 4-4 показан полный код для этого компонента button. Пример 4-4. Touch/PressDemo.js иллюстрирует использование <TouchableHighlight> 'use strict'; var React = require('react-native'); var { StyleSheet, Text, View, TouchableHighlight } = React; var Button = React.createClass({ getInitialState: function() { return { pressing: false } }, _onPressIn: function() { this.setState({нажатие: true}); }, _onPressOut: function() { this.setState({нажатие: false}) ; }, render: функция() { return ( <View style={styles.container}> <TouchableHighlight onPressIn={this._onPressIn} onPressOut={this._onPressOut} style={styles.touchable}> <View style={styles.button}> <Text style={styles.добро пожаловать}> {this.state.pressing ? 'EEK!' : 'PUSH ME'} </Text> </View> </TouchableHighlight> </View> ); } }); var styles = StyleSheet.create({ контейнер: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, добро пожаловать: { Размер шрифта: 20, TextAlign: 'center', размерджина: 10, цвет: '#FFFFFF' }, осязаемый: { borderRadius: 100 }, кнопка: { backgroundColor: '#FF0000', borderRadius: 100, высота: 200, ширина: 200, justifyContent: 'center' }, }); module.exports = Кнопка; Попробуйте отредактировать эту кнопку, чтобы реагировать на другие события, используя хуки типа onPress и onLongPress. Лучший способ получить представление о том, как эти события соотносятся с взаимодействиями пользователей, - это поэкспериментировать с использованием реального устройства. Система GestureResponder Что, если вы хотите сделать больше, чем просто сделать вещи “доступными для прослушивания”? React Native также предоставляет два API для пользовательской обработки касаний: GestureResponder и PanResponder. GestureResponder - это API более низкого уровня, в то время как PanResponder предоставляет полезную абстракцию. Мы начнем с рассмотрения того, как работает система GestureResponder, потому что этооснова API PanResponder. Touch на мобильных устройствах довольно сложен. Большинство мобильных платформ поддерживают мультитач, что означает, что на экране может быть одновременно активировано несколько точек касания. (Не все из них также обязательно являются пальцами; подумайтео сложности, например, обнаружения ладони пользователя, лежащей на углу экрана.) Кроме того, существует проблема с тем, какой вид должен обрабатывать данное касание. Эта проблема похожа на то, как обрабатываются события мыши в Интернете, и поведение default также аналогично: самый верхний дочерний элемент обрабатывает событие касания по умолчанию. Однако с помощью системы реагирования на жесты React Native мы можем переопределить это поведение, если захотим. Средство реагирования на касания - это представление, которое обрабатывает данное событие касания. Впредыдущем разделе мы видели, что компонент <TouchableHighlight> выполняет функции сенсорного ответа. Мы можем заставить наши собственные компоненты также выполнять функции сенсорного ответа. Жизненный цикл, в рамках которого осуществляется этот процесс, немного сложен. Представление, которое желаетполучить статус ответчика касания, должно реализовывать четыре реквизита: View.props.onStartShouldSetResponder View.props.onMoveShouldSetResponder View.props.onResponderGrant View.props.onResponderReject Затем они вызываются в соответствии с потоком, показанным на Fрисунке 4-3, чтобы определить, получит ли представление статус ответчика. Рисунок 4-3. Получение статуса сенсорного ответчика, блин, это выглядит сложно! Давайте разберем это по отдельности. Во-первых, событие касания имеет три основных этапа жизненного цикла: запуск, перемещение и освобождение (они соответствуют mouseDown, mouseMove и mouseUp в браузере). Представление может запросить функцию ответа на касание на этапе запуска или перемещения. Это поведение определяется onStartShouldSetResponder и onMoveShouldSetResponder . Когда одна из этих функций возвращает true, представление пытается запросить статус ответчика. После того, как представление попыталось запросить статус ответчика, его попытка может быть удовлетворена или отклонена. Будет вызван соответствующий обратный вызов — либо onResponderGrant, либо onResponderReject.Эти функции согласования с ответчиком вызываются в циклическом режиме. Если несколько представлений попытаются претендовать на статус ответчика, ответчиком станет самый глубокий компонент. Обычно это желаемое поведение; в противном случае у вас возникли бы трудности с добавлением кнастраиваемых компонентов, таких как кнопки, в увеличенный вид. Если вы хотите переопределить это поведение, родительские компоненты могут использовать onStartShouldSetResponderCapture и onMoveShouldSetResponderCapture. Возврат значения true для любого из этих параметров предотвратит превращение дочерних элементов компонентав средства реагирования на касание. После того, как представление успешно подтвердило статус средства реагирования на касание, могут быть вызваны соответствующие обработчики событий. Вот выдержка из документации жест ответчик: смотреть.реквизит.onResponderMove пользователь мовиНГ пальце вид.реквизит.onResponderRelease уволен в конце ощупь (т. е., “ретушь”) вид.реквизит.onResponderTerminationRequest-то еще хочет стать ответчика. Должно ли это представление освободить ответчика? Возвращая значение true, можно освободить View.props.onResponderTerminate Ответчик был удален из представления. Это может быть принято другими представлениями после вызова onResponderTerminationRequest или операционной системой без запроса (происходит с центром управления / центром уведомлений на iOS) Большую часть времени вас в первую очередь будут беспокоить onResponderMove и onResponderRelease. Все эти методы получают синтетический объект события касания, который соответствует следующему формату (опять же, выдержка из документации): changedTouches Массив всех событий касания, которые изменились с момента последнего идентификатора события Идентификатор местоположения касания X Позиция касания X относительно местоположения элемента Y позиция касания относительно страницы элемента X Позиция касания относительно страницы экрана Позиция касания Y относительно целевого объекта экрана Идентификатор узла элемента, получающего временную метку события касания Идентификатор времени для функция touch, полезная для расчета скорости касаний, содержит массив всех текущих касаний на экране. Вы можете использоватьf эту информацию при принятии решения о том, реагировать или нет на событие касания. Возможно, ваш вид заботится только о касаниях двумя пальцами, например. Это довольно низкоуровневый API; если вы хотите обнаруживать жесты и реагировать на них таким образом, вам нужно будет потратитьприличное количество времени на настройку правильных параметров и выяснение, о каких значениях вам следует заботиться. В следующем разделе мы рассмотрим PanResponder, который обеспечивает интерпретацию жестов пользователя на несколько более высоком уровне. PanResponder Unlкак и <TouchableHighlight>, PanResponder - это не компонент, а скорее класс, предоставляемый React Native. Он предоставляет API немного более высокого уровня, чем базовые события, возвращаемые системой реагирования на жесты, при этом по-прежнему предоставляя доступ к этим необработанным событиям. Объект gestureState PanResponder предоставляет вам доступ к следующему, в соответствии с документацией PanResponder: StateID ID состояния жеста (сохраняется до тех пор, пока на экране есть хотя бы одно касание) moveX Последние экранные координаты rнедавно перемещенного касания moveY Последние экранные координаты недавно перемещенного касания x0 Экранные координаты ответчика предоставляют y0 Экранные координаты ответчика предоставляют dx Накопленное расстояние жеста с момента начала касания dy Накопленноезаданное расстояние жеста с момента начала касания vx Текущая скорость движения жест vy Текущая скорость числа жестов activeractivetouches Количество касаний, отображаемых в данный момент на экране. Как вы можете видеть, в дополнение к необработанным данным о местоположении, объект gestureState такжеo включает такую информацию, как текущая скорость касания и накопленное расстояние. Чтобы использовать PanResponder в компоненте, нам нужно создать объект PanResponder, а затем прикрепить его к компоненту в методе render . Создание PANRESPONSEer требует, чтобы мы указали надлежащие обработчики для событий PanResponder (пример 4-5). Пример 4-5. Создание PanResponder требует, чтобы мы передали кучу обратных вызовов this._panResponder = PanResponder.create({ onStartShouldSetPanResponder: this._handleStartShouldSetPanResponder, onMoveShouldSetPanResponder: этот._handleMoveShouldSetPanResponder, onPanResponderGrant: это._handlepanresponder предоставляет, onPanResponderMove: это._handlePanResponderMove, onPanResponderRelease: это._handlePanResponderEnd, onPanResponderЗавершение: это._handlePanResponderEnd, }); Затем мы используем синтаксис spread, чтобы прикрепить PanResponder к представлению в методе визуализации компонента (пример 4-6). Пример 4-6. Подключение PanResponder с помощью spread sytax render: function() { return ( <Просмотр {...this._panResponder.panHandlers}> { /* Просмотреть содержимое здесь */ } </View> ); } После этого обработчики, которые вы передали вызову PanResponder.create, будут вызваны во время соответствующих событий перемещения, если касание происходит в этом представлении. В примере 4-7 sприведена модифицированная версия примера кода PanResponder, предоставленного React Native. Эта версия прослушивает события касания в представлении контейнера, а не только в виде круга, и поэтому значения выводятся на экран по мере взаимодействия с приложением. Если вы планируете реализовать свои собственные средства распознавания жестов, я предлагаю поэкспериментировать с этим приложением на реальном устройстве, чтобы вы могли почувствовать, как реагируют эти значения. Рис. 4-4 показывает скриншот этого примера, но вы хотите экспериментахэнце на устройстве с настоящим сенсорным экраном. Рис. 4-4. PanResponder демо-пример 4-7. Touch/PanDemo.js иллюстрирует использование PanResponder // Адаптировано из // https://github.com/facebook/react-native/blob/master / // Примеры/UIExplorer/PanResponderExample.js 'use strict'; var React = require('react-native'); var { Таблица стилей, PanResponder, Вид, текст } = React; var CIRCLE_SIZE = 40; var CIRCLE_COLOR = 'синий'; var CIRCLE_HIGHLIGHT_COLOR = 'зеленый'; var PanResponderExample = React.createClass({ // Задайте некоторые вначальные значения. _panResponder: {}, _previousLeft: 0, _previousTop: 0, _circleStyles: {}, circle: null, getInitialState: функция() { возвращает { numberActiveTouches: 0, moveX: 0, moveY: 0, x0: 0, y0: 0, dx: 0, dy: 0, vx: 0, vy: 0, } }, componentWillMount: функцияion() { это. _panResponder = PanResponder.create({ onStartShouldSetPanResponder: это._handleStartShouldSetPanResponder, onMoveShouldSetPanResponder: это._handleMoveShouldSetPanResponder, onPanResponderGrant: это._handlepanrespond предоставляет, onPanResponderMове: это._handlePanResponderMove, onPanResponderRelease: это._handlePanResponderEnd, onPanResponderTerminate: это._handlePanResponderEnd, }); this._previousLeft = 20; this._previousTop = 84; this._circleStyles = { слева: this._previousLeft, сверху: this._previousTop, }; }, componentDidMount: функция() { this._updatePosition(); }, render: функция() { return ( <View style={стили.контейнер}> <View ref={(круг) => { this. circle = круг; }} style={styles.circle} {...this._panResponder.panHandlers}/> <Текст> {this.state.numberActiveTouches} касается, dx: {this.state.dx}, dy: {this.state.dy}, vx: {this.state.vx}, vy: {this.state.vy} </Текст> </Вид> ); }, // _highlight и _unHighlight вызываются Методы PanResponder, // обеспечивающие визуальную обратную связь с пользователем. _выделите: функция() { this.circle && this.circle.setNativeProps({ backgroundColor: CIRCLE_HIGHLIGHT_COLOR }); }, _unHighlight: функция() { this.circle && this.circle.setNativeProps({ backgroundColor: CIRCLE_COLOR }); }, // Мы контролируем положение круга напрямую с помощью setNativeProps. _updatePosition: функция() { this.circle && this.circle.setNativeProps(this._circleStyles); }, _handleStartShouldSetPanResponder: функция(e: Объект, gestureState: Объект): логическое значение { // Должны ли мы становиться активными, когда пользователь нажимает на круг? return true; }, _handleMoveShouldSetPanResponder: функция(e: Object, gestureState: Object): boolean {// Должны ли мы становиться активными, когда пользователь проводит касанием по окружности? возвращает true; }, _handlePanResponderGrant: function(e: Object, gestureState: Object) { это._highlight(); }, _handlePanResponderMove: функция(e: Object, gestureState: Объект) { this.setState({ StateID: gestureState.StateID, moveX: gestureState.moveX, moveY: gestureState.moveY, x0: gestureState.x0, y0: gestureState.y0, dx: gestureState.dx, dy: gestureState.dy, vx: gestureState .vx, vy: gestureState.vy, numberActiveTouches: gestureState.numberActiveTouches }); // Вычислить текущую позицию, используя дельты this._circleStyles.left = this._previousLeft + gestureState.dx; this._circleStyles.top = this._previousTop + gestureState.dy; this._updatePosition(); }, _handlePanResponderEnd: функция(e: объект, gestureState: Объект) { this._unHighlight(); this._previousLeft += gestureState.dx; this._previousTop += gestuREstate.dy; }, }); var styles = Таблица стилей.create({ circle: { width: CIRCLE_SIZE, height: CIRCLE_SIZE, borderRadius: CIRCLE_SIZE / 2, backgroundColor: CIRCLE_COLOR, position: 'absolute', left: 0, top: 0, }, контейнер: { flex: 1, paddingTop: 64, }, }); moduфайл.exports = PanResponderExample; Выбор способа обработки касания Как вы должны решить, когда использовать API-интерфейсы касаний и жестов, обсуждаемые в этом разделе? Это зависит от того, что вы хотите построить. Чтобы предоставить пользователю базовую обратную связь и указать, что кнопка или другой элемент ”доступен для нажатия", используйте компонент <TouchableHighlight>. Чтобы реализовать свои собственные сенсорные интерфейсы, используйте либо систему raw Gesture Responder, либо PanResponder. Скорее всего, вы почти всегда предпочтете подход PanResponder, потому что он также дает вам доступ к более простым событиям касания, предоставляемым системой реагирования на жесты. Если вы разрабатываете игру, или приложение с необычным интерфейсом, вам потребуется потратить некоторое время на создание интерактивная детская ...дополнения, которые вы хотите с помощью этих API. Для многих приложений вам не нужно будет реализовывать какую-либо пользовательскую обработку касаний ни с помощью системы реагирования на жесты, ни с помощью панорамирования. В следующем разделе мы рассмотрим некоторые компоненты более высокого уровня, которые реализуютnt распространенные шаблоны пользовательского интерфейса для вас. Работа с организационными компонентами В этом разделе мы рассмотрим организационные компоненты, которые вы можете использовать для управления общим потоком в вашем приложении. Сюда входят <TabView>, <NavigatorView> и <LisTView>, которые реализуют некоторые из наиболее распространенных шаблонов взаимодействия с мобильными устройствами и навигации. После того, как вы спланируете навигационный процесс вашего приложения, вы обнаружите, что эти компоненты очень полезны для воплощения вашего приложения в жизнь. Использование ListView Давайте начнем с использования компонента <ListView>. В этом разделе мы собираемся создать приложение, которое отображает список бестселлеров New York Times и позволяет нам просматривать данные о каждой книге, как показано на рис. 4-5. Если хотите, вы можете взять свой собственный API токен из New York Times . В противном случае используйте токен API, включенный в пример кода. Рисунок 4-5. Приложение BookList, которое мы создадим, списки чрезвычайно полезны для разработки мобильных устройств, и вы заметите, что во многих мобильных пользовательских интерфейсах они являются центральным элементом. <ListView> - это буквально просто список представлений, необязательно со специальными представлениями для разделителей разделов, верхних или нижних колонтитулов. Например, вы можете увидеть этот шаблон взаимодействия в приложениях Dropbox, Twitter и iOS "Настройки" (рис. 4-6). Рис. 4-6. Списки, используемые Dropbox, Twitter и приложением настроек iOS <ListView>, являются хорошим примером того, в чем преуспевает React Native, поскольку он может использовать свою основную платформу. На мобильных устройствах собственный элемент <ListView> обычно сильно оптимизирован, так что рендеринг плавный и без заиканий. Если вы ожидаете отрисовки очень большого количества элементов в вашем <ListView>, вам следует попытаться сохранить дочерние представления относительно простыми, чтобы попытаться уменьшить заикания. Базовый компонент React Native <ListView> требует двух prопераций: DataSource и renderRow. DataSource, как следует из названия, является источником информации о данных, которые необходимо отобразить. renderRow должен возвращать компонент на основе данных из одного элемента источника данных. Это базовое использование продемонстрировано в SimpleList.js. Мы начнем с добавления источника данных в наш компонент <SimpleList>. В ListView.DataSource необходимо реализовать метод rowHasChanged . Вот простой пример: var ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2}); Чтобы установить фактическое содержимое источника данных, мы используем cloneWithRows. Давайте вернем источник данных в нашем вызове getInitialState: getInitialState: function() { var ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2}); return { DataSource: ds.cloneWithRows(['a', 'b', 'c', 'более длинный пример', 'd', 'e'])}; } Другой реквизит, который нам нужен, - это renderRow , который должен быть функцией, возвращающей некоторые JSX на основе данных для данной строки: _renderRow: функция(rowData) { return <Text style={styles.row}>{rowData}</Text>; } Теперь мы можем собрать все это вместе, чтобы увидеть простой <ListView>, отрисовав <ListView> примерно так: <Источник данных ListView={this.state.DataSource} renderRow={this._renderRow} /> Это выглядит как на рисунке 4-7. Рисунок 4-7. Компонент SimpleList отображает элементарные данные <ListView> Что, если мы захотим сделать немного больше? Давайте создадим <ListView> с более сложными данными. Мы будем использовать API New York Times для создания простого приложения-бестселлера, которое отображает список бестселлеров New York Times. Сначала мы инициализируем наш источник данных как пустой, потому что нам нужно будет извлечь данные: getInitialState: function() { var ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2}); return { DataSource: ds.cloneWithRows([]) }; } Затем мы добавляем метод для извлечения данныхa и обновляем источник данных, как только он у нас будет. Этот метод будет вызван из componentDidMount: _refreshData: function() { конечная точка var = 'http://api.nytimes.com/svc/books/v3/lists/hardcover-fiction?response-format =json&api-key=' + API_KEY; выборка(endpoint) .then((response) => response.json()) .then((rjson) => { this.setState({ источник данных: this.state.DataSource.cloneWithRows(rjson.results.books) }); }); } Каждая книга, возвращаемая API New York Times, имеет три свойства: coverURL, author и title. Мынастраиваем функцию рендеринга <ListView>, чтобы она возвращала компонент на основе этих реквизитов. Пример 4-8. Для _renderRow мы просто передаем соответствующие данные в функцию <BookItem> _renderRow:(rowData) { return <BookItem coverURL={rowData.book_image} title={rowData.title} author={rowData.author}/>; } , Мы также добавим компонент верхнего и нижнего колонтитулов, чтобы продемонстрировать, как они работают (пример 4-9). Обратите внимание, что для <ListView> верхний и нижний колонтитулы не являются липкими; они прокручиваются вместе с остальным списком. Если вам нужен липкий верхний или нижний колонтитул, вероятно, проще всего отобразить их отдельно от компонента <ListView> . Пример 4-9. Добавление методов для отображения элементов верхнего и нижнего колонтитулов в BookListV2.js _renderHeader: функция() { return (<View style={styles.sectionDivider}> <Text style={styles.headingText}> Бестселлеры художественной литературы в твердом переплете </Текст> </View>); }, _renderFooter: функция() { return( <View style={styles.sectionDivider}> <Текст> Данные из списка бестселлеров New York Times. </Text> </View> ); }, Все вместе, этоприложение для бестселлеров состоит из двух файлов: BookListV2.js и BookItem.js. BookListV2.js показано в примере 4-10. (BookList.js это более простой файл, в котором отсутствует выборка данных из API, и он включен в репозиторий GitHub для вашей справки.) Экзаменстраница 4-10. Bestsellers/BookListV2.js 'использовать строгий'; var React = требовать('react-native'); var { таблица стилей, текст, вид, изображение, ListView, } = реагировать; var BookItem = требовать('./BookItem'); var API_KEY = '73b19491b83909c7e07016f4bb4644f9:2:606672 90'; var QUERY_TYPE = 'художественная литература в твердом переплете'; var API_STEM = 'http://api.nytimes.com/svc/books/v3/lists ' var ENDPOINT = \`$ {API_STEM}/$ {QUERY_TYPE}?response-format=json&api-key=$ {API_KEY}\`; var BookList = React.createClass({ getInitialState: функция() { var ds = новый ListView.Источник данных({rowHasChanged: (r1, r2) => r1 !== r2}); return { источник данных: ds.cloneWithRows([]) }; }, componentDidMount: функция() { this._refreshData(); }, _renderRow: функция(rowData) { возврат <BookItem coverURL={rowData.book_image} title={rowData.title} автор={rowData.author}/>; }, _renderHeader: функция() { возврат (<View style={styles.sectionDivider}> <Text style={styles.headingText}> Бестселлеры художественной литературы в твердом переплете </Text > </View>); }, _renderFooter: функция() { возвращает( <View style={styles.sectionDivider}> <Текст>Данные из списка бестселлеров New York Times.</Text> </View> ); }, _refreshData: функция() { выборка(КОНЕЧНАЯ ТОЧКА) .затем((response) => response.json()) .затем((rjson) => { this.setState({ Источник данных: this.state.DataSource.cloneWithRows(rjson.results.books) }); }); }, render: функция() { return ( <Стиль ListView= DataSource={this.state.DataSource} renderRow={this._renderRow} renderHeader={это._renderHeader} renderFooter={это._renderFooter} /> ); } }); var styles = таблица стилей.create({ контейнер: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#FFFFFF', paddingTop: 24 }, список: { flex: 1, flexDirection: 'строка' }, listContent: { flex: 1, flexDirection: 'столбец' }, строка: { flex: 1, размер шрифта: 24, отступы: 42, borderWidth: 1, borderColor: '#DDDDDD' }, sectionDivider: { padding: 8, backgroundColor: '#EEEEEE', alignItems: 'center' }, headingText: { flex: 1, FontSize: 24, alignSelf: 'center' } }); module.exports = BookList; <BookItem> - это простой компонент, который обрабатывает рендерингкаждого дочернего представления в списке (пример 4-11). Пример 4-11. Bestsellers/BookItem.js 'использовать строгий'; var React = требовать('react-native'); var { таблица стилей, текст, Вид, изображение, ListView, } = реагировать; var styles = таблица стилей.create({ BookItem: { flex: 1, flexDirection: 'row', backgroundColor: '#FFFFFF', borderBottomColor: '#ААААААА', borderBottomWidth: 2, padding: 5 }, обложка: { flex: 1, height: 150, ResizeMode: 'содержать' }, info: { flex: 3, alignItems: 'flex-end', flexDirection: 'column', alignSelf: 'center', paddiчисло: 20 }, author: { FontSize: 18 }, title: { FontSize: 18, FontWeight: 'bold' } }); var BookItem = React.createClass({ PropTypes: { coverURL: React.PropTypes.string.IsRequired, автор: React.PropTypes.string.IsRequired, название: React.PropTypes.string.isrequestired }, render: функция() { return ( <Стиль представления={styles.BookItem}> <Стиль изображения={styles.cover} источник=/> <Стиль представления={styles.info }> <Стиль текста={styles.author}>{this.props.author}</Text> <Стиль текста={styles.title}>{this.props.title}</Text> </View> </View> ); } }); module.exports = BookItem; Если у вас сложные данные или очень длинные списки, вам нужно будет обратить внимание на оптимизацию производительности, включаемую некоторыми из более сложных необязательных свойств <ListView>. Однако для большинства применений этого будет достаточно. Использование навигаторов В <ListView> является хорошим примером объединения нескольких представлений в более удобное взаимодействие. На более высоком уровне мы можем использовать такие компоненты, как <Навигатор>, для представления различных экранов приложения, подобно тому, как у нас могут быть различные страницы на веб-сайте. <Навигатор> - это тонкий, но важный компонент, который используется во многих распространенных приложениях. Например, приложение настроек iOS может быть реализовано как комбинация <Navigator> со многими компонентами <ListView> (рис. 4-8). В приложении Dropbox также используется навигатор. Рисунок 4-8. Приложение "Настройки iOS" - хороший пример поведения навигатора. <Navigator> позволяет вашему приложению переключаться между разными экранами (часто называемыми “сценами”), сохраняя при этом “стек” roэлементов, так что вы можете нажимать, всплывать или заменять состояния. Вы можете рассматривать это как аналог history API в Интернете. “Маршрут” - это заголовок экрана в сочетании с индексом. Например, в приложении "Настройки" изначально стек пуст. Когда вы выбираетеодно из подменю, начальная сцена помещается в стек. Нажатие “назад” в левом верхнем углу экрана вернет его обратно. Если вам интересно, как это работает, в приложении UIExplorer есть хорошая демонстрация различных способов использования Navigator API. Обратите внимание, что на самом деле существует два варианта навигатора: кроссплатформенный компонент <Navigator> и компонент <NavigatorIOS>. В этой книге мы предпочтем использовать <Navigator> . ДОЛЖЕН ЛИ я ИСПОЛЬЗОВАТЬ NAVIGATOR Или NAVIGATORIOS? Забавно, что вы спросили! В документах React Native есть страница, посвященная именно этому вопросу. Краткий ответ таков: вам следует использовать <Navigatorios> . <NavigatorIOS> не поддерживается основной командой и, следовательно, содержит некоторые ошибки. Более длинный ответ: <Navigator> - это повторная реализация на JavaScriptповедения Navigator как для Android, так и для iOS. Таким образом, он полностью кроссплатформенный и гибкий. Специфичный для iOS <NavigatorIOS> оборачивает версию UIKit, поэтому вы получаете поведение и анимацию Apple. Его API более ограничен, и поскольку он не является приоритетным для основной команды, вы, вероятно, не захотите его использовать.Другие организационные компоненты Существует также множество других организационных компонентов. Например, несколько полезных из них включают <TabBarIOS> и <SegmentedControlIOS> (показано на рис. 4-9), а такжеи <DrawerLayoutAndroid> и <ToolbarAndroid> (показано на рис. 4-10). Вы заметите, что все они имеют имена с суффиксами, зависящими от платформы. Это потому, что они используют собственные API для элементов пользовательского интерфейса, зависящих от платформы. Рисунок 4-9. Сегментированный элемент управления iOS (вверху) и панель вкладок iOS (внизу) Рисунок 4-10. Панель инструментов Android (слева) и ящик Android (справа) Эти компоненты очень полезны для организации нескольких экранов в вашем приложении. Например, <TabBarIOS> и <DrawerLayoutAndroid> предоставляют вам простой способ переключения между несколькими режимами или функциями. <SegmentedControlIOS> и <ToolbarAndroid> лучше подходят для более детализированных элементов управления. Вы захотите обратиться к рекомендациям по проектированию для конкретной платформы, чтобы узнать, как лучше всего использовать эти компоненты: AРуководство по дизайну ndroid Рекомендации по пользовательскому интерфейсу iOS, но подождите! Как мы используем компоненты, зависящие от платформы? Теперь давайте посмотрим, как обращаться с компонентами, зависящими от платформы, в кроссплатформенных приложениях. Компоненты, зависящие от платформы Не всекомпоненты доступны на всех платформах, и не все схемы взаимодействия подходят для всех устройств. Однако это не означает, что вы не можете использовать код, зависящий от платформы, в своем приложении! В этом разделе мы рассмотрим компоненты, зависящие от конкретной платформы, а такжерасскажем о стратегиях их включения в ваши кроссплатформенные приложения. СОВЕТ: Написание кроссплатформенного кода на React Native - это не попытка "все или ничего"! Вы можете смешивать кроссплатформенный и платформенно-ориентированный код в своем приложении, как мы сделаем в этомразделе. Компоненты только для iOS или Android Некоторые компоненты доступны только на определенной платформе. Сюда входят такие вещи, как <TabBarIOS> или <SwitchAndroid>. Обычно они зависят от платформы, потому что они содержат какой-то базовый для конкретной платформы API. Для некоторых компонентов наличие независимой от платформы версии не имеет смысла. Например, компонент <ToolbarAndroid> предоставляет специфичный для Android API для типа представления, который в любом случае не существует в iOS. Компоненты, зависящие от платформы, называются с соответствующим суффиксом: либо IOS, либо Android. Если вы попытаетесь включить один из них не на той платформе, ваше приложение выйдет из строя. Компоненты также могут иметь реквизиты, зависящие от платформы. В документации они помечены небольшим значком, указывающим на их использование. Для примера, <TextInput> имеет некоторые реквизиты, не зависящие от платформы, а другие специфичны для iOS или Android (рис. 4-11). Рис. 4-11. <TextInput> содержит компоненты props для Android и iOS с версиями для конкретной платформы. Итак, как вы обрабатываете компоненты platдля конкретной формы или props в кроссплатформенном приложении? Хорошей новостью является то, что вы по-прежнему можете использовать эти компоненты. Помните, что в нашем приложении есть как файл index.ios.js, так и файл index.android.js? Это соглашение об именовании может быть использовано для любого файла, чтобы создатькомпонент, который имеет разные реализации на Android и iOS. В качестве примера мы будем использовать компоненты <SwitchIOS> и <SwitchAndroid>. Они предоставляют немного разные API, но что, если мы просто захотим использовать простой switch? Давайте создадим компонент-оболочку com, <Switch>, который отображает соответствующий компонент для конкретной платформы. Начнем с реализации switch.ios.js (Пример 4-12). Это очень простая оболочка для <SwitchIOS>, которая позволяет нам предоставлять обратный вызов при изменении значения switch. Например,mple 4-12. Switch.ios.js var React = require('react-native'); var { SwitchIOS } = React; var Switch = React.createClass({ getInitialState() { return {value: false}; }, _onValueChange(value) { this.setState({value: значение}); if (this.props.onValueChange) { this.props.onValueChange(значение); } }, render() { return ( <SwitchIOS onValueChange={this. _onValueChange} значение={this.state.value}/> ); } }); module.exports = Переключатель; Далее давайте реализуем switch.android.js (Пример 4-13). Пример 4-13. Switch.android.js var React = require('react-native'); var { SwitchAndroid } = React; var Switch = React.createClass({ getInitialState() { return {value: false}; }, _onValueChange(value) { this.setState({value: значение}); if (this.props.onValueChange) {this.props.onValueChange(значение); } }, render() { return ( <SwitchAndroid onValueChange={this. _onValueChange} значение={this.state.value}/> ); } }); module.exports = переключатель; Обратите внимание, что он выглядит почти идентично switch.ios.js , и он реализует тот же API. Единственное отличие в том, чтоон использует <SwitchAndroid> внутри вместо <SwitchIOS>. Теперь мы можем импортировать наш компонент <Switch> из другого файла с синтаксисом: var Switch = require('./switch'); ... var switchComp = <Переключить onValueChange={(val) => {console.log(val); }}/>; Давайте на самом деле использовать компонент <Switch>. Создайте новый файл, CrossPlatform.js и включите код, показанный в примере 4-14. Мы изменим цвет фона на основе текущего значения <Switch> . Пример 4-14. CrossPlatform.js использует компонент <Switch> var React = require('react-native'); var { таблица стилей, текст, представление, } = React; var Switch = require('./switch'); var CrossPlatform = React.createClass({ getInitialState() { return {val: false}; }, _onValueChange(val) { this.setState({val: val}); }, render: function() { var colorClass = this.state.val ? styles.blueContainer : styles.redContainer; return ( <Стиль представления={[стили.контейнер, цветовой класс]}> <Стиль текста={стили.добро пожаловать}> Сделай меня синим! </Text> <Переключить onValueChange={this._onValueChange}/> </View> ); } }); var styles = StyleSheet.create({ контейнер: { flex: 1, justifyContent: 'center', alignItems: 'center', }, blueContainer: { backgroundColor: '#5555FF' }, redContainer: { backgroundColor: '#FF5555' }, welcome: { Размер шрифта: 20, TextAlign: ' center', поле: 10, } }); module.exports = кроссплатформенный; Обратите внимание, что нет switch.js файл, но мы можем вызвать require(./switch). Упаковщик React Native автоматически выберет правильную реализацию на основе нашей платформы и будет использовать либо switch.ios.js, либо switch.android.js по мере необходимости. Наконец, замените содержимое index.android.js и index.ios.js, чтобы мы могли отобразить компонент <CrossPlatform>. Пример 4-15. Файлы index.ios.js и index.android.js должны быть идентичными, и просто импортируйте ихон crossplatform.js файл var React = require('react-native'); var { AppRegistry } = React; var CrossPlatform = require('./crossplatform'); AppRegistry.registerComponent('PlatformSpecific', () => CrossPlatform); Теперь мы можем запускать наше приложение как на iOS, так и наAndroid (рис. 4-12). Рисунок 4-12. Кроссплатформенное приложение должно отображаться как на iOS, так и на Android с использованием соответствующего компонента <Switch> Когда использовать компоненты, зависящие от платформы Когда уместно использовать компонент, зависящий от платформы? Во многихслучаях вам захочется сделать это, когда существует специфичный для платформы шаблон взаимодействия, которому вы хотите, чтобы придерживалось ваше приложение. Если вы хотите, чтобы ваше приложение казалось по-настоящему “родным”, стоит обратить внимание на нормы пользовательского интерфейса, зависящие от конкретной платформы. И Apple, и Google предоставляют рекомендации по пользовательскому интерфейсу для своих платформ, с которыми стоит ознакомиться: Рекомендации по пользовательскому интерфейсу для iOS, Справочник по дизайну для Android Создавая версии только определенных компонентов для конкретной платформы, вы можете найти баланс между повторным использованием кода и настройкой на основе платформы. В большинстве случаев вам понадобятся только отдельные реализации нескольких компонентов, чтобы поддерживать как iOS, так и Android. Краткое содержание В этой главе мы углубились в специфику множества наиболее важных компонентовReact Native. Мы обсудили, как использовать базовые компоненты низкого уровня, такие как <Text> и <Image>, а также компоненты более высокого порядка, такие как <ListView>, <Navigator> и <TabBarIOS>. Мы также рассмотрели, как использовать различные API и компоненты, ориентированные на касание, на случай, если вы захотите создать свои собственные обработчики касаний. Наконец, мы увидели, как использовать компоненты, зависящие от платформы, в наших приложениях. На этом этапе вы должны быть подготовлены к созданию базовых функциональных приложений с использованием React Native! Теперь, когда вы ознакомились с компонентами, обсуждаемыми в этой главе, работа с ними и их объединение для создания собственных приложений должны быть удивительно похожи на работу с React в Интернете. Конечно, создание базовых, функционирующих приложений это только часть битвы. В следующей главе мы сосредоточимся на стилизации и на том, как использовать реализацию стилей в React Native, чтобы получить желаемый внешний вид на мобильных устройствах. Глава 5. Стили Здорово иметь возможность создавать функциональные приложения, но если вы не можете эффективно стилизовать их, вы не продвинетесь далеко!В главе 3 мы создали простое погодное приложение с некоторыми базовыми стилями. Хотя это дало нам общее представление о том, как стилизовать компоненты React Native, мы умолчали о многих деталях. В этой главеr мы подробнее рассмотрим, как работают стили в React Native. Мы расскажем, как создавать таблицы стилей и управлять ими, а также подробно расскажем о реализации правил CSS в React Native. К концу этой главы вы должны чувствовать себя комфортно, создавая и стилизуя свои собственные компоненты и приложения React Native. Если вы хотите совместно использовать стили между вашим React Native и веб-приложениями, проект React Style на GitHub предоставляет версию системы стилей React Native для Интернета. Объявление и управлениестилями При работе с React для Интернета мы обычно используем отдельные файлы таблиц стилей, которые могут быть написаны на CSS, SASS или МЕНЕЕ. React Native использует радикально иной подход, полностью перенося стили в мир JavaScript и заставляя вас явно связывать объекты стиля с компонентами. Излишне говорить, что такой подход, как правило, вызывает бурную реакцию, поскольку представляет собой значительный отход от норм стиля, основанных на CSS. Чтобы понять дизайн стилей React Native, сначала нам нужно рассмотреть некоторые проблемы, связанные с традиционными таблицами стилей CSS.1 У CSS есть ряд проблем. Все правила CSS и имена классов имеют глобальную область действия, что означает, что стилизация одного компонента может легко нарушить работу другого, если вы не будете осторожны. Например, если вы включите популярную библиотеку начальной загрузки Twitter, вы введете более 600 новых глобальных переменных. Поскольку CSS явно не связан с элементами HTML, которые он стилизует, устранение мертвого кода затруднено, и может быть нетривиальным определить, какие стили будут применяться к данному элементу. Такие языки, как SASS и LESS, пытаются обойти некоторые из более уродливых частей CSS, но многие из тех же фундаментальных проблем остаются. С React у нас есть возможность сохранить желаемые части CSS, но также и свободуот значительных расхождений. React Native реализует подмножество доступных стилей CSS, уделяя особое внимание тому, чтобы API-интерфейс стилей оставался узким, но при этом очень выразительным. Позиционирование существенно отличается, как мы увидим позже в этой главе. Кроме того, React Native не поддерживает псевдоклассы, анимацию или селекторы. Полный список поддерживаемых свойств можно найти в документации. Вместо таблиц стилей в React Native мы работаем с объектами стилей на основе JavaScript. Одна из самых сильных сторон React заключается в том, что оназаставляет вас сохранять ваш код JavaScript — ваши компоненты - модульными. Привнося стили в сферу JavaScript, React Native подталкивает нас также к написанию модульных стилей. В этом разделе мы рассмотрим механику создания этих объектов стиляи манипулирования ими в React Native. Встроенные стили Встроенные стили - это самый простой синтаксический способ стилизации компонента в React Native, хотя обычно это не лучший способ. Как вы можете видеть в примере 5-1, синтаксис для встроенных стилей в React Native такой же, как и для React для браузера. Пример 5-1. Используя встроенные стили <Text>, быстрая <Text style={{FontStyle: "курсив"}}>коричневая</Text> лиса перепрыгнула через ленивую <Text style={{FontWeight: "жирный шрифт"}}>собаку</Text>. </Text> Встроенные стили имеют некоторые преимущества. Они быстрые и "грязные", что позволяет быстро экспериментировать. Однако вам следует избегать их в целом, поскольку они менее эффективны. Объекты встроенного стиля должны воссоздаваться заново на каждом этапе рендеринга. Даже если вы хотите изменять стили в ответ на prоперации или состояние, вам не обязательно использовать встроенные стили, как мы сейчас увидим. Стилизация с помощью объектов Если вы взглянете на синтаксис встроенного стиля, вы увидите, что он просто передает объект атрибуту style . Однако нет необходимости создавать объект style iв вызове render; вместо этого вы можете отделить его, как показано в примере 5-2. Пример 5-2. Атрибут Style примет объект JavaScript var italic = { FontStyle: 'курсив' }; var bold = { FontWeight: 'полужирный' }; ... render() { return ( <Текст> quick <Стиль текста={курсив}>коричневый</Text> лис перепрыгнул через ленивую <Стиль текста={жирный шрифт}>собаку</Text>. </Text> ); } PanDemo.js, из примера 4-7, дает нам хороший пример варианта использования, в котором неизменяемость обеспечивается таблицей стилей.Созидание - это скорее помеха, чемпомощь. Напомним, что мы хотели обновить местоположение круга на основе движения — другими словами, каждый раз, когда мы получали обновление от PanResponder, нам нужно было обновлять состояние, а также изменять стили круга. В этом случае мывообще не хотим неизменности, по крайней мере, не для стиля, управляющего расположением круга. Следовательно, мы можем использовать обычный объект для сохранения стиля круга. Используя таблицу стилей.Create Вы заметите, что почти весь код примера React Nativeиспользует таблицу стилей.create. Использование StyleSheet.create строго необязательно, но в целом вы захотите его использовать. Вот что говорится в документации: конструкция StyleSheet.create необязательна, но предоставляет некоторые ключевые преимущества. Это гарантирует, что значения являются неизменяемымитабличными и непрозрачными, преобразуя их в простые числа, которые ссылаются на внутреннюю таблицу. Помещая его в конец файла, вы также гарантируете, что они создаются только один раз для приложения, а не при каждом рендеринге. Другими словами, StyleSheet.create - это на самом деле просто синтаксический сахар, предназначенный для вашей защиты. Используйте его! В подавляющем большинстве случаев полезна неизменяемость, обеспечиваемая StyleSheet.create. Это также дает вам возможность выполнять проверку реквизитов с помощью PropTypes: стили, созданные с помощью StyleSheet.create, могут быть проверены с помощью View.PropTypes .Стиль и текст.проптипы.Типы стилей. Объединение стилей Что произойдет, если вы захотите объединить два или более стилей? Напомним, ранее мы говорили, что следует предпочесть повторное использование стилизованных компонентов стилям. Это правда, но иногда повторное использование стиля также полезно. Например, если у вас есть стиль button и стиль accentText, вы можете захотеть объединить их для создания компонента AccentButton. Если стили выглядят следующим образом: var styles = Stylesheet.create({ button: { borderRadius: '8px', backgroundColor: '#99CCFF' }, accentText: { FontSize: 18, FontWeight: 'bold' } }); Тогда вы можете создать компонент, к которому оба этих стиля будут применены с помощью простой конкатенации (пример 5-3). Пример 5-3. Атрибут Style также принимает массив объектов var AccentButton = React.createClass({ render: function() { return ( <Стиль текста={[styles.button, styles.accentText]}> {this.props.children} </Text> ); } }); Как вы можете видеть, атрибут style может принимать массив объектов style. Вы также можете добавить сюда встроенные стили, если хотите (пример 5-4). Пример 5-4. Вы можете смешивать объекты стиля и встроенные стили var AccentButton = React.createClass({ render: функция() { return ( <Стиль текста={[styles.button, styles.accentText, {color: '#FFFFFF'}]}> {this.props.children} </Text> ); } }); В случае конфликта, например, когда два объекта задают одно и то же свойство, React Native разрешит конфликт за вас. Крайние правые элементы в массиве стилей имеют приоритет, а ложные значения (false, null, undefined) игнорируются. Вы можете использовать этот шаблон для применения условных стилей. Например, если бы у нас был компонент <Button> и мы хотели применить дополнительные правила стиля при касании к нему, мы могли бы использовать код, показанный в примере 5-5. Пример 5-5. Использование условных стилей <View style={[стили.кнопка, это.состояние.касание && стили.выделить]} /> Этот ярлык может помочь вам сохранить логику рендеринга лаконичной. В целом, объединение стилей является полезным инструментом для объединения стилей. Интересно продолжитьрасширять конкатенацию с помощью веб-подходов к таблицам стилей: @extend в SASS или вложенности и переопределения классов в ванильном CSS. Объединение стилей - это более ограниченный инструмент, что, возможно, хорошо: оно упрощает логику и упрощает рассуждения о том, какие стили применяются и как. Организация и наследование В большинстве примеров, приведенных на данный момент, мы добавляем наш код стиля в конец основного файла JavaScript одним вызовом Stylesheet.create. Для примера кода это работает достаточно хорошо, ноэто не то, что вы, вероятно, захотите делать в реальном приложении. Как нам на самом деле организовать стили? В этом разделе мы рассмотрим способы организации ваших стилей, а также способы совместного использования и наследования стилей. Экспорт объектов стиля По мере того, как ваши файлы стилябудут усложняться, вам захочется хранить их отдельно от файлов JavaScript ваших компонентов. Один из распространенных подходов заключается в создании отдельной папки для каждого компонента. Если у вас есть компонент с именем <Имя_компонента>, вам следует создать папку с именем ComponentName/ и структурировать ее следующим образом: - Имя_компонента |- index.js |- styles.js Внутри styles.js , вы создаете таблицу стилей и экспортируете ее (пример 5-6). Пример 5-6. Экспорт стилей из файла JavaScript 'use strict'; var React = require('react-native'); var { Sтаблица стилей, } = React; var styles = Таблица стилей.create({ текст: { цвет: '#FF00FF', размер шрифта: 16 }, жирный шрифт: { вес шрифта: 'bold' } }); module.exports = стили; Внутри index.js , мы можем импортировать наши стили следующим образом: var styles = require('./styles.js'); Затем мы можемиспользовать их в нашем компоненте (пример 5-7). Пример 5-7. Импорт стилей из внешнего файла JavaScript 'use strict'; var React = требовать('react-native'); var styles = требовать('./styles.js '); var { View, Text, StyleSheet } = React; var ComponentName = React.createClass({ render: функция() { return ( <Стиль текста={[стили.текст, стили.жирный шрифт]}> Привет, мир </Text> ); } }); Передавая стили в качестве реквизита, вы также можете передавать стили в качестве свойств. propType View.PropTypes.style гарантирует, что в качестве реквизитов передаются только допустимые стили. Вы можете использовать этот шаблон для создания расширяемых компонентов, которые могут более эффективно управляться и стилизоваться их родителями. Например, компонент может использовать необязательный реквизит стиля (пример 5-8). Пример 5-8. Компоненты могут получать стилизованныеобъекты через props 'use strict'; var React = требовать('react-native'); var { View, Text } = Реагировать; var CustomizableText = Реагировать.createClass({ PropTypes: { стиль: Текст.PropTypes.Style }, getDefaultProps: function() { return { style: {} }; }, render: function() { return ( <Стиль текста={[myStyles.text, this.props.style]}> Привет, мир </Text> ); } }); Добавляя this.props.style в конец массива styles, мы гарантируем, что вы сможете переопределить реквизит по умолчанию. Повторное использование стилей и общий доступ к ним Обычно мы предпочитаем повторноиспользовать стилизованные компоненты, а не повторно использовать стили, но очевидно, что в некоторых случаях вам захочется поделиться стилями между компонентами. В этом случае обычным шаблоном является организация вашего проекта примерно следующим образом: - js |- компоненты |- Кнопка |- index.js |- styles.js |- стили |- styles.js |- colors.js |- fonts.js Имея отдельные каталоги для компонентов и стилей, вы можете четко определять предполагаемое использование каждого файла в зависимости от контекста. Папка компонента должна содержать его класс React, так же как мызаполняем любые файлы, относящиеся к конкретному компоненту. Общие стили не должны храниться в папках компонентов. Общие стили могут включать такие элементы, как ваша палитра, шрифты, стандартные поля и отступы и так далее. styles/styles.js требуются другие файлы общих стилей, and предоставляет их; затем ваши компоненты могут запрашивать styles.js и использовать общие файлы по мере необходимости. Или же вы можете предпочесть, чтобы для компонентов требовались определенные таблицы стилей из каталога styles / . Поскольку теперь мы перенесли наши стили в JavaScript, организацияваших стилей на самом деле является вопросом общей организации кода; здесь нет единственно правильного подхода. Позиционирование и разработка макетов Одним из самых больших изменений при работе со стилем в React Native является позиционирование. CSS поддерживает множество методов позиционирования. Между float, абсолютным позиционированием, таблицами, расположением блоков и многим другим легко заблудиться! Подход React Native к позиционированию более сфокусирован, он опирается в первую очередь на flexbox, а также на абсолютное позиционирование, наряду со знакомымисвойствами ar margin и padding . В этом разделе мы рассмотрим, как создаются макеты в React Native, и завершим созданием макета в стиле картины Мондриана. Макеты с Flexbox Flexbox - это режим макета CSS3. В отличие от существующих в laпользовательских режимов, таких как block и inline, flexbox предоставляет нам независимый от направления способ построения макетов. (Все верно: наконец-то вертикальное центрирование стало простым делом!) React Native в значительной степени опирается на flexbox. Если вы хотите подробнее ознакомиться с общей спецификацией, документация MDN - хорошее место для начала. В React Native доступны следующие реквизиты flexbox: flex flexDirection flexWrap alignSelf alignItems Кроме того, эти связанные значения влияют на макет: height width margin border padding Если вы работали с flexbox в Интернете раньше, здесь не будет много сюрпризов. Однако, поскольку flexbox очень важен для создания макетов в React Native, мы потратим некоторое время на изучение того, как это работает. Основная идея flexbox заключается в том, что вы должны иметьвозможность создавать предсказуемо структурированные макеты даже с учетом элементов динамического размера. Поскольку мы разрабатываем для мобильных устройств и должны учитывать различные размеры экрана и его ориентацию, это полезная функция. Начнем с родителя <View>и некоторые дети: <View style="{styles.parent}"> <Text style="{styles.child}"> Ребенок Один </Text> <Text style="{styles.child}"> Ребенок Два </Text> <Text style="{styles.child}"> Ребенок Три </Text> </View> Для начала, мы применили несколько основных стилей взгляды, но не тouched позиционирование сих пор: ВАР стили = стилей.создать({ родитель: { свойство backgroundColor: '#F5FCFF', цвет границы значение: '#0099AA', borderWidth: 5, marginTop: 30 }, ребенка: { необходимо: '#AA0099', borderWidth: 2, для textalign: 'центр', свойство FontSize: 24, } }); результатИнг макета показана на рис. 5-1. Рисунок 5-1. Макет перед добавлением свойств flex в Следующий раз мы установим flex как для родительского, так и для дочернего элемента. Устанавливая свойство flex, мы явно выбираем поведение flexbox. flex принимает число. Это число определяет относительный вес, который получает каждый ребенок; устанавливая его равным 1 для каждого ребенка, мы взвешиваем их одинаково. Мы также устанавливаем flexDirection: 'column', чтобы дочерние элементы располагались вертикально. Если мы переключим это на flexDirection: 'row', дочерние элементы будут расположеныгоризонтально. Эти изменения в стилях можно увидеть в примере 5-9. Рисунок 5-2 иллюстрирует разницу в том, как эти значения влияют на макет. Рисунок 5-2. Настройка основных свойств flex и flexDirection; установка flexDirection в столбец (слева) и установка flexDirection в строку (справа) Пример 5-9. Изменение свойств flex и flexDirection var styles = StyleSheet.create({ parent: { flex: 1, flexDirection: 'column', backgroundColor: '#F5FCFF', borderColor: '#0099AA', bordercolorwidth: 5, marginTop: 30 }, child: { flex: 1, borderColor: '#AA0099', bordercolorwidth: 2, TextAlign: 'center', размер шрифта: 24, } }); Если мы установим alignItems, дочерние элементы будут больше не расширяется, чтобы заполнить все доступное пространство в обоих направлениях. Поскольку мы установили flexDirection: 'строка', они будут расширяться, заполняя строку. Однако теперь они будут занимать столько места по вертикали, сколько им нужно. Затем значение alignItems определяет, где они расположены вдоль поперечной оси. Поперечная ось - это ось, ортогональная направлению изгиба. В этом случае поперечная ось вертикальна. flex-start размещает дочерние элементы вверху, center - по центру, а flex-end - внизу. Давайте посмотрим, что происходит, когда мы устанавливаем alignItems (результат показан на рисунке 5-3): var styles = StyleSheet.create({ parent: { flex: 1, flexDirection: 'row', alignItems: 'flex-start', backgroundColor: '#F5FCFF', borderColor: '#0099AA', bordercolorwidth: 5, marginTop: 30 }, дочерний элемент: { flex: 1, borderColor: '#AA0099', bordercolorwidth: 2, TextAlign : 'center', размер шрифта: 24, } }); Рисунок 5-3. Установка alignItems позиционирует дочерние элементы по поперечной оси, которая является осью, ортогональной направлению flexDirection; здесь мы видим, что flex-start, center и flex-end используют абсолютное позиционирование. В дополнение к flexbox, React Native поддерживает абсолютное позиционирование. Это работает почти так же, как и в Интернете. Вы можете включить это, установив свойство position: position: absolute, после чего вы сможете управлять позиционированием компонента с помощью знакомых свойств left, right, top и bottom . Абсолютно уверенный в себе ребенок будет применять эти координаты относительно положения родительского элемента, поэтому вы можете создать родительский элемент с помощью flexbox, а затем использовать абсолютное положение для дочернего элемента внутри него. На это есть некоторые ограничения. Например, у нас нет z-индекса, поэтому наложение view друг на друга немного сложно. Последнее представление в стеке обычно имеет приоритет. Абсолютное позиционирование может быть очень полезным. Например, если вы хотите создать вид контейнера, который находится под строкой состояния телефона, абсолютное позиционирование mвыполняется так просто: container: { position: 'absolute', top: 30, left: 0, right: 0, bottom: 0 } Собирая это вместе, давайте попробуем использовать эти методы позиционирования для создания более сложного макета. Допустим, мы хотим воспроизвести картину Мондриана. На рисунке 5-4 показан конечный результат. Рисунок 5-4. Мы будем использовать flexbox для создания этого макета Как нам следует приступить к созданию такого макета? Для начала мы создаем родительский стиль, который будет действовать как контейнер. Мы будем использовать абсолютное позиционирование родительского элемента, потому что это наиболееуместно: мы хотим, чтобы он заполнял все доступное пространство, за исключением смещения на 30 пикселей вверху из-за строки состояния в верхней части экрана. Мы также установим для его flexDirection значение column: parent: { flexDirection: 'столбец', позиция: 'абсолютная', вверху: 30, слева: 0, справа: 0, внизу: 0 } Возвращаясь к изображению, мы можем разделить макет на более крупные блоки. Эти разделения во многом произвольны, поэтому мы выберем вариант и будем действовать с ним. На рисунке 5-5 показан один из способов сегментации макета. Рисунок 5-5. Порядок, в котором мы будем оформлять разделы, Мы начинаем с разделения макета на верхний и нижний блоки: <View style={styles.parent}> <View style={styles.topBlock}> </View> <View style={styles.bottomBlock}> </View> </View> Затем мы добавляем следующий слой. Это ввключает как “левый столбец”, так и “нижний правый” сектор, а также фактические компоненты <View> для ячеек три, четыре и пять: <View style={styles.parent}> <View style={styles.topBlock}> <View style={styles.leftCol}> </View> <View style={[styles.cellThree, styles.base]} /> </View> <View style={styles.bottomBlock}> <View style={[styles.cellFour, styles .base]}/> <Стиль просмотра={[styles.cellFive, styles.base]}/> <Стиль просмотра={styles.bottomRight}> </View> </Вид> </View> Окончательная разметка содержит все семь ячеек. В примере 5-10 показан полный компонент. Пример 5-10. Styles/Mondrian/index.js 'использовать строгий'; var React = требовать('react-native'); var { AppRegistry, таблица стилей, текст, вид, } = Реагировать; var styles = требовать('./style'); var Mondrian = React.createClass({ render: function() { return ( <View style={styles.parent}> <View style={styles.topBlock}> <View style={styles.leftCol}> <View style={[styles.cellOne, styles.base]} / > <Стиль просмотра={[styles.base, styles.cellTwo]} /> </View> <Стиль просмотра={[styles.cellThree, styles.база]} /> </View> <Стиль просмотра={styles.bottomBlock}> <Стиль просмотра={[styles.cellFour, styles.base]}/> <Стиль просмотра={[styles.cellFive, styles.base]}/> <Стиль просмотра={styles.bottomRight}> <Стиль просмотра={[styles.cellSix, styles.base ]} /> <View style={[styles.cellSeven, styles.base]} /> </View> </Вид> </View> ); } }); module.exports = Mondrian; Теперь давайте добавим стили, которые заставят это работать (пример 5-11). Пример 5-11. Styles/Mondrian/style.js var React = require('react-native'); var { таблица стилей } = React; var styles = Таблица стилей.create({ parent: { flexDirection: 'column', position: 'absolute', top: 30, left: 0, right: 0, bottom: 0 }, base: { borderColor: '#000000', borderWidth: 5 }, topBlock: { flexDirection: 'row', flex: 5 }, leftCol: { flex: 2 }, bottomBlock: { flex: 2, flexDirection: 'строка' }, bottomRight: { flexDirection: 'столбец', flex: 2 }, cellOne: { flex: 1, ширина нижней границы: 15 }, cellTwo: { flex: 3 }, cellThree: { backgroundColor: '#FF0000', flex: 5 }, cellFour: { flex: 3, backgroundColor: '#0000FF' }, cellFive: { flex: 6 }, cellSix: { flex: 1 }, cellSeven: { flex: 1, backgroundColor: '#FFFF00' } }); module.exports = стили; Краткое описание В этой главе мы рассмотрели, как стили работают в React Native. Хотя во многих отношениях стилизация похожа на то, как работает CSS в Интернете, React Native представляет другую структуру и подход к стилизации. Здесь есть много нового материала, который нужно переварить! На этом этапе вы должны быть в состоянии эффективно использовать стили для создания необходимых вам мобильных пользовательских интерфейсов с помощью React Native. И что самое приятное, экспериментировать со стилямилегко: возможность нажать “перезагрузить” в симуляторе обеспечивает нам тесную обратную связь. (Стоит отметить, что при традиционной мобильной разработке редактирование стиля обычно требует перестройки вашего приложения. Фу ты.) Если вы хотите большепрактиковаться со стилями, попробуйте вернуться к бестселлерам или погодным приложениям и скорректировать их стиль и компоновку. В следующих главах мы создадим больше примеров приложений, и у вас тоже будет много материала для практики! 1 Слайд-шоу Кристофера Чедеаu, известного как Вье “CSS в JS”, содержит хороший обзор. Глава 6. API платформы При создании мобильных приложений вы, естественно, захотите воспользоваться преимуществами конкретных API хост-платформы. React Native упрощает доступ к таким параметрам, как фотопленка телефона, местоположение и постоянное хранилище. Эти платформенные API доступны для React Native через включенные модули, которые предоставляют нам простые в использовании асинхронные интерфейсы JavaScript для этих функций. React Native не включает в себя все функциональные возможности своей хост-платформы по умолчанию; некоторые API платформы потребуют от вас либо написания собственных модулей, либо использования модулей, написанных другими участниками сообщества React Native. Мы рассмотрим этот процесс в главе 7. Документы - лучшее место, где можнопроверить, поддерживается ли API. В этой главе рассматриваются некоторые из доступных API платформы. Для нашего примера мы внесем некоторые изменения в приложение погоды из предыдущих. Мы добавим в приложение геолокацию, чтобы оно автоматическиопределяло местоположение пользователя. Мы также добавим в приложение “память”, чтобы оно запоминало ваши ранее выбранные местоположения. Наконец, мы воспользуемся фотопленкой, чтобы заменить фоновое изображение на одну из фотографий пользователя. В то время как соответствующие фрагменты кода будут представлены в каждом разделе, полный код приложения включен в “Приложение SmarterWeather”. СОВМЕСТИМОСТЬ С IOS И ANDROID Кроссплатформенная поддержка этих API находится в стадии разработки, поэтому, хотя AsyncStorage поддерживается как на iOS, так и на Android, геолокация и фотопленка в настоящее время доступны только для iOS. Ознакомьтесь со списком известных проблем, из-за которых модули все еще переносятся на Android. При использовании геолокации Для мобильных приложений знание местоположения пользователя часто имеет решающее значение. Это позволяет вам предоставлять пользователю контекстуально обновленнуюинформацию о леванте. Многие мобильные приложения широко используют эти данные. К счастью, React Native имеет встроенную поддержку геолокации. Это предоставляется как “полифилл”, не зависящий от платформы. Он возвращает данные на основе веб-спецификации MDN Geolocation APIn. Поскольку мы используем спецификацию геолокации, вам не нужно будет иметь дело с API, зависящими от платформы, такими как службы определения местоположения, и любой код с учетом местоположения, который вы пишете, должен быть полностью переносимым. ГЕОЛОКАЦИЯ В НАСТОЯЩЕЕ ВРЕМЯ ДОСТУПНА ТОЛЬКО ДЛЯ IOS Модуль геолокации скоро будет поддерживаться на Android, но пока он доступен только для iOS. Получение местоположения пользователя с помощью API геолокации для получения местоположения пользователя очень просто. Как показано в примере 6-1, нам нужно позвонить в navigator.geolocation. Пример 6-1. Получив пользователя лocation с навигатором.геолокацию позвонить навигатор.геолокацию.getCurrentPosition( (установки) => { консоли.журнал(положение); }, (ошибка) => {оповещения(ошибка.сообщения);}, {enableHighAccuracy: true, то время ожидания: 20000, атрибута maximumage: 1000} ); в соответствии с Geolocatiна спецификации, мы не импортировать этот API как отдельный модуль; это просто доступная для нашего использования. Вызов getCurrentPosition принимает три аргумента: обратный вызов с успехом, обратный вызов с ошибкой и набор настроек. Требуется только обратный вызов с успехом.Объект position, переданный в успешный обратный вызов, будет содержать координаты, а также временную метку. В примере 6-2 показан формат и возможные значения. Пример 6-2. Форма ответа, возвращаемого из вызова getCurrentPosition { координаты: { скорость:-1, долгота:-122.03031802, широта: 37.33259551999998, точность: 500, курс:-1, высота: 0, высотная точность:-1 }, временная метка: 459780747046.605 } Географические объекты должны быть объектом, который необязательно включает ключи timoeut, enableHighAccuracy и maximumAge. тайм-аут - это , вероятно, самый важный параметр, когда речь заходит о влиянии на логику вашего приложения. Данные о местоположении разрешений на обработку являются конфиденциальной информацией и, следовательно, не будут доступны вашему приложению по умолчанию. Ваше приложение должно иметь возможность обрабатывать принимаемые или отклоняемые разрешения. Большинство мобильных платформ имеют некоторое представление о разрешениях на определение местоположения. Например, пользователь может полностью заблокировать Службы определения местоположения на iOS или управлять разрешениями для каждого приложения отдельно. Если пользователь отказывает y вдоступе к нашему приложению, будет вызван обратный вызов отмены, который вы передаете getCurrentPosition . Важно отметить, что разрешения на определение местоположения могут быть отозваны практически в любой момент времени. Ваше приложение всегда должно быть готово к тому, что вызов геолокации завершится неудачей. При первой попытке вашего приложения получить доступ к местоположению пользователя пользователю будет представлено диалоговое окно разрешений, подобное тому, что показано на рисунке 6-1. Рисунок 6-1. Запрос местоположения, пока это диалоговое окно активно, ни один обратный вызов не будетвыполнен; как только пользователь выберет опцию, будет вызван соответствующий обратный вызов. Этот параметр сохранится для вашего приложения, поэтому в следующий раз такая проверка не потребуется. Если пользователь отклоняет разрешения, вы можете выполнить автоматический сбой, если хотите, но большинство приложений используютдиалоговое окно с предупреждением для повторного запроса разрешений. Тестирование геолокации в симуляторе iOS Скорее всего, большую часть тестирования и разработки вы будете выполнять в симуляторе или, по крайней мере, за своим рабочим столом. Как вы можете протестировать, как будет вести себя ваше приложение в разных местоположениях? Симулятор iOS позволяет вам легко подделать другое местоположение. По умолчанию вы будете находиться недалеко от штаб-квартиры Apple в Калифорнии, но вы можете указать и любые другие координаты, перейдя в меню Отладка → Местоположение → Пользовательское местоположение ..., как показано на рисунке 6-2. Рисунок 6-2. Выбор местоположения В процессе тестирования рекомендуется опробовать разные местоположения. Для тщательного тестирования, конечно, потребуется загрузить приложение на реальное устройство. Отслеживание местоположения пользователяВы также можете установить наблюдение за местоположением пользователя и получать обновления всякий раз, когда оно меняется. Это можно использовать для отслеживания местоположения пользователя с течением времени или просто для того, чтобы ваше приложение получало самую актуальную информацию о местоположении: this.watchID = навигатор.геолокация.watchPosition((позиция) => { this.setState({position: положение}); }); Обратите внимание, что вы захотите очистить часы, когда ваш компонент также отключится: componentWillUnmount: function() { navigator.geolocation.clearWatch(this.watchID); } Ограничения Поскольку геолокация основана на спецификации MDN, в ней отсутствуют более продвинутые функции, основанные на местоположении. Например, iOS предоставляет API геозоны, который позволяет вашему приложению получать уведомления, когда пользователь входит в определенный географический регион (геозона) или покидает его. В настоящее время React Native не предоставляет этот API. Это означает, что если вы хотите использовать функции, основанные на местоположении, которые в настоящее время не включены в спецификацию MDN Geolocation, вам нужно будет перенести их самостоятельно. Обновление приложения Weather Приложение SmarterWeather - это обновленная версия приложения Weather, в котором теперь используется API геолокации. Вы можете видеть эти изменения на рисунке 6-3. Наиболее примечательным является новый компонент, <LocationButton>, который извлекает текущее местоположение cuпользователя и вызывает обратный вызов при нажатии. Код для <LocationButton> показан в примере 6-3. Рисунок 6-3. Отображение прогноза на основе текущего местоположения пользователя Пример 6-3. SmarterWeather/LocationButton/index.js : при нажатии button получает местоположение пользователя var React = require('react-native'); var styles = require('./style.js '); var Button = требовать('./../Кнопка'); var LocationButton = Реагировать.createClass({ PropTypes: { onGetCoords: Реагировать.PropTypes.func.IsRequired }, _onPress: функцияn() { navigator.geolocation.getCurrentPosition( (initialPosition) => { this.props.onGetCoords(initialPosition.coords.latitude, initialPosition.coords.longitude); }, (ошибка) => {alert(error.message)}, {enableHighAccuracy: true, время ожидания: 20000, Максимальное значение: 1000} ); }, визуализация: функция () { return ( <Button label="Use currentLocation" style={styles.locationButton} onPress={this._onPress}/> ); } }); module.exports = LocationButton; Компонент кнопки, используемый LocationButton, включен в конце этойглавы; он просто оборачивает компонент <Text> в соответствующий <TouchableHighlight> с некоторым базовым оформлением. Нам также пришлось обновить основной файл weather_project.js, чтобы он соответствовал двум типам запросов (пример 6-4). К счастью, API OpenWeatherMap позволяет нам выполнять запросы по широте и долготе, а также по почтовому индексу. Пример 6-4. Добавление функций _getForecastForCoords и _getForecastForZip var WEATHER_API_KEY = 'bbeb34ebf60ad50f7893e7440a1e2b0b'; var API_STEM = 'http://api.openweathermap.org/data/2.5/weather ?'; ... _getForecastForZip: функция(zip) { this._getForecast( \`$ {API_STEM}q=$ {zip}&units=imperial&APPID=$ {WEATHER_API_KEY}\`); }, _getForecastForCoords: функция (широта, lon) { this._getForecast( \`$ {API_STEM}широта=$ {lat}&lon=$ {lon}&units=imperial&APPID=$ {WEATHER_API_KEY}\`); }, _getForecast: функция(url, cb) { выборка(url) .then((ответ) => response.json()) .then((responseJSON) => { console.log(responseJSON); this.setState({ прогноз: { main: responseJSON.weather[0].main, описание: responseJSON.weather[0].описание, temp: responseJSON.main.temp } }); }) .catch((ошибка) => { console.warn(ошибка); }); } Затем мы включаем LocationButton в основное представление с _getForecastForCoords в качестве обратного вызова: <LocationButton onGetCoords={this._getForecastForCoords}/> Я опустилсоответствующие обновления стиля и так далее, поскольку полностью обновленный код приложения будет включен в конце этой главы. Здесь еще предстоит проделать много работы, если вы действительно хотите донести это до пользователей — например, более полное приложение включало быулучшенные сообщения об ошибках и дополнительную обратную связь с пользовательским интерфейсом. Но базовая выборка местоположения на удивление проста! Доступ к изображениям и камере пользователя Доступ к локальным изображениям телефона, а также к камере является еще одной важной частью многих мобильных приложений. В этом разделе мы рассмотрим ваши варианты взаимодействия с данными изображений пользователей, а также с камерой. Мы по-прежнему будем использовать проект SmarterWeather. Давайте изменим фоновое изображение, чтобы использовать изображение с фотографий пользователя. Модуль CameraRoll React Native предоставляет интерфейс для работы с CameraRoll — изображениями, которые хранятся на телефоне пользователя и сняты с камеры. В НАСТОЯЩЕЕ время CAMERAROLL ДОСТУПЕН ТОЛЬКО для IOS Модуль CameraRoll скоро будет поддерживаться на Android, но пока он доступен только для iOS.Взаимодействие с CameraRoll в его самой простой форме не слишком сложно. Сначала нам требуется модуль, как обычно: var React = require('react-native'); var { CameraRoll } = React; Затем мы используем модуль для получения информации о фотографиях пользователя, как показано в примере 6-5. Пример 6-5. Базовое использование CameraRoll.getPhotos CameraRoll.getPhotos( {first: 1}, (data) => { console.log(data); }, (error) => { console.warn(error); }); Мы вызываем getPhotos с соответствующим запросом, и он возвращаетнекоторые данные, относящиеся к изображениям CameraRoll. В SmarterWeather давайте заменим компонент верхнего уровня <Image> новым компонентом PhotoBackdrop (пример 6-6). На данный момент PhotoBackdrop просто извлекает самую последнюю фотографию из подборки с камеры пользователя. Примерфайл 6-6. SmarterWeather/PhotoBackdrop/camera_roll_example.js var React = требовать('react-native'); var { Изображение, CameraRoll } = Реагировать; var styles = требовать('./style.js '); var PhotoBackdrop = React.createClass({ getInitialState() { возвращает { photoSource: null } }, componentDidMount() { CameraRoll.getPhotos( {first: 5}, (data) => { this.setState({ photoSource: {uri: data.edges[3].node.image.uri} })}, (error) => { console.warn(ошибка); }); }, render() { return ( <Стиль изображения={styles.backdrop} источник={ this.state.ph otoSource } ResizeMode='cover'> {this.props.children} </Image> ); } }); module.exports = PhotoBackdrop; CameraRoll.getPhotos принимает три аргумента: объект с параметрами, обратный вызов с успехом и обратный вызов с ошибкой. Запрос изображений с помощью GetPhotoParams Объект getPhotoParams может использовать множество опций, которые, как ни странно, не включены в веб-документацию. Мы можем взглянуть на исходный код React Native, чтобы увидеть, какие опции доступны нам: первое число, количество фотографий, которые требуется сделать в обратном порядке, илииндекс приложения photo (т. Е. Самое последнее значение для сохраненных фотографий) после string , курсор, соответствующий page_info {end_cursor}, возвращенный из предыдущего вызова getPhotos groupTypes string , указывает, какую группу использовать для фильтрации результатов. Может быть Album, All, Event и т.д.; полный список типов групп указан в исходной строке groupName, задает фильтр для имен групп, таких как Недавние фотографии или название альбома, тип активов один из всех, Фотографии или видео, задает фильтр для типа активов mimeTypes массив stколец, фильтры на основе mimetype (например, image / jpeg) В нашем базовом вызове getPhotos в примере 6-5 наш объект getPhotoParams был довольно простым: {first: 1} Это просто означает, что мы использовали ищу самую свежую фотографию. Рендеринг изображения сфотопленки Как мы можем рендерить изображение, полученное с фотопленки? Давайте посмотрим на этот успешный обратный вызов: (data) => { this.setState({ photoSource: {uri: data.edges[0].node.image.uri} })}, Структура объекта данных не является сразуродительской, поэтому вы, вероятно, захотите использовать отладчик для проверки объекта. Каждый из объектов в data.edges имеет узел, представляющий фотографию; оттуда вы можете получить URI фактического ресурса. Возможно, вы помните, что компонент <Image> может принимать URI в качестве своего исходного свойства. Итак, мы можем отрендерить изображение, полученное с фотопленки, соответствующим образом установив свойство source: <Источник изображения={this.state.photoSource} /> Вот и все! Вы можете увидеть полученное приложение, включая изображение, на рисунке 6-4. Рисунок6-4. Визуализация изображения с камеры При отображении списка фотографий Во многих приложениях мы предоставляем пользователю возможность выбрать фотографию. Как вы визуализируете экран выбора фотографии? Если вы пользователь iOS, то, возможно, заметили, что, хотя в iOS по умолчанию естьэкран выбора фотографий, многие приложения фактически реализуют свой собственный пользовательский экран. Как показано на рисунке 6-5, и Twitter, и Tumblr имеют пользовательские экраны. В случае Twitter это позволяет выбрать фотографию на экране создания композиции для твита. Рисунок 6-5. Экраны выбора фотографий в приложениях Tumblr (слева) и Twitter (справа) для iOS Экран по умолчанию представляет собой диалог на всю страницу, и выглядит он немного иначе (рис. 6-6). Рис. 6-6. Диалоговое окно по умолчанию Итак, вы можете либо использовать встроенный элемент для этого, либо создать свой собственный. Приложения часто создают пользовательские решения, чтобы обеспечить дополнительную функциональность поверх стандартного интерфейса. Приложение UIExplorer дает нам очень простой пример того, как использовать CameraRoll для создания простого пользовательского представления фотобиблиотеки user, показанный на рис. 6-7. Рисунок 6-7. Пример CameraRoll из приложения UIExplorer - это немного больше, чем взаимодействия CameraRoll, которые мы видели ранее, объединенные с <ListView>. Вы могли бы использовать этот подход для разработки кросс-платформенногокомпонента выбора изображений как для Android, так и для iOS. В iOS нативным элементом пользовательского интерфейса является UIImagePickerController, который React Native поддерживает через модуль ImagePickerIOS. ПОДДЕРЖКА ANDROID ДЛЯ ВЫБОРА ФОТОГРАФИЙ В настоящее время React Native предоставляет ImagePickerIOS API для выбора фотографий или доступа к камере на iOS, но эквивалента для Android пока нет. Ознакомьтесь с документацией для получения самой последней информации. Вы можете импортировать модуль ImagePickerIOS обычным способом: var { ImagePickerIOS } = React; Тогда использовать его будет просто. Мы можем запросить ImagePickerIOS, чтобы узнать, можем ли мы использовать камеру или записывать видео (пример 6-7). Пример 6-7. Проверяем, можем ли мы получить доступ к камере или записать видео, используя ImagePickerIOS ImagePickerIOS.canUseCamera((результат) => { console.log(результат); // логическое значение }); ImagePickerIOS.canRecordVideos((результат) => { console.log(результат); // логическое значение }); Затем, чтобы запустить диалоговое окно выбора фотографии, мы вызываем openSelectDialog, предоставляя ему некоторые опции, а также обратные вызовы для успешноговыбора фотографии и отмены пользователем (пример 6-8 ). Пример 6-8. Запуск диалогового окна выбора фотографий с помощью ImagePickerIOS ImagePickerIOS.openSelectDialog( { showImages: true, showVideos: false, }, (data) => { this.setState({ photoSource: {uri: data} }); }, () => { console.log('Пользователь отменил действие'); }); Этот вызов открывает стандартное диалоговое окно выбора фотографии iOS (рис. 6-8). Рисунок 6-8. Диалоговое окно выбора iOS Данные, передаваемые в успешный обратный вызов, представляют собой URI, который может использоваться как <Image> source prop. Загрузка изображения на сервер Что делать, если вы хотите куда-то загрузить фотографию? React Native поставляется со встроенной функцией загрузки изображений в модуле XHR. Пример UIExplorer демонстрирует один из подходов: var formdata = new FormData(); ... дляrmdata.append('изображение', {...this.state.randomPhoto, name: 'image.jpg '}); ... xhr.send(formdata); XHR - сокращение от XMLHttpRequest. React Native реализует XHR API поверх сетевых API iOS. Подобно геолокации, реализация XHR от React Nativen основана на спецификации MDN. Использование XHR для сетевых запросов несколько сложнее по сравнению с Fetch API, но базовый подход должен выглядеть примерно так, как в примере 6-9. Пример 6-9. Базовая структура для публикации фотографии с использованием XHR var xhr = new XMLHttpRequest(); xhr.open('ОПУБЛИКОВАТЬ', 'http://posttestserver.com/post.php '); var formdata = new FormData(); formdata.append('изображение', {...this.state.photo, название: 'image.jpg '}); xhr.send(formdata); Здесь опущены различные обратные вызовы, которые вы захотите зарегистрироватьдля запроса XHR. Хранение постоянных данных с помощью AsyncStore Большинству приложений потребуется постоянно отслеживать различные данные. Как вы достигаете этого с помощью React Native? iOS предоставляет нам AsyncStorage, хранилище ключей-значений, которое является gпривязанным к вашему приложению. Если вы использовали localStorage в Интернете, AsyncStorage должен выглядеть примерно так же. AsyncStorage, как следует из названия, является асинхронным; его API также довольно прост, и для него по умолчанию включен модуль React Native . Давайте взглянем на то, как этим пользоваться. Ключ хранилища, используемый AsyncStorage, может быть любой строкой; обычно используется формат @AppName:key, например, так: var STORAGE_KEY = '@SmarterWeather:zip'; Модуль AsyncStorage возвращает обещание в ответ как на GetItem, так и наd setItem. Для SmarterWeather давайте загрузим сохраненный почтовый индекс в componentDidMount: AsyncStorage.GetItem(STORAGE_KEY) .then((значение) => { if (значение !== null) { this._getForecastForZip(значение); } }) .catch((ошибка) => console.log('Ошибка AsyncStorage: ' + ошибка.message)) .done(); Затем в _getForecaseForZip мы можем сохранить значение почтового индекса: AsyncStorage.setItem(STORAGE_KEY, zip) .then(() => console.log('Сохраненный выбор на диск: ' + zip)) .catch((ошибка) => console.log('Ошибка AsyncStorage: ' + error.message)) .done(); AsyncStorage также предоставляет методы для удаления ключей, объединения ключей и извлечения всех доступных ключей. Другие варианты хранения Если вы работаете с более сложными, структурированными данными или просто с большим их объемом, вам, скорее всего, понадобятся варианты, выходящие за рамки простого хранилища значений ke. Одной из распространенных баз данных в iOS является SQLite; однако она недоступна как встроенный модуль React Native. В следующей главе мы рассмотрим, как обернуть собственные модули для использования с React Native и как установить модули, которые уже есть у другихпользователей. Приложение SmarterWeather Весь пример кода в этой главе можно найти в каталоге SmarterWeather/. Приложение из главы 3 немного изменилось, поэтому давайте еще раз взглянем на структуру всего приложения (рис.e 6-9). Рисунок 6-9. Содержимое проекта SmarterWeather, компонент верхнего уровня, находится в разделе weather_project.js. Общие стили шрифтов расположены в разделе styles/typography.js. Папки Forecast/, PhotoBackdrop/, Button/ и LocationButton/ содержат новыекомпоненты, используемые в новом приложении SmarterWeather. Компонент WeatherProject, в котором расположен компонент верхнего уровня weather_project.js (Пример 6-10). Это включает использование AsyncStorage для сохранения самого последнего местоположения. Пример 6-10. SmarterWeather/weather_project.js ВАР реагировать = требуется('реагируют родной'); ВАР { стилей, текст, просмотр и TextInput, AsyncStorage, изображения } = реагировал; прогноз ВАР = требуется('./Прогноз'); ВАР LocationButton = требуют('./LocationButton'); ВАР STORAGE_KEY = '@SmarterWeather:молния'; ВАР WEATHER_API_KEY = 'bbeb34ebf60ad50f7893e7440a1e2b0b'; ВАР API_STEM = 'http://api.openweathermap.org/data/2.5/weather?'; // Эта версия использует цветов.png из местных активов // PhotoBackdrop ВАР = требуется('./PhotoBackdrop/local_image'); // это версияСион вас, чтобы выбрать фото PhotoBackdrop ВАР = требуется('./PhotoBackdrop'); // этот вариант тянет за собой указанную фотографию из камеры ролл // PhotoBackdrop ВАР = требуется('./PhotoBackdrop/camera_roll_example'); ВАР WeatherProject = среагировать.createClass({ getInitialState() { возвращение { прогноз: нулевой }; }, componentDidMount: функция() { AsyncStorage.метод getitem(STORAGE_KEY) .затем((значение) => { если (значение !== значения NULL) { это._getForecastForZip(значение); } }) .улов((ошибка) = консоль>.ошибка AsyncStorage журнала (': '+ ошибка.сообщение)) .сделано(); }, _getForecastForZip: функция(ИНДЕКС) { // запоминаем индекс AsyncStorage.setitem класса(STORAGE_KEY, молния) .затем(() => консоли.войти('выбор сохраненного на диске:' + молния)) .улов((ошибка) = консоль>.ошибка AsyncStorage журнала (': '+ ошибка.сообщение)) .сделано(); этот._getForecast( \`$ {API_STEM}и Q=$ {молния}&агрегаты=Императорское значение AppID=$ {WEATHER_API_KEY}\`); }, _getForecastForCoords: функция(широта, долгота) { это._getForecast( \`$ {API_STEM}широта=$ {широта}&долгота=$ {долгота}&агрегаты=Императорское значение AppID=$ {WEATHER_API_KEY}\`); }, _getForecast: функция(URL-адрес, ЦБ) { Фтравления(URL-адрес) .то((ответ) => Ответ.формат JSON()) .затем((responseJSON) => { консоли.журнал(responseJSON); этот.выполнении функция setState({ погоды: { главном: responseJSON.погода[0].главное, описание: responseJSON.погода[0].описание, темп: responseJSON.главная."темп"} }); }) .котч((ошибка) => { консоли.предостеречь(ошибка); }); }, _handleTextChange: функция(событие) { ВАР молния = событие.nativeEvent.текста; этот._getForecastForZip(на молнии); }, визуализации: функция() { ВАР содержание = null; если (это.государство.прогноз !== значения null) { содержание = ( <View style="{styles<wbr">.row}> <Forecast main={this.state.forecast.main} description={this.state.forecast.description} temp={this.state.forecast.temp}/> </View>); } return ( <PhotoBackdrop> <View style={styles.overlay}> <View style={styles.row}> <Text style={textStyles.mainText}> Current weather for </Text> <View style={styles.zipContainer}> <TextInput style={[textStyles.mainText, styles.zipCode]} returnKeyType='go' onSubmitEditing={this._handleTextChange}/> </View> </View> <View style={styles.row}> <LocationButton onGetCoords={this._getForecastForCoords}/> </View> {content} </View> </PhotoBackdrop> ); } }); var textStyles = require('./styles/typography.js'); var styles = StyleSheet.create({ overlay: { paddingTop: 5, backgroundColor: '#000000', opacity: 0.5, }, row: { width: 400, flex: 1, flexDirection: 'row', flexWrap: 'nowrap', alignItems: 'center', justifyContent: 'center', padding: 30 }, zipContainer: { flex: 1, borderBottomColor: '#DDDDDD', borderBottomWidth: 1, marginLeft: 5, marginTop: 3, width: 10 }, zipCode: { width: 50, height: textStyles.baseFontSize, } }); module.exports = WeatherProject; It makes use of shared styles located in styles/typography.js (Example 6-11). Example 6-11. Shared font styles are located in SmarterWeather/styles/typography.js var React = require('react-native'); var { StyleSheet } = React; var baseFontSize = 18; var styles = StyleSheet.create({ bigText: { fontSize: baseFontSize + 8, color: '#FFFFFF' }, mainText: { fontSize: baseFontSize, color: '#FFFFFF' } }); // For use elsewhere… styles['baseFontSize'] = baseFontSize; module.exports = styles; The Forecast Component This component displays the forecast information, including the temperature. It’s used by the <WeatherProject> component above. The code for the <Forecast> component is provided in Example 6-12. Example 6-12. Forecast component renders information about the forecast var React = require('react-native'); var { Text, View, StyleSheet } = React; var styles = require('../styles/typography.js'); var Forecast = React.createClass({ render: function() { return ( <View style={forecastStyles.forecast}> <Text style={styles.bigText}> {this.props.main} </Text> <Text style={styles.mainText}> Current conditions: {this.props.description} </Text> <Text style={styles.bigText}> {this.props.temp}°F </Text> </View> ); } }); var forecastStyles = StyleSheet.create({ forecast: { alignItems: 'center' } }); module.exports = Forecast; The Button Component The <Button> component is a reusable container-style component. It provides a properly- styled <Text> wrapped by a <TouchableHighlight>. The main component file is provided in Example 6-13, and its associated styles are provided in Example 6-14. Example 6-13. Button component provides an appropriately styled <TouchableHighlight> containing a <Text> var React = require('react-native'); var { Text, View, TouchableHighlight } = React; var styles = require('./style.js'); var Button = React.createClass({ propTypes: { onPress: React.PropTypes.func, label: React.PropTypes.string }, render: function() { return ( <TouchableHighlight onPress={this.props.onPress}> <View style={[styles.button, this.props.style]}> <Text> {this.props.label} </Text> </View> </TouchableHighlight> ); } }); module.exports = Button; Example 6-14. Styles for the Button component var React = require('react-native'); var { StyleSheet } = React; var baseFontSize = 16; var styles = StyleSheet.create({ button: { backgroundColor: '#FFDDFF', width: 200, padding: 25, borderRadius: 5 }, }); module.exports = styles; The LocationButton Component When pressed, the <LocationButton> fetches the user’s location and invokes a callback. The component’s main JavaScript file is provided in Example 6-15, and its styles are provided in Example 6-16. Example 6-15. <LocationButton> component var React = require('react-native'); var styles = require('./style.js'); var Button = require('./../Button'); var LocationButton = React.createClass({ propTypes: { onGetCoords: React.PropTypes.func.isRequired }, _onPress: function() { navigator.geolocation.getCurrentPosition( (initialPosition) => { this.props.onGetCoords(initialPosition.coords.latitude, initialPosition.coords.longitude); }, (error) => {alert(error.message)}, {enableHighAccuracy: true, timeout: 20000, maximumAge: 1000} ); }, render: function() { return ( <Button label="Use CurrentLocation" style={styles.locationButton} onPress={this._onPress}/> ); } }); module.exports = LocationButton; Example 6-16. Styles for <LocationButton> var React = require('react-native'); var { StyleSheet } = React; var baseFontSize = 16; var styles = StyleSheet.create({ locationButton: { backgroundColor: '#FFDDFF', width: 200, padding: 25, borderRadius: 5 }, }); module.exports = styles; The PhotoBackdrop Component There are three versions of <PhotoBackdrop> provided, to demonstrate different methods of selecting an image for the background. The first, provided in Example 6-17 and listed as local_image.js in the Github repository, uses a simple require call to load a standard image asset. The second, as seen in Example 6-18 and provided as camera_roll_example.js in the Github repository, selects an image from the user’s CameraRoll. Finally, the third version, is provided in Example 6-19 and as index.js in the Github repository. This version uses ImagePickerIOS to prompt the user to select a background image. Example 6-17. local_image.js is the original version; it uses a simple require call var React = require('react-native'); var { Image } = React; var styles = require('./style.js'); var PhotoBackdrop = React.createClass({ render() { return ( <Image style={styles.backdrop} source={require('image!flowers')} resizeMode='cover'> {this.props.children} </Image> ); } }); module.exports = PhotoBackdrop; Example 6-18. camera_roll_example.js programmatically selects an image from the CameraRoll var React = require('react-native'); var { Image, CameraRoll } = React; var styles = require('./style.js'); var PhotoBackdrop = React.createClass({ getInitialState() { return { photoSource: null } }, componentDidMount() { CameraRoll.getPhotos( {first: 5}, (data) => { this.setState({ photoSource: {uri: data.edges[3].node.image.uri} })}, (error) => { console.warn(error); }); }, render() { return ( <Image style={styles.backdrop} source={ this.state.photoSource } resizeMode='cover'> {this.props.children} </Image> ); } }); module.exports = PhotoBackdrop; Example 6-19. index.js, the final version, uses ImagePickerIOS and asks the user to select an image var React = require('react-native'); var { Image, ImagePickerIOS } = React; var styles = require('./style.js'); var Button = require('./../Button'); var PhotoBackdrop = React.createClass({ getInitialState() { return { photoSource: require('image!flowers') } }, _pickImage() { ImagePickerIOS.openCameraDialog( {}, (data) => { this.setState({ photoSource: {uri: data} }); }, () => { console.log('User canceled the action'); }); }, render() { return ( <Image style={styles.backdrop} source={ this.state.photoSource } resizeMode='cover'> {this.props.children} <Button style={styles.button} label="Load Image" onPress={this._pickImage}/> </Image> ); } });module.exports = PhotoBackdrop; Все три версии используют одну и ту же таблицу стилей, показанную ниже в примере 6-20. Пример 6-20. Все три версии <PhotoBackdrop> используют эту таблицу стилей var React = require('react-native'); var { StyleSheet } = React; var styles = StyleSheet.create({ background: { flex: 1, flexDirection: 'column' }, button: { flex: 1, margin: 100, alignItems: 'center' } }); module.exports = styles; Краткое описание В этой главе мы внесли некоторые изменения в приложение Weather. Мы рассмотрели API-интерфейсы Geolocation, Camera Roll и AsyncStorage и узнали, как интегрировать эти модули в наши приложения. Поскольку поддержка этих API зависит от платформы, вам потребуется изолировать компоненты, которые их используют, чтобы вы могли создавать вокруг них не зависящие от платформыоболочки, как мы видели в главе 4. Помимо проблем совместимости, когда React Native поставляется с поддержкой API хост-платформы, это упрощает использование. Но что произойдет, если React Native еще не поддерживает данный API, например, вслучае воспроизведения видео, и вы хотите использовать библиотеку или модуль, которые еще не доступны в JavaScript? В следующей главе мы подробнее рассмотрим этот сценарий. Глава 7. Модули В главе 6 мы рассмотрели некоторые API, которые React Native expoиспользует для взаимодействия с хост-платформой. Такие вещи, как фотопленка и геолокация, зависят от платформы, но React Native предоставляет для них интерфейсы для нашего удобства. Поскольку поддержка этих API встроена в React Native, ими довольно легкопользоваться. Что происходит, когда мы хотим использовать API, который не поддерживается React Native? В этой главе мы рассмотрим, как устанавливать модули, написанные членами сообщества React Native, с использованием npm. Мы также подробнее рассмотрим один из таких модулей для iOS, react- native-video , и узнаем, как RCTBridgeModule может позволить вам добавлять интерфейсы JavaScript к существующим API Objective-C. Мы также рассмотрим импорт чистых библиотек JavaScript в ваш проект и способы управления зависимостями. В этой главе мы рассмотрим некоторый код Objective-C и Java, но не пугайтесь! Мы будем действовать медленно. Полное введение в мобильную разработку для iOS и Android выходит за рамки этой книги, но мы вместе рассмотрим некоторые примеры. Установка JavaScrбиблиотек ipt с помощью npm Прежде чем мы обсудим, как работают собственные модули, сначала мы должны рассказать о том, как устанавливать внешние зависимости в целом. React Native использует npm для управления зависимостями. npm - это менеджер пакетов для Node.js, но реестр npm включает в себя пакеты для всех видов проектов JavaScript, а не только для Node. npm использует файл с именем package.json для хранения метаданных о вашем проекте, включая список зависимостей. Давайте начнем с создания нового проекта: react-native init Depends После создания нового проекта ваш package.json будет выглядеть примерно так: { "name": "Зависит", "version": "0.0.1", "private": true, "scripts": { "start": "node_modules/react-native/packager/packager.sh " }, "зависимости": { "react-native": "^ 0.12.0" } } Обратите внимание, что на данный момент единственной зависимостью верхнего уровня в вашем проекте является react-native. Давайте добавим еще одну зависимость! Библиотека Lodash похожа на Underscore.js; она предоставляет ряд полезных служебных функций, таких как функция перемешивания для массивов. Мы устанавливаем его с флагом --save, чтобы указать, что его следует добавить в наш список зависимостей: npm install --save Lodash Теперь хэш ваших зависимостей в package.json должен быть обновлен: "dependencies": { "Lodash": "^3.10.1", "react-native": "^0.12.0" } Если вы хотите использовать Lodash в вашем приложении React Native, теперь вы можете запросить его по имени: var _ = require('Lodash'); Давайте используем Lodash для вывода случайного числа: var _ = require('lodash'). 'Lodash'); console.log('Случайное число: ' + _.random(0, 5)); Это работает! Но как насчет других модулей? Можете ли вывключать произвольные пакеты с помощью npm install? Ответ “да”, с некоторыми оговорками. Любые методы, которые касаются DOM, например, приведут к сбою. Интеграция с существующими пакетами может потребовать некоторой доработки, потому что очень многие пакеты делают предположения относительносреды, в которой они будут работать. Но в целом, вы можете воспользоваться преимуществами произвольных пакетов JavaScript и использовать npm для управления вашими зависимостями точно так же, как вы бы поступили в любом другом проекте JavaScript. Нативные модули для iOS Теперь, когда мы увидели, на что похоже добавление внешней библиотеки JavaScript, давайте добавим компонент React Native с помощью npm. В этом разделе мы собираемся использовать react-native- video, компонент React Native, реализованный Брентом Ватне, в качестве нашего основного примера. Этот модуль предоставляет нам компонент <Video>, который можно использовать (сюрприз!) для воспроизведения видео. Затем мы заглянем под капот и посмотрим, как собственные модули работают с Objective-C и iOS. Компонент react-native-video, включающий компонент сторонних производителей, указан в реестре npmistry. Мы можем добавить это в наш проект с помощью npm install: npm install react-native-video --save Если бы мы работали с традиционной веб-разработкой, мы бы уже закончили! react-native- video теперь будет доступен для нашего проекта. К сожалению, здесь это не так; для разработки на iOS нам нужно сообщить Xcode об этой библиотеке. Когда ваш проект открыт в Xcode, щелкните правой кнопкой мыши Библиотеки, затем добавьте файлы в “Depends”… (Рис. 7-1). Рис. 7-1. Щелкните правой кнопкой мыши на вашем проекте и выберите “Добавить файлы в "Depends”… Затем добавьте файл RCTVideo.xcodeproj в свой проект (рис. 7-2). Рис. 7-2. Выберите RCTVideo.xcodeproj из списка файлов; он должен быть расположен в разделе node_modules/react-native-video. Вам также нужно будет добавить video framework в процесс сборки вашего проекта. В разделе Этапы сборки перейдите в подменю Link Binary С библиотеками и нажмите кнопку “+”. Затем добавьте libRCTVideo.a в свой проект (рис. 7-3). Рис. 7-3. Добавьте файл libRCTVideo.a (вы можете воспользоваться строкой поиска, которая поможет вам найти нужный файл) С помощью that, вы закончили импорт модуля RCTVideo в свой проект! Нам также нужно импортировать наш видеофайл mp4 в наш проект Xcode, чтобы он был доступен как ресурс. Щелкните правой кнопкой мыши на вашем проекте и снова выберите Добавить файлы в Depends, как показано на рисунке 7-4. Должен работать любой видеофайл mp4; я использовал видео из прошлого проекта, поскольку оно было у меня под рукой. Вы можете загрузить его с GitHub. Рисунок 7-4. Выберите видеофайл, который вы хотите использовать; здесь мы используем PianoStairs.mp4, после чего вы должны увидеть видеофайл в вашем проекте (рис. 7-5). Рис. 7-5. После успешного добавления видеофайла в ваш проект вы должны увидеть его в Xcode с помощью видеокомпонента OK, теперь, когда вы импортировали его в Xcode, мы можем запросить видеокомпонент из нашего кода JavaScript: var Video = require('react-native-video'); Затем используйте компонент, как обычно. Здесь я установил несколько необязательных реквизитов: <Источник видео={{uri: "PianoStairs"}} // Может быть URL-адресом или локальным файлом. скорость ={1.0} // 0 приостановлено, 1 в норме. vобъем ={1.0} // 0 отключено, 1 в норме. отключено ={false} // Полностью отключает звук. приостановлено ={false} // Полностью приостанавливает воспроизведение. ResizeMode="обложка" // Заполнить весь экран с учетом соотношения сторон. repeat={true} // Повторять вечно. style={styles.backgroundVideo} /> Та-да! У нас есть рабочий видеокомпонент! Хотя процесс использования модулей сторонних производителей с React Native несколько сложнее, чем простая установка npm, это не так уж плохо. Потенциально самая запутанная часть - это правильное включение библиотек в вашпроект r Xcode и работа с графическим интерфейсом Xcode. Для таких модулей, как react-native-video, который был разработан специально для React Native и предоставляет подробные инструкции по этой процедуре в README, это в основном не проблема. Не позволяйте взаимодействию с Xcode помешать вам включать в свой код внешние модули! Многие такие компоненты перечислены в реестре npm и часто используют префикс react- native-. Оглянитесь вокруг и посмотрите, что построило сообщество! Анатомия нативного модуля Objective-C Теперь, когда мы используем модуль react-native-video, давайте посмотрим, как подобные модули работают под капотом. Компонент react-native-video - это то, что React называет собственным модулем. Документация React Native определяет собственный модуль как “ класс Objective-C, который реализует протокол RCTBridgeModule”. (RCT - это сокращение от ReaCT.) Написание кода Objective-C не является частью стандартного процесса разработки с React Native, так что не волнуйтесь — в этом нет необходимости! Но наличие базовых знаний о том, что происходит, из чтения будет полезно, даже если вы не планируете внедрять свои собственные встроенные модули (пока). Если вы никогда раньше не работали с Objective-C, большая часть синтаксиса, с которым вы столкнетесь, может показаться запутанной. Ничего страшного! Мы будем разбираться сngs медленно. Давайте начнем с создания базового модуля “Привет, мир”. Классы Objective-C обычно имеют заголовочный файл, заканчивающийся на .h, который содержит интерфейс для класса. Фактическая реализация находится в файле .m. Давайте начнем с написания нашего файла HelloWorld.h, показанного в примере 7-1. Пример 7-1. Зависит от/iOS/HelloWorld.h #импорт "RCTBridgeModule.h" @интерфейс HelloWorld : NSObject <RCTBridgeModule> @end Что делает этот файл? В первой строке мы импортируем заголовок RCTBridgeModule. (Обратите внимание, что символ # обозначает не комментарий, а скорее инструкцию импорта.) Затем, в следующей строке, мы объявляем, что класс HelloWorld подклассирует NSObject и реализует интерфейс RCTBridgeModule, и завершаем объявление интерфейса с помощью @end . По историческим причинамns, многие базовые типы в Objective-C имеют префикс NS (NSString, NSObject и т.д.). Теперь давайте перейдем к реализации (пример 7-2). Пример 7-2. Depends/iOS/HelloWorld.m #импорт "HelloWorld.h" #импорт "RCTLog.h" @реализация HelloWorld RCT_EXPORT_MODULE(); RCT_EXPORT_METHOD(приветствие:(NSString *)name) { RCTLogInfo(@"Saluton, %@", name); } @в конце в файл .m вам захочется импортировать соответствующий файл .h, как мы делаем здесь в первой строке. Я также импортировал RCTLog.h, чтобы мы могли записывать данные в консоль, используя RCTLogInfo. При импорте других классов в Objective-C вам почти всегда захочется импортировать заголовочный файл, а не файл .m . Строки @implementation и @end указывают, что содержимое между ними является реализацией класса d HelloWorl. Остальные строки выполняют работу по превращению этого модуля в React Native . С помощью RCT_EXPORT_MODULE() мы вызываем специальный макрос React Native, который делает этот класс доступным для моста React Native. Аналогично, наше определение метода для приветствия:name имеет префикс макроса RCT_EXPORT_METHOD, который экспортирует метод и, таким образом, предоставляет его нашему коду JavaScript. Обратите внимание, что имена методов Objective-C имеют несколько странный синтаксис. Имя каждого параметра включено в название метода. Согласно соглашению React Native, имя функции JavaScript является именем Objective-C вплоть до первого двоеточия, поэтому приветствие: name становится приветствием в JavaScript. Вы можете использовать макрос RCT_REMAP_METHOD, чтобы переназначить это именование, если хотите. Затем мы можем вызвать метод из oваших файлов JavaScript (пример 7-3). Пример 7-3. Использование модуля HelloWorld из нашего кода JavaScript var HelloWorld = require('react-native').NativeModules.HelloWorld; HelloWorld.приветствие ('Bonnie'); Вывод должен появиться в консоли (рис. 7-6), both в Xcode и в инструментах разработчика Chrome, если вы решите их включить. Рисунок 7-6. Вывод на консоль, просматриваемый через интерфейс Xcode Обратите внимание, что синтаксис для импорта собственных модулей немного подробный. Распространенный подход заключается в том, чтобы обернуть ваш собственный модульe в модуль JavaScript (пример 7-4). Пример 7-4. Depends/HelloWorld.js : оболочка JavaScript для собственного модуля HelloWorld var HelloWorld = require('react-native').NativeModules.HelloWorld; module.exports = HelloWorld; Тогда требовать этого становится намногопроще: var HelloWorld = require('./HelloWorld'); HelloWorld.js Файл JavaScript также является хорошей возможностью добавить любую функциональность на стороне JavaScript в ваш модуль. Уф. Objective-C может показаться слишком подробным, и мы должны отслеживать количествоe разных файлов. Но поздравляю — вы написали “Привет, мир” для своего модуля Objective-C! Для проверки модуль Objective-C должен выполнить следующее, чтобы быть доступным в React Native: Импортировать заголовок RCTBridgeModule Объявите, что ваш module реализует интерфейс RCTBridgeModule Вызовите макрос RCT_EXPORT_MODULE() Имейте по крайней мере один метод, который экспортируется с помощью макроса RCT_EXPORT_METHOD Затем собственные модули могут использовать любой API, предоставляемый iOS SDK. (Обратите внимание, что API, который вы предоставляете для React Native, должен быть асинхронным.) Apple предоставляет обширную документацию по iOS SDK, а также множество ресурсов, доступных от сторонних производителей. Обратите внимание, что здесь пригодятся ваши лицензии разработчика — без них часто бывает трудно получить доступ к документации по e SDK. Теперь, когда мы написали наш собственный базовый “Привет, мир”, давайте подробнее рассмотрим, как реализовано react-native-video. Реализация RCTVideo Как и наш модуль HelloWorld, RCTVideo является собственным модулем, и он реализуетпротокол RCTBridgeModule. Вы можете увидеть полный код для RCTVideo в репозитории react-native- video на GitHub. Мы будем рассматривать версию 0.6.0. react-native-video - это, по сути, оболочка API AVPlayer, предоставляемого iOS SDK. Давайте подробнее рассмотрим, как это работает, начиная с точек входа JavaScript Video.ios.js и Video.android.js. В этой версии функция Video.android.js все еще не реализована, поэтому давайте посмотрим на Video.ios.js. Мы можем видеть, что он обеспечивает тонкую оболочку вокруг natiпятого компонента, RCTVideo, выполняя некоторую нормализацию реквизита и немного дополнительной логики рендеринга. Собственный компонент импортируется в конце: var RCTVideo = requireNativeComponent('RCTVideo', Video); Как мы видели в нашем примере с HelloWorld, это означает, что некоторыегде компонент RCTVideo должен быть экспортирован из Objective-C. Давайте посмотрим на RCTVideo.h: // RCTVideo.h #импорт "RCTView.h" @class RCTEventDispatcher; @интерфейс RCTVideo : UIView - (instancetype)initWithEventDispatcher: (RCTEventDispatcher *)eventDispatcher NS_DESIGNATED_INITIALIZER; @end На этот раз вместо создания подкласса NSObject, RCTVideo создает подкласс UIView. Это имеет смысл, потому что это рендеринг компонента view . Если мы посмотрим на файл реализации, RCTVideo.m , там многое происходит. Вверху находятся переменные экземпляра, отслеживающие такие параметры, как громкость, скорость воспроизведения и сам AVPlayer. Есть один интересный метод, methodQueue , на который нам следует обратить внимание: - (dispatch_queue_t)methodQueue { return dispatch_get_main_queue(); } Это сообщает нам об этомв основной очереди iOS, что необходимо, поскольку модуль использует API iOS только для основного потока. Существуют также различные методы для таких вещей, как вычисление продолжительности видео, загрузка видео и установка его в качестве источника и многое другое. Не стесняйтесь ознакомиться с этими методами и выяснить, какую роль они играют. Другая часть головоломки - это RCTVideoManager. Чтобы создать собственный компонент пользовательского интерфейса, в отличие от простого модуля, нам также нужен диспетчер представлений. Как следует из названия, в то время как view фактически обрабатывает логику рендерингаи аналогичные задачи, view manager занимается другими вещами (обработка событий, экспорт свойств и т.д.). Как минимум, класс view manager должен: Подкласс RCTViewManager Использовать макрос RCT_EXPORT_MODULE() Реализовать метод просмотра -(UIView *) Метод просмотра должен возвращать экземпляр UIView. В этом случае мы можем видеть, что он создает экземпляр и возвращает RCTVideo: - (UIView *)view { return [[RCTVideo alloc] initWithEventDispatcher:self.bridge.EventDispatcher]; } RCTVideoManager также экспортирует ряд свойств и констант: RCT_EXPORT_VIEW_PROPERTY(src, NSDictionary); RCT_EXPORT_VIEW_PROPERTY(ResizeMode, NSString); RCT_EXPORT_VIEW_PROPERTY( repeat, BOOL); RCT_EXPORT_VIEW_PROPERTY(приостановлено, BOOL); RCT_EXPORT_VIEW_PROPERTY(отключено, BOOL); RCT_EXPORT_VIEW_PROPERTY(объем, с плавающей точкой); RCT_EXPORT_VIEW_PROPERTY(скорость, с плавающей точкой); RCT_EXPORT_VIEW_PROPERTY(поиск, с плавающей точкой); - (NSDictionary *)constantsToExport { return @{ @"ScaleNone": AVLayerVideoGravityResizeAspect, @"ScaleToFill": AVLayerVideoGravityResize, @"ScaleAspectFit": AVLayerVideoGravityResizeAspect, @"scaleAspectFill": AVLayerVideoGravityResizeAspectFill }; Вместе RCTVideo и RCTVideoManager составляют собственный компонент пользовательского интерфейса RCTVideo, который мы можем свободно использовать из нашего приложения. Как вы можете видеть, написание собственных модулей, использующих iOS SDK, является нетривиальной задачей, хотя и не непреодолимой. Это определенно одна из областей, где предыдущий опыт разработки iOS сослужит вам хорошую службу. Полное объяснение разработки iOS, безусловно, выходит за рамки этой книги, но, ознакомившись с чужими нативными модулями, даже если у вас нет большого опыта работы с Objective C, вы сможете начать экспериментировать с собственными попытками разработки нативных модулей.....Встроенные модули для Android Встроенные модули для Android работают аналогично встроенным модулям для iOS. Вы можете найти дополнительную информацию о встроенных модулях Android в документации. Для этого раздела мы будем работать в каталоге AndroidDepends / project . Продолжайте и создайте новый проект: react-native init AndroidDeтребует установки стороннего компонента Для этого раздела мы установим пакет react-native-linear-gradient, который предоставляет нам компонент <LinearGradient>. Поскольку создание градиентов является относительно сложной графической задачей, имеет смысл использоватьсобственные API платформы для этого компонента. Итак, <LinearGradient> предоставляет унифицированный компонент React Native, который использует пакет android.graphics и API CAGradientLayer под капотом для Android и iOS соответственно. Вы можете найти проект на GitHub. Как и в iOS, установка встроенных модулей для Android требует, чтобы мы касались кода проекта, специфичного для Android. Вообще говоря, чтобы включить сторонний встроенный модуль Android, вам нужно будет сделать три вещи: 1. Обновите свой android / settings.gradle, чтобы модуль включен в вашу сборку Android. 2. Укажите модуль как зависимость в android / app / build.gradle. 3. Импортируйте пакет в MainActivity.java и включите его как пакет, доступный для React Native. Давайте рассмотрим их один за другим. Сначала мы обновимdate settings.gradle, чтобы включить каталог react- native-linear-gradient . Файл settings.gradle должен выглядеть как пример 7-5. Пример 7-5. AndroidDepends/android/настройки.gradle rootProject.name = 'androiddependts' включает проект ':app', ': react-native-linear-gradient'(':react-native-linear-gradient').ProjectDir = новый файл (RootProject.ProjectDir, '../node_modules/react-native-linear-gradient/android') Gradle - это система сборки для Android. Когда мы используем npm install для установки другого пакета react- native-linear-gra, соответствующие файлы для Android загружаются в нашу папку node_modules /. Обновление настроек.gradle включает эту папку в нашу сборку. Далее нам нужно перечислить модуль react-native-linear-gradient в качестве зависимости в нашем файле build.gradle f(пример 7-6). Вы можете видеть, что этот файл включает в себя ряд параметров сборки, таких как целевая версия Android SDK, а также зависимости приложений, такие как React Native. Нам нужно добавить react-native-linear-gradient в список зависимостей в нижней части файла. Пример 7-6. AndroidDepends/android/app/build.gradle применить плагин: 'com.android.application' android { compileSdkVersion 23 buildToolsVersion "23.0.1" defaultConfig { applicationId "com.androiddepends" minSdkVersion 16 targetSdkVerверсия 22 versionCode 1 versionName "1.0" ndk { abiFilters "armeabi-v7a", "x86" } } buildTypes { release { minifyEnabled false ProGuard Files getDefaultProguardFile('proguard-android.txt '), 'proguard-правила.pro' } } } зависимости { скомпилировать FileTree(каталог: 'библиотеки', включают: ['*.jar']) скомпилировать 'com.android.support: appcompat-v7: 23.0.1' скомпилировать 'com.facebook.react: react-native: 0.12.+' скомпилировать проект(': react-native-linear-gradient') } Наконец, нам нужно обновить наш MainActivity.java. Здесь есть два шага: импортируемLinearGradientPackage, а затем добавляем его в наш ReactInstanceManager. Вы можете добавить следующую инструкцию import в любом месте вверху файла, если она находится перед объявлением класса: import com.BV.LinearGradient.LinearGradientPackage; Затемдобавьте пакет в свой ReactInstanceManager, добавив другой вызов addPackage() после существующего: mReactInstanceManager = ReactInstanceManager.builder() .setApplication(getApplication()) .setBundleAssetName("index.android.bundle") .setJSMainModuleName("index.android") .addPackage(новый MainReactPackage()) . addPackage(новый LinearGradientPackage()) // Добавьте эту строку! .setUseDeveloperSupport(BuildConfig.DEBUG) .setInitialLifecycleState(LifecycleState.ВОЗОБНОВЛЕНО) .build(); OK! После того, как вы это сделаете, мы можем улучшитьпакет из нашего кода JavaScript следующим образом: var LinearGradient = require('react-native-linear-gradient'); Затем мы можем использовать компонент из React Native: <LinearGradient colors={['#FFFFFF', '#00A8A8']} style={styles.container}> <Text style={styles.welcome}> Прекрасный градиент </Text> </LinearGradient> Давайте используем это для создания нового компонента <Градиент>, который заменит экран приложения по умолчанию (пример 7-7). Пример 7-7. AndroidDepends/gradient.js var React = требовать('react-native'); var { таблица стилей, Text } = реагировать; var LinearGradient = требовать('react-native-linear-gradient'); var Gradient = React.createClass({ render: функция() { return ( <LinearGradient colors={['#FFFFFF', '#00A8A8']} style={styles.container}> <Text style={styles.добро пожаловать}> Прекрасныйпомощник </Text> </LinearGradient> ); } }); var styles = StyleSheet.create({ контейнер: { flex: 1, justifyContent: 'center', alignItems: 'center' }, добро пожаловать: { Размер шрифта: 20, TextAlign: 'center', поле: 10, высота: 50, отступ: 20 } }); module.exports = Gradient; И это должно быть все, что нам нужно, чтобы использовать <LinearGradient > компонент. Измените свой index.android.js файл для отображения компонента <Gradient>. Он должен отображать градиент с некоторым текстом, как показано на рисунке 7-7. Рисунок 7-7. Композиция <Gradient>очень крутая! Теперь, когда мы рассмотрели, как включить собственный модуль сторонних производителей для Android, мы рассмотрим, как работают собственные модули в целом, создав еще один модуль “Hello, World”, но на этот раз на Java вместо Objective-C. После этого мы можем внимательновзглянуть на то, как работает react-native-linear-gradient. Анатомия родного модуля Java Чтобы лучше понять, как работают родные модули Java, мы напишем свой собственный. Как и в случае с Objective-C, мы начнем с простого модуля “Привет, мир”. Мы начнем ссоздания файла HelloWorld.java (пример 7-8). Помните, что проекты Android имеют довольно глубокую структуру вложенности. Давайте сделаем HelloWorld.java братом нашего файла MainActivity.java. Пример 7-8. AndroidDepends/android/app/src/main/java/com/androiddepends/Heвесь мир.java-пакет com.androiddepends; импортировать com.facebook.react.bridge.NativeModule; импортировать com.facebook.react.bridge.ReactApplicationContext; импортировать com.facebook.react.bridge.ReactContext; импортировать com.facebook.react.bridge.ReactContextBaseJavaModule; яимпортирую com.facebook.react.bridge.ReactMethod; импортирую android.util.Log; открытый класс HelloWorld расширяет ReactContextBaseJavaModule {открытый HelloWorld(ReactApplicationContext reactContext) { super(reactContext); } @Переопределить общедоступную строку getName() { вернуть "HelloWorld"; } @ReactMethod публичное приветствие void(имя строки) { Log.i("HelloWorld", "Привет" + имя); } } Здесь довольно много шаблонов! Давайте разберем это по частям. Во-первых, мы начинаем с инструкции пакета: package com.androiddepends; Все файлы source в пакете com.androiddepends должны начинаться с этой строки. Мы используем тот же пакет, что и наш файл MainActivity.java для удобства. Затем мы импортируем кучу файлов, специфичных для React Native, а также android.util.Log. Любой модуль, который вы wзапускаете, должен импортировать те же файлы React Native. Затем мы объявляем наш класс HelloWorld . Он общедоступен, что означает, что внешние файлы могут его использовать; и он расширяет ReactContextBaseJavaModule , что означает, что он наследует методы из ReactContextBaseJavaModule: public class HelloWorld расширяет ReactContextBaseJavaModule { ... } Здесь реализованы три метода: HelloWorld, getName и greeting . В Java метод с тем же именем, что и у класса, называется конструктором. Таким образом, метод HelloWorld является немного шаблонным; мы вызываем конструктор ReactContextBaseJavaModule с вызовом super(reactContext) и больше ничего не делаем. getName определяет, какое имя мы будем использовать позже для доступа к этому модулю из нашего кода JavaScript, поэтому убедитесь, что оно правильное! В этом случае мы назовем его “HelloWorld”. Обратите внимание, что мы добавляем сюда декоратор @Override . Вы захотите реализовать getName для любых других модулей, которые вы пишете. Наконец, приветствие - это наш собственный метод, который мы хотим, чтобы он был доступен в нашем коде JavaScript. Мы добавляем декоратор @ReactMethod, чтобы React Native знал, что этот метод должен быть открыт. Чтобы записать что-либо при вызове приветствия, мы вызываем Log.мне нравится так: Log.i ("HelloWorld", "Hello", + name); Объект Log в Android предоставляет разные уровни ведения журнала. Тремя наиболее часто используемыми являются INFO, WARN и ERROR, которые вызываются с помощью Log.i, Log.w и Log.e соответственно. Каждый из этих методов принимает два параметра: "тег” для вашего журнала и сообщение. Стандартной практикой является использование имени класса для тега. Просмотрите документацию по Android для получения более подробной информации. Нам также необходимо создать файл пакета для упаковки этого модуля (пример 7-9), чтобы мы могли включить его в нашу сборку. Он также должен быть родственным по отношению к HelloWorld.java. Пример 7-9. AndroidDepends/android/app/src/main/java/com/androiddepends/HelloWorldPackage.java пакет com.androiddepends; импорт com.facebook.react.ReactPackage; импортировать com.facebook.react.bridge.JavaScriptМодуль; импортировать com.facebook.react.bridge.NativeModule; импортировать com.facebook.react.bridge.ReactApplicationContext; импортировать com.facebook.react.uimanager.ViewManager; импортировать java.util.ArrayList; импортируйте java.util.Коллекции; импорт java.util.List; открытый класс HelloWorldPackage реализует ReactPackage { @Переопределить открытый список<NativeModule> createNativeModules(ReactApplicationContext reactContext) { Список<NativeModule> модули = новый ArrayList<>(); modules.add(новый HelloWorld(reactContext)); вернуть модули; } открытый список<Класс<? расширяет JavaScriptModule>> createJSModules() { возвращает коллекции.emptyList(); } общедоступный List<ViewManager> createViewManagers(ReactApplicationContext reactContext) { возвращает коллекции.emptyList(); } } Этот файл в основном шаблонный. Нам не нужно импортировать HelloWorld, потому что он является частью того же пакета (com.androiddepends), что и этот файл. Здесь стоит отметитьтри метода: createNativeModules, createJSModules и createViewManagers. React Native использует эти методы для определения того, какие модули он должен экспортировать. В данном случае мы написали только так называемый собственный модуль, поэтому последние два методавозвращают пустой список, в то время как createNativeModules возвращает список, содержащий экземпляр HelloWorld. Напротив, если вы посмотрите на LinearGradientPackage.java (исходный код), вы увидите, что он возвращает экземпляр LinearGradientManager при вызове createViewManagers и пустые списки для двух других методов. Наконец, нам нужно добавить пакет в MainActivity.java, точно так же, как мы сделали с LinearGradient. Импортируйте файл пакета: import com.androiddepends .HelloWorldPackage; Затем добавьте HelloWorldPackage в свой ReactInstanceManager: mReactInstanceManager = ReactInstanceManager.builder() .setApplication(getApplication()) .setBundleAssetName("index.android.bundle") .setJSMainModuleName("index.android") .addPackage(новый MainReactPackage()) .addPackage(новый LinearGradientPackage ()) .addPackage(новый HelloWorldPackage()) // <-- Добавьте эту строку .setUseDeveloperSupport(BuildConfig.DEBUG) .setInitialLifecycleState(Жизненный цикл.ВОЗОБНОВЛЕНО) .build(); Как и в случае с модулями Objective-C, наш Java-модуль будет доступен через React.Объект NativeModules. Теперь мы можем вызвать наш метод greeting() из любого места в нашем приложении следующим образом: React.NativeModules.HelloWorld.приветствие ("Бонни"); Давайте отфильтруем логи и найдем наше сообщение. Запустите следующее из корня вашего проекта: adb logcat | grep HelloWorld Мы ищем экземпляры ”HelloWorld", потому что это тег, который мы использовали в нашем вызове Log.i. На рисунке 7-8 показан результат, который вы должны увидеть в вашей командной строке. Рис. 7-8. Вывод из logcat Теперь, когда мы написали наш пример “Hello, World” дляrom Java, давайте посмотрим на реализацию более сложного примера: react-native-linear-gradient. Android-реализация LinearGradient Android-реализация <LinearGradient> находится в каталоге android/. Он состоит в основном из трех файлов: LinearGradientPackage.java LinearGradientView.java LinearGradientManager.java LinearGradientPackage.java, показанный в примере 7-10, очень похож на наш HelloWorldPackage.java файл. Пример 7-10. LinearGradientPackage.java пакет com.BV.LinearGradient; импортировать com.facebook.react.ReactPackage; импортировать com.facebook.react.bridge.JavaScriptМодуль; импортировать com.facebook.react.bridge.NativeModule; импортировать com.facebook.react.bridge.ReactApplicationContext; импортировать com.facebook.react.uimanager.ViewManager; импортировать java.util.ArrayList; импортировать java.util.Коллекции; импорт java.util.List; открытый класс LinearGradientPackage реализует ReactPackage { @Override открытый список<NativeModule> createNativeModules(ReactApplicationContext reactContext) { возвращает коллекциюns.emptyList(); } открытый список<Класс<? расширяет JavaScriptModule>> createJSModules() { возвращает коллекции.emptyList(); } общедоступный список<ViewManager> createViewManagers(ReactApplicationContext reactContext) { Список<ViewManager> модули = новый ArrayList<>(); модульs.add(новый LinearGradientManager()); возвращает модули; } } Основное отличие заключается в том, что LinearGradientPackage возвращает LinearGradientManager из createViewManagers, в то время как наш HelloWorldPackage вернул HelloWorld из createNativeModules. В чем разница? Для Android любые исходные представления для рендеринга создаются и управляются ViewManager (или, более конкретно, классом, расширяющим ViewManager). Поскольку LinearGradient - это компонент пользовательского интерфейса, нам нужно вернуть ViewManager . Документация React Native по родным компонентам пользовательского интерфейса Android содержит дополнительную информацию о разнице между предоставлением собственного модуля (т. Е. неродового Java-кода) и компонента пользовательского интерфейса. Давайте рассмотрим LinearGradientManager далее. Это относительно длинный файл; вы можете просмотреть полный исходный код в репозитории react-native-linear-gradient на GitHub. Мы рассмотрим сокращенную версию здесь: открытый класс LinearGradientManager расширяет SimpleViewManager<FrameLayout> { ... публичная статическая конечная строка REACT_CLASS = "BVLinearGradient"; публичная статическая конечная строка String PROP_COLORS = "цвета"; публичный LinearGradientView mGradientView; ... @Переопределить общедоступную строку getName() { возвращает REACT_CLASS; } ... @ReactProp(name=PROP_COLORS) public аннулирует UpdateColors(FrameLayout frame, ReadableArray colors){ if(mGradientView != null) { mGradientView.UpdateColors(цвета); } } ... @Переопределить public void UpdateView(FrameLayout frame, CatalystStylesDiffMap props) { BaseViewPropertyApplicator.applycommon viewproperties(frame, props); frame.removeAllViews(); mGradientView = новый линейныйпросмотр (frame.getContext(), props); mGradientView.setId(View.generateViewId()); frame.addView(mGradientView); } } Существует несколько здесь нам следует обратить внимание на некоторые вещи. Первый - это реализация getName . Обратите внимание, что, как и в нашем примере с HelloWorld, нам нужно реализовать getName, чтобы иметь возможность ссылаться на этот компонент из нашего кода JavaScript! Следующим является метод UpdateColors и использование декоратора @ReactProp. Здесь мы объявляем, что компонент <LinearGradient> примет параметр с именем colors (поскольку это значение PROP_COLORS) , и UpdateColors будет вызываться при изменении этого параметра. В UpdateColors мы проверяем, существует ли базовый вид; если это так, мы передаем цвета вместе, чтобы его можно было обновить. Наконец, в UpdateView Lineargradientmanager обрабатывает фактическое обновление представления, удаляя все существующие представления из фрейма, а затем добавляя в фрейм новый экземпляр LinearGradientView.Чтобы эффективно писать собственные компоненты Android, вам потребуется понимание того, как Android обрабатывает представления в целом, но для начала стоит изучить другие компоненты React Native. Кроссплатформенные нативные модули Возможно ли написать кроссплатформенный нативный модуль? Ответ “да”; вам просто нужно реализовать свой модуль отдельно для каждой платформы и предоставить единый интерфейс JavaScript. Это может быть хорошим способом оптимизации для конкретной платформы при максимальном повторном использовании кода. Компонент <LinearGradient> является хорошим примером этого. Наш проект androiddependtsct на самом деле кроссплатформенный, потому что <LinearGradient> выполняет кроссплатформенный рендеринг (хотя и с некоторыми стилевыми отличиями); см. Рисунок 7-9. Рисунок 7-9. Компонент <Gradient> на Android (слева) и iOS (справа) Создание кроссплатформенного нативного модуля довольно просто и не требует особых дополнительных настроек. После того, как вы внедрили версии для iOS и Android отдельно, просто создайте папку, содержащую файлы index.ios.js и index.android.js. Для каждой версии должен требоваться соответствующий встроенный модуль. Затем вы можете запросить эту папку, и React Native подберет версию, соответствующую платформе. Например, папка react-native-linear-gradient/ (в нашем каталоге node_modules/, поскольку мы установили ее через npm) содержит элементы index.ios.js и index.android.js f. React Native подберет для нас подходящий файл — нам просто нужно запросить react-native-linear- gradient / папку следующим образом: var LinearGradient = require('react-native-linear-gradient'); В текущем виде React Native не будет применять consciousstent API между версиями iOS и Android, так что ответственность ложится на вас. Если вы хотите, чтобы версии iOS и Android имели немного разные API, это тоже нормально! Итак, когда уместно использовать собственный код Objective-C или Java? Когда стоит ли включать сторонние модули и библиотеки? В общем, существует три основных варианта использования нативных модулей: использование преимуществ существующего кода Objective-C или Java; написание высокопроизводительного многопоточного кода для таких задач, как обработка графики; и предоставление API, еще не включенных в React Native. Для любых существующих мобильных проектов, созданных на Objective-C или Java, написание собственного модуля может стать отличным способом повторного использования существующего кода в приложениях React Native. Хотя гибридные приложения выходят за рамки этой книги, они, безусловно, представляют собой осуществимый подход, и вы можете использовать собственные модули для совместного использования функциональности между JavaScript, Objective-C и Java. Аналогично, для случаев использования, где производительность критична, или для специализированных задач, часто имеет смысл работать на родном языке платформы, для которой вы разрабатываете. В этих случаях часто имеет смысл выполнить тяжелую работу на Objective-C или Java, а затем передать результат обратно в ваше JavaScript-приложение. Наконец,неизбежно возникнут платформенные API, которые вы захотите использовать, но которые еще не поддерживаются React Native. React Native находится в активной разработке, и поддержка любой данной платформы почти наверняка всегда будет неполной. В этих случаях у вас есть два варианта. Первый - обратиться к сообществу и надеяться, что кто-то другой уже решил вашу проблему. Альтернатива - решить проблему самостоятельно и, надеюсь, поделиться своим решением с сообществом! Возможность писать свои собственные нативные модули означает, что вашемуподразделению не нужно полагаться на React Native core, чтобы использовать преимущества вашей хост-платформы. Даже если вы никогда раньше не занимались разработкой для iOS или Android, если вы планируете разрабатывать с React Native, хорошей идеей будет попытаться получить начальные знания Objective-C и / или Java. На случай, если вы наткнетесь на стену при работе с React Native, возможность попробовать обойти ее по-своему - действительно бесценный актив, а собственные модули на самом деле довольно доступны. Не бойтесь пробовать! React Native сообщество, а также более широкая экосистема JavaScript станут ценным активом при разработке собственных приложений React Native. Опирайтесь на работу других и обращайтесь, если вам понадобится помощь! Глава 8. Средства отладки и разработчика По мере разработки вашего потокаприложений есть вероятность, что на этом пути что-то пойдет не так. Когда придет время отлаживать ваши приложения, у нас, к счастью, есть несколько специфичных для React Native инструментов, которые облегчат эту работу. Также есть несколько неприятных ошибок, которые могут возникнуть в разделе "Взаимодействие"React Native и его хост-платформы, на которые мы тоже обратим внимание. В этой главе мы рассмотрим распространенные ошибки разработки на основе React Native и инструменты, которые вы можете использовать для их устранения. И поскольку любое обсуждение отладки было бы несложнымбез ссылки на тестирование, мы также рассмотрим основы настройки автоматического тестирования для вашего React Native кода. Методы отладки JavaScript, переведенные При работе с React для Интернета у нас есть ряд распространенных инструментов на основе JavaScript,а также методов, помогающих нам отлаживать наши приложения. Большинство из них также доступны для React Native, хотя иногда и с некоторыми незначительными изменениями. React Native предоставляет нам доступ к консоли, отладчику и инструментам разработчика React, к которым мы привыкли использовать, поэтому отладка проблем на основе JavaScript в React Native должна казаться знакомой. Активация параметров разработчика Чтобы воспользоваться этими инструментами, вам необходимо включить Chrome Developer Tools во встроенном меню разработчика приложений (рис. 8-1). К этому меню cможно получить доступ, нажав Command + Control + Z в симуляторе iOS, нажав аппаратную кнопку на Android или встряхнув устройство. Оттуда вы можете выбрать "Отладка в Chrome", чтобы включить инструменты разработчика Chrome. Рисунок 8-1. Встроенное меню разработчика приложений, aпросматривается с Android (слева) и iOS (справа) Отладка с помощью консоли.регистрация Одной из самых основных и распространенных форм отладки является тактика “распечатай это и посмотри, что происходит”. Для многих веб-разработчиков возможность добавления консоли.вход в наш код - это почти бессознательная часть нашего рабочего процесса. Консоль JavaScript работает прямо из коробки с React Native; вам не нужно выполнять какую-либо специальную настройку, чтобы использовать ваши операторы печати. При использовании Xcode вы увидите свои консольные инструкциив качестве выходных данных в консоли Xcode (рис. 8-2). Обратите внимание, что вы можете увеличить количество места, отведенного консоли, изменив видимые панели Xcode. Рисунок 8-2. Вывод на консоль, как показано в Xcode Аналогично, для Android вы можете просматривать журналы для вашего device, запустив logcat из корня вашего проекта (на рисунке 8-3 показан вывод): adb logcat Рисунок 8-3. Вывод консоли отображается с тегом “ReactNativeJS” в logcat, однако эти представления довольно загромождены, а также включают ведение журнала, связанного сспецифичными для платформы вещами. Вместо этого мы можем перейти к инструментам разработчика на основе браузера. Активируйте меню разработчика и выберите "Отладка" в Chrome, а затем откройте консоль. Как показано на рисунке 8-4, вы сможете увидеть вывод консоли из инструментов разработчика Chrome . Рисунок 8-4. Вывод на консоль, как показано в Chrome Обратите внимание, что вам нужно открыть консоль, прежде чем вы увидите, что здесь все отображается. Как это работает? Когда вы загружаете свое приложение React Native с включенной отладкой Chrome, Google Chrome загружает ваш собственный JavaScript-код React из упаковщика React Native, используя стандартный тег <script>, так что у вас есть полный контроль отладки на основе браузера. Затем упаковщик использует WebSockets для передачи команд между устройством и браузером. Нам не нужно слишком беспокоиться о специфике; нам просто нужно знать, как воспользоваться преимуществами этих инструментов! Использование отладчика JavaScript Вы также можете использовать отладчик JavaScript, как обычно для веб-разработки React. Откройте инструменты разработчика в Chrome, перейдите на вкладку “Исходный код”, и тогда будут активированы ваши контрольные точки. Вы можете увидеть это в действии на рисунке 8-5. Обратите внимание, что, как и в консоли JavaScript, если у вас еще не открыта панель инструментов разработчика, отладчик может быть не активирован в ваших точках останова. Аналогично, если у вас не включена функция отладки в Chrome, отладчик не будет активирован. Рисунок 8-5. Использование отладчика При использовании отладчика у вас есть доступ к обычному просмотру вашего исходного кода из Chrome, и вы также можете взаимодействовать с текущим контекстом JavaScript через встроенную консоль браузера. Работа с инструментами разработчика React При разработке с помощью React для Интернета инструменты разработчика React весьма полезны. Они позволяют вам проверять иерархию компонентов,определять реквизиты и состояние компонентов, а также изменять состояние в вашем браузере. Инструменты разработчика React доступны в виде расширения для Chrome. Инструменты разработчика React также работают с React Native, хотя опыт работы с ними несколько иной. После работы синструментами разработчика вам нужно будет кратко взаимодействовать с вашим приложением, чтобы подключить мост (должно быть достаточно простого касания экрана); смотрите Рисунки 8-6 и 8-7. Рисунок 8-6. Вид перед подключением инструментов разработчика (вам нужно нажать на экран) Рисунок 8-7. Просмотр компонентов и свойств с помощью инструментов разработчика React В React Native для этих инструментов существуют некоторые ограничения. Инструменты разработчика для Native находятся в стадии разработки, поэтому не все функции полностью реализованы. Возможность редактировать стили из инспектора, например, все еще несколько нестабильна. Еще одна вещь, на которую следует обратить внимание, - это отсутствие имени отображения во многих компонентах. С React для Интернета вы обычно можете неявно задать имя_дисПлея компонента,например, так: импортируйте React из 'react'; переменное имя_компонента = React.createClass({ ... }); экспортируйте имя компонента по умолчанию; Если вы определяете свои компоненты таким образом, то вы обнаружите, что они названы правильно, когда вы также проверите их с помощью React Developerls. Поскольку это не работает с React Native , вам следует вместо этого явно задать DisplayName: импортировать React из 'react-native'; var ComponentName = React.createClass({ DisplayName: 'ИмякомпонЕнта' ... }); экспортируйте имя компонента по умолчанию; Как только вы сделаете это, инструменты разработчика React смогут проанализировать вашу иерархию компонентов с помощью четко обозначенных компонентов, как обычно. Инструменты отладки React Native В дополнение к обычным веб-инструментам отладки на основе JavaScript, существуют также некоторые функции, специфичные для React Native, которые имеют отношение к отладке. Использование Inspect Element Хотя вы можете использовать инструменты разработчика React через браузер, вы можете обнаружить, что функциональность "inspect element” оставляет желать лучшего. Также в приложении есть “элемент проверки”, который выможете счесть полезным. Он поддерживает просмотр таких вещей, как стиль, и предоставляет вам быстрый способ изучить иерархию компонентов. На рисунке 8-8 вы можете увидеть результат проверки компонента button. Рисунок 8-8. Использование элемента Inspect позволит вам нажатьk на компоненте, чтобы просмотреть дополнительную информацию. В этом представлении также отображаются некоторые основные показатели производительности. Красный экран смерти Одно из самых распространенных зрелищ, которые вы увидите во время разработки приложения, - это Красный экран смерти. Несмотря на тревожный внешний вид, красный экран смерти на самом деле является благом: он принимает ошибки и преобразует их в значимые сообщения. Таким образом, умение анализировать информацию, которую он отображает, имеет решающее значение для эффективного рабочего процесса разработчика. Например, синтаксическая ошибка может привести к выводу, показанному на рисунке 8-9, с указанием файла и номера строки, в которых произошла ошибка. Рисунок 8-9. Красный экран смерти из-за синтаксической ошибки Другие распространенные ошибки включают попытку использовать переменную без ее импорта или определения. Например, распространенной проблемой является то, что не удается явно импортировать компонент <Text>, например так: импортируйте React из 'react-native'; экспортируйте React.createClass по умолчанию({ render() { return ( <View> <Text> Я не запрашивал все должным образом! </Text> </View> ); } }) В результате появляется сообщение об ошибке, показанное на рисунке 8-10: shown: Рисунок 8-10. Сообщение об ошибке из-за того, что забыли импортировать текст, попытка использовать необъявленную переменную приводит к появлению другого сообщения об ошибке (см. Рис. 8-11). Рис. 8-11. Сообщение об ошибке при попытке использовать необъявленную переменную конкретного использованияar - это сообщения об ошибках, связанные со стилем. Например, если вы передадите неверное значение в вызов StyleSheet.create , React Native услужливо сообщит вам, какие значения были бы подходящими (см. Рисунок 8-12). Рисунок 8-12. Сообщение об ошибке при неправильной настройке свойства стиля Хотя красный экран смерти может выглядеть тревожно, он действительно готов вам помочь, и сообщения об ошибках, которые он представляет, являются полезной информацией. Если по какой-либо причине вам нужно закрыть экран, нажатие клавиши Escape в симуляторе устройства вернет вас к вашему приложению. Отладка за пределами JavaScript При написании мобильных приложений с помощью React Native вы будете сталкиваться с ошибками не только в вашем коде React, но и в вашем приложении в целом. Если вы новичок в разработке мобильных устройств, тоэти проблемы могут вызвать разочарование. Кроме того, иногда вы увидите загадочные сообщения об ошибках и проблемы, связанные с тем, что ваша кодовая база JavaScript соответствует платформе хоста; сочетание кода платформы хоста и React Native может привести к запутанным симптомам. Умение решатьпроблемы ebug за пределами чисто JavaScript-задач имеет решающее значение для продуктивного процесса разработки с React Native. К счастью, многие из этих проблем проще, чем могут показаться на первый взгляд, и у нас есть множество инструментов, которые помогут нам на этом пути. CПроблемы среды разработки ommon React Native развивается быстро, а это значит, что управление средой разработчика может быть немного утомительным. Если вы столкнулись с проблемами при запуске упаковщика или при сборке или запуске вашего приложения с использованием npm start или react-native run-android, возможно, у вас проблема с зависимостями. Как всегда, если вы используете brew для управления своими зависимостями, рекомендуется поддерживать brew в актуальном состоянии: brew update brew upgrade При обновлении React Native рекомендуется выполнить эти команды brew, а затем также обновить установку вашего узла: brew upgrade node Кроме того, вы можете запустить brew doctor для проверки проблем с установленными пакетами. Если у вас возникли проблемы с зависимостями, другое распространенное решение - просто очистить установленные пакеты npm и переустановить их: rm -rf node_modules Установка npm Распространенные проблемы с Xcode При сборке приложения iOS, если в вашем приложении есть какие-либо ошибки, они появятся на панели проблем в Xcode (рисунок 8-13). Вы можете просмотреть их, выбрав значок предупреждения. Рисунок 8-13. При просмотре панели проблем Xcode укажет вам на соответствующий файл и номер строки, а также выделит проблему в IDE. На рисунке 8-14 показан пример распространенной ошибки. Рисунок 8-14. Ошибка интерфейса Эта проблема “Нет vдоступного интерфейса для RCTRootView” указывает на то, что классы Objective-C React Native по какой-то причине не видны Xcode. В общем, если вы сталкиваетесь с сообщениями об ошибках “X не определено” в Xcode, где X - класс с префиксом RCT или иным образом часть React Native, рекомендуется проверить упаковщик и убедиться, что ваши зависимости JavaScript в порядке: 1. Закройте упаковщик 2. Закройте Xcode 3. Запустите npm install из каталога проекта 4. Повторно откройте Xcode Другая распространенная проблема связана сзаданными размерами (см. Рисунок 8-15). Рисунок 8-15. Предупреждение о неправильном размере изображения Поскольку ресурсы должны иметь соответствующий размер для устройства, для которого они предназначены (особенно значок вашего приложения), Xcode выдаст предупреждение, если вы добавите ресурс неподходящего размера.Расшифровка предупреждений Xcode поначалу может занять некоторое время, особенно если вы не знакомы с Objective-C. Некоторые из наиболее запутанных проблем связаны с интеграцией React Native и вашего проекта Xcode, но чистая установка React Native обычно устраняет любые проблемы. Распространенные проблемы Android При запуске react-native run-android могут появляться некоторые сообщения об ошибках, препятствующие загрузке вашего приложения. Двумя наиболее распространенными проблемами обычно являются отсутствие зависимостей Android, или сбой при загрузке виртуального устройства Android (или подключении соответствующего устройства через USB). Если вы получаете предупреждение об отсутствии пакета, запустите Android и проверьте, указан ли этот пакет как “установленный”. Если нет, установите его. Если он установлен, но React Native не может его найти, выполните описанные выше действия, чтобы попытаться устранить любые проблемы с вашей средой разработки. Вам также следует убедиться, что ваша переменная окружения ANDROID_HOME установлена правильно и указывает на вашу установку Android SDK. Например, в моей системе: $ echo $ ANDROID_HOME / usr / local / opt / android-sdk Если вы получаете предупреждение о том, что ни одно подходящее устройство не доступно в качестве цели сборки, проверьте свое устройство. Вы пытались запустить эмулятор? Если нет, запустите Android avd и запустите соответствующий эмулятор. Если эмулятор все еще загружается, команда react-native run-android завершится ошибкой; подождите несколько секунд и попробуйте снова. Если вы используете физическое устройство, убедитесь, что включена отладка по USB. Вы также можете столкнуться с проблемами после созданияподписанной версии вашего приложения для Android, о чем мы расскажем в главе 11: $./ gradlew installRelease… INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES: Новый пакет имеет другую подпись. Это можно решить, удалив старое приложение из вашего device или эмулятора и повторно запустив установку. Ошибка вызвана попыткой установить приложение с другим ключом подписи, что, конечно же, происходит после создания вашего первого подписанного APK-файла. Упаковщик React Native Поскольку React Native,используемый для перестройки вашего кода, использует упаковщик для того, чтобы перестроить ваш код, проблемы с упаковщиком проявятся в виде проблем довольно быстро. Упаковщик React Native запустится автоматически при запуске вашего проекта либо из Xcode, либо с помощью react-native run-android. Какбы то ни было, он не завершится автоматически, когда вы закроете свой проект. Это означает, что если вы переключите проекты, упаковщик все равно будет запущен - просто из неправильного каталога, поэтому ему не удастся скомпилировать ваш код. Всегда следите за тем, чтобы упаковщик был запущенg из корневого каталога вашего проекта. Вы можете запустить его самостоятельно с помощью npm start . Если упаковщик React Native выдает странные ошибки при запуске, велика вероятность того, что ваша среда разработки находится в плохом состоянии. Следуя только что описанным шагам,убедитесь, что все ваши локальные установки npm, node и react-native находятся в хорошем состоянии. Проблемы при развертывании на устройстве iOS При попытке протестировать ваше приложение на реальном устройстве iOS вы можете столкнуться с некоторыми специфическими проблемами. Если у вас возникли проблемы с загрузкой на ваше устройство iOS, первое, что вам следует сделать, это проверить, в порядке ли ваша учетная запись разработчика Apple. Перейдите в iTunes Connect, чтобы проверить и принять все незавершенные соглашения. Без учетной записи разработчика Apple вы не сможете выполнить развертывание на устройстве. Затем убедитесь, что ваше устройство выбрано правильно в качестве целевого объекта сборки. Поддерживается ли тип вашего устройства в соответствии с настройками вашего проекта? Например, если ваше приложение явно запрещает использование iPad, вы не сможете выполнить развертывание на iPad. Если вы используете React Packager для восстановления файлов по мере внесения изменений, вы можете увидеть экран, показанный на рисунке 8-16. Рисунок 8-16. Не удалось подключиться к серверу разработки Это указывает на то, что ваше приложение попыталось загрузить свой связанный файл JavaScriptиз React Native packager, но не смогло этого сделать. В этом случае выполните следующие проверки: Используете ли вы опцию packager в AppDelegate.m? Правильный ли ваш IP-адрес в AppDelegate.m? Подключены ли ваш компьютер и устройство iOS к одному и тому же Wi-Fi черезtwork? Запускается ли упаковщик React Native из каталога project? Можете ли вы получить доступ к нему http://your.ip.address:8081/index.ios.bundle из браузера вашего компьютера? Можете ли вы получить доступ к той же странице из браузера вашего устройства iOS? Если вы используете предварительно созданный пакетфайлов, вы можете столкнуться с отдельной проблемой, когда команда react-native bundle по умолчанию --minify помещает ваш пакет в неправильное расположение. Это легко исправить, переместив файл main.jsbundle по соответствующему пути на основе сообщения об ошибке.Поведение симулятора Время от времени вы также можете видеть странное поведение в симуляторе устройства. Если ваше приложение продолжает постоянно аварийно завершать работу или кажется, что изменения в вашем коде не отражаются в симуляторе, самый простой первый шаг - удалитьваше приложение с устройства. Обратите внимание, что простое удаление вашего приложения может не дать желаемого эффекта; во многих системах ваше приложение может оставить после себя файлы, которые впоследствии могут вызвать побочные эффекты. Как показано на рисунке 8-17, самый простой способ начать все с чистого листа - это полностью перезагрузить симулятор устройства, что приведет к удалению всех файлов и приложений с моделируемого устройства. Рисунок 8-17. Содержимое и настройки сброса… опция удалит все с вашего устройства, протестировав ваш код Debuс настройкой все в порядке, но вы также захотите предотвращать ошибки до того, как они возникнут (и отлавливать их, когда они неизбежно возникнут!). Автоматические тесты и статическая проверка типов - полезные инструменты, которые вы, вероятно, захотите использовать в своих приложениях. ТЕСТИРОВАНИЕКОДА JAVASCRIPT Большая часть созданного вами кода React Native может даже не осознавать, что он выполняется в мобильной среде. Например, любая бизнес-логика, вероятно, может быть изолирована от логики рендеринга. Это означает, что вы можете протестировать свой JavaScript-код с помощью любые инструменты, которые вы предпочитаете для обычной разработки на JavaScript. Вау! В этом разделе мы собираемся конкретно рассмотреть проверку типов с помощью Flow и модульное тестирование с помощью Jest. Проверка типов с помощью Flow Flow - это библиотека JavaScript для статической проверки типов. It полагается на вывод типов для обнаружения ошибок типов даже в неназванном коде и позволяет медленно добавлять аннотации типов в существующие проекты. Проверка типов может помочь вам обнаружить возможные проблемы на ранней стадии и внедрить разумные API-интерфейсы между различнымикомпонентами и модулями. Запустить Flow просто: $ проверка flow Приложение по умолчанию поставляется с файлом .flowconfig, который настраивает поведение Flow. Если вы видите много ошибок, связанных с файлами в node_modules, возможно, вам потребуется добавить эту строку в ваш файл .flowconfig в разделе [игнорировать]: .*/node_modules/.* После этого вы сможете запускать flow check, не видя никаких ошибок: $ flow check $ Найдено 0 ошибок. Не стесняйтесь использовать Flow, чтобы помочь вам при разработке приложений React Native. Тестирование с помощью Jest React Native поддерживает тестированиекомпонентов React с использованием Jest. Jest - это фреймворк модульного тестирования, построенный поверх Jasmine. Он обеспечивает агрессивную автоматическую проверку зависимостей и прекрасно сочетается с утилитами тестирования React. Чтобы использовать Jest, вам сначала нужно будет установить его: npm install jest-cli --save-dev Обновите ваш файл package.json, включив в него тестовый скрипт: { ... "scripts": { "test": "jest" } ... } При вводе npm test будет выполняться jest. Затем создайте каталог tests/ . Jest будет рекурсивно искать файлы в каталоге tests / directoи запускать их: mkdir __tests__ Теперь давайте создадим новый файл, tests/dummy-test.js , и напишем наш первый тест: 'use strict'; describe('глупый тест', function() { it('ожидает, что true будет true', function() { expect(true).toBe(true); }); }); Теперь, если вы запустите npm тест, вы должны увидеть, что тест пройден. Конечно, для тестирования требуется гораздо больше, чем этот тривиальный пример. Лучшие ссылки можно найти в приложении sample Movies в репозитории React Native. Например, вот сокращенная версия файла test для getImageSource в приложении Movies example (код доступен полностью на GitHub): jest.dontMock('../getImageSource'); var getImageSource = require('../getImageSource'); describe('getImageSource', () => { it('возвращает null для вдопустимых входных данных', () => { expect(getImageSource().uri ).toBe(null); }); ... }); Обратите внимание, что вам нужно явно запретить Jest подделывать файлы, а затем требовать ваши зависимости впоследствии. Если вы хотите узнать больше о Jest, я рекомендую начать с документации d. Когда вы оказываетесь в тупике, Если в итоге сталкиваетесь с особенно неприятной проблемой, которую не можете решить самостоятельно, вы можете попробовать проконсультироваться с сообществом. Есть много мест, куда можно обратиться за советом: IRC-чат #reactnative (irc://чат.freenode.net/reactnative) Дискуссионный форум React StackOverflow Если вы подозреваете, что ваша проблема может быть ошибкой в самом React Native, проверьте существующий список проблем на GitHub. При сообщении о проблемах полезно создать небольшое приложение для проверки концепции, демонстрирующее проблему. Краткое описание В целом, отладка с помощью React Native должна быть очень похожа на отладку вашего кода React в Интернете. Большинство инструментов, с которыми вы будете знакомы, доступны и здесь, что значительно упрощает переход на React Native. Это, как говорится, приложения React Native имеют свою собственную сложность, и иногда эта сложность может проявляться в досадных ошибках. Знание того, как отлаживать ваши приложения, и сообщений об ошибках, создаваемых вашей средой, во многом поможет вам наладить продуктивный рабочий процесс. Глава 9. Сведение всего воедино Теперь, когда мы рассмотрели многие элементы, которые вам понадобятся для создания ваших собственных приложений React Native, давайте сведем все воедино. До сих пор мы в основном имели дело с маленькимипримерами. В этой главе мы рассмотрим структуру более крупного приложения. Мы рассмотрим использование Reflux, библиотеки для однонаправленного потока данных, основанной на модели Flux. Мы также увидим, как мы можем использовать Dimensions API для масштабирования текста в соответствии с различнымиразмерами экрана. Наконец, мы закончим с некоторыми домашними заданиями: задачами, которые вы можете выполнить, чтобы увидеть, каково это - создавать дополнительные функции в существующей базе кода React Native. Приложение для флэш-карт Zebreto - это приложение для флэш-карт, основанное на системе повторения пробеловd (SRS), стратегии обучения для эффективного запоминания. Цель SRS состоит в том, чтобы просмотреть информацию непосредственно перед тем, как вы в противном случае забудете ее. Если вы изучаете какой-либо иностранный язык, вы, возможно, знакомы с системами SRS; они позволяют вам быстрее запоминать большие объемы данных, ориентируясь на долгосрочное хранение. Общепринятый подход заключается в том, чтобы начинать с небольшого интервала между проверками, например, с часа, и постепенно увеличивать его по мере корректности карточек: сначала час, затем день, затем три дня, затем неделя. Интервалы могут постепенно увеличиваться до года или пяти лет. Отслеживать эти интервалы непрактично с помощью карточек с карандашом и бумагой, поэтому вместо этого мы создадим приложение. Zebreto немного сложнее, чем примеры приложений, которые мы до сих пор создавали. Он предназначен для моделирования того, как могло бы выглядеть более развернутое приложение. Весь код доступен на GitHub. Он также полностью кроссплатформенный; приложение должно работать на Android так же, как и на iOS. Как показано на рисунке 9-1, приложение Zebreto имеет три основных вида: Домашняя страница, на которой перечислены доступные колоды и которая позволяет создавать новые колоды Экран создания карт Экран просмотра Рисунок 9-1. Просмотр колод, создание карт и просмотр карт Пользователи приложения проходят через два основных потока взаимодействия. Первый связан с созданием контента (т.е. созданием колод, а также карт). Процесс создания контента работает следующим образом (проиллюстрирован на рисунке 9-2): 1. Пользователь нажимает Создать колоду. 2. Пользователь вводит название колоды, затем либо нажимает кнопку Возврата, либо снова создает колоду. 3. Пользователь вводит значения для лицевой и оборотной сторон, а затем нажимает Создать карту. 4. После ввода нуля или более карточек пользователь может нажать “Готово”, вернув их на исходный экран. В качестве альтернативы пользователь может нажать Просмотреть Deck и начать просмотр. Рисунок 9-2. Создание колоды карт Создание колоды карт также можно запустить позже, нажав кнопки + на главном экране. Второй основной процесс взаимодействия связан с просмотром карт (проиллюстрирован на рис. 9-3): 1. Пользователь нажимает на название колоды, которую он хочет просмотреть. 2. Пользователю отображается экран вопроса. 3. Пользователь нажимает на один из предоставленных вариантов. 4. Пользователь получает обратную связь, основанную на том, была ли его догадка правильной. 5. Чтобы просмотреть следующий отзыв, пользователь нажимает "Продолжить"e. 6. После завершения всех отзывов пользователь переходит к экрану “Отзывы удалены!”. Рисунок 9-3. Просмотр карт Если пользователь правильно выбирает карту, мы должны увеличить силу карты и, следовательно, интервал до ее следующего просмотра. Аналогично, для каждой некорректной карты нам нужно будет снизить уровень надежности карты и запланировать ее повторную проверку в ближайшее время. Мы будем использовать приложение Zebreto и, в частности, описанные выше функции, чтобы обсудить некоторые закономерности и проблемы, возникающие при созданииболее полного приложения. Структура проекта Вот сокращенная структура проекта: Zebreto |- .babelrc |- iOS |- index.ios.js |- node_modules |- package.json |- src |- actions.js |- components |- data |- stores |- styles В папке Zebreto наш проект свободно разделен между папками проектов, специфичными для iOS и Android, и каталогом src/. Каталог src/ содержит весь наш код React для проекта. Также обратите внимание, что существует файл .babelrc, который изменяет nfiguration по умолчанию для Babel co. Если вы добавите файл .babelrc в корневой каталог проекта React Native, программа-упаковщик React Native автоматически подберет его. В данном случае наиболее значительным изменением является то, что я включил синтаксис модуля ES6: // .babelrc { "stage": 1, "optional": ["runtime"], "loose": "all", "whitelist": [ "es6.modules" ] } По большей части мы будем работать в каталоге src/. В каталоге src/ наш код упорядочен дополнительно на основе функциональности: компоненты/ Все наши компоненты React находятся здесь данные/ Здесь вы найдете наши хранилища моделей данных / Наши хранилища данных Reflux, о которых мы скоро поговорим в прямом эфире actions.js Действия с возвратом, которые мы обсудим вместе с хранилищами данных, стили live here / Здесь вы найдете объекты таблицы стилей, которые повторно используются в других местах Иерархия компонентов Есть три основных сцены, которые могут отображаться в любой момент времени. Чтобы дать вам представление об общей структуре приложения, давайте изобразим деревья компонентов для каждого из трех сценариев. Сначала мы создаем колоду на главном экране колоды. На этом экране будет отображено столько колод, сколько в данный момент существует в приложении, как показано на рисунке 9-4. Иерархия компонентов показана на рисунке 9-5. Рисунок 9-4. Создание колоды из основной колоды scсм. рисунок 9-5. Дерево компонентов для создания колоды Далее у нас есть экран создания карты (см. Рисунок 9-6). Рисунок 9-6. Экран создания карты Иерархия компонентов для этого экрана показана на схеме на рисунке 9-7. Рисунок 9-7. Дерево компонентов для создания deck И, наконец, у нас есть экран обзора, который показан на рисунке 9-8. Обратите внимание, что дочерний компонент <Review> будет меняться в зависимости от того, где вы находитесь в процессе проверки. После того, как пользователь завершит все доступные проверки, <Карточка просмотра> будет замененаинформацией о результатах работы пользователя. Рисунок 9-8. Экран просмотра карты Иерархия компонентов для экрана просмотра карты представлена на рисунке 9-9. Рисунок 9-9. Дерево компонентов для создания колоды Как упоминалось ранее, когда вы создаете более крупные aдополнения, полезно иметь несколько стилизованных компонентов, которые вы можете использовать снова и снова. В результате большинство компонентов на самом деле не используют <Text> для отображения текста: вместо этого они используют <HeadingText> и <NormalText>. Аналогично, компонентnt <Button> часто используется повторно. Это улучшает читаемость кода и упрощает создание новых компонентов. Это должно дать вам представление об общей структуре приложения Zebreto. Обратите внимание, что мы все еще не обсудили, как обрабатываются взаимодействия с пользователем, or как мы обрабатываем модификацию и сохранение данных. Теперь давайте взглянем на наши модели данных. Моделирование и хранение данных Теперь, когда мы немного узнали о том, как Zebreto обрабатывает рендеринг, как он обрабатывает данные? Какие данные нам нужно отслеживать и как мы это делаем? Zebreto использует две основные модели: карты и колоды. Колода состоит из понятного человеку имени и уникального идентификатора. Мы также иногда храним некоторые метаданные о картах, которые она содержит: Deck: { name, id, totalCards, // вычислено, может быть ouустаревшими dueCards // вычислено, может быть устаревшими } Карты имеют лицевую и оборотную стороны (например, “der Hund” и “the dog”) и принадлежат колоде. У них также есть сила, представленная в виде целого числа, и срок выполнения. Использование Zebreto moment.js для объектов date: Card: { front, back, deckID, strength, DueDate, id } Колоды и карты могут быть представлены как простые объекты JavaScript, но для удобства Zebreto использует некоторые классы-оболочки. Если вы заглянете в каталог src/data/, вы найдете наши классы моделей. Вот класс для колоды: // src/data/Deck.js импортируйте md5 из 'md5'; class Deck { конструктор(имя) { this.name = name; this.totalCards = 0; this.dueCards = 0; this.id = md5(имя); } setFromObject(ob) { this.name = ob.name; this.totalCards = ob.totalCards; this.dueCards = ob.dueCards; this.id = ob.id; } resetCounts() { this.totalCards = 0; this.dueCards = 0; } статический fromObject(ob) { пусть d = новая колода(ob.name ); d.setFromObject(ob); return d; } } module.exports = Deck; Как вы можете видеть, класс Deck является qочень простым. Его конструктор принимает необходимые параметры, которые отличают Колоду, а затем устанавливает разумные значения по умолчанию для других полей. Это также предоставляет нам удобные методы для создания колоды из объекта JavaScript и простой способ сбросить метаданные, хранящиеся в колоде. На данный момент так называемые уникальные идентификаторы создаются путем использования MD5-хэша соответствующей информации. Класс Card выглядит довольно похоже и предоставляет нам вспомогательные методы для создания Card из обычного объекта: // src/data/Card.js импортируйте md5 из 'md5'; импортируйте moment из 'moment'; class Card { конструктор (передний, задний, deckID) { this.front = передняя часть; это.назад = back; this.deckID = deckID; this.strength = 0; this.DueDate = момент(); this.id = md5(спереди + сзади + deckID); } setFromObject(ob) { this.front = ob.front; это.назад = ob.back; this.deckID = ob.deckID; this.strength = ob.strength; this.DueDate = момент (ob.DueDate); this.id = ob.id ; } static fromObject(ob) { пусть c = new Card(ob.front, ob.back, ob.deckID); c.setFromObject(ob); return c; } } module.exports = Card; Чтобы понять, как эти модели используются в приложении, давайте посмотрим на нашу архитектуру потока данных. Архитектура потока данных: Reflux и Flux Zebreto использует Reflux для своей архитектуры потока данных, которая основана на схеме потока. Предыдущие примеры, которые мы рассмотрели в этой книге, не требовали многого в плане управления потоками данных. В небольших приложениях обмен данными между компонентами обычно является тривиальной проблемой. Рассмотрим случай, когда нажатие кнопки оказываетn влияние на состояние родительского элемента: // Child.js импортируйте React из 'react-native'; var {Text, TouchableOpacity} = React; экспортируйте React.createClass по умолчанию({ render() { <TouchableOpacity onPress={this.props.onPress}> <Text>Дочерний компонент</Text> </TouchableOpacity> } }); Передавая обратный вызов от родительского компонента дочернему, родительский компонент может быть предупрежден о взаимодействии с дочерним компонентом: // Parent.js импортировать React из 'react-native'; импортировать дочерний элемент из './Child'; экспортировать React.createClass по умолчанию({ getInitialState() { return { numTaps: 0 } }, _handlePress() { this.setState({numTaps: this.state.numTaps + 1}); }, render() { <Дочерний элемент onPress={this._handlePress}/> } }); Для простых случаев использования этот шаблон работает просто отлично. Наша потребность в более надежной архитектуре потока данных становится очевидной, когда мы рассматриваем более сложное взаимодействие. Что происходит, когда компоненту, расположенному намного ниже по дереву компонентов, необходимо повлиять на состояние приложения, расположенного на более высоком уровне? Давайте снова посмотрим на экран обзора (рис. 9-10). Рис. 9-10. Просмотркарточек wing При выборе одного из ответов должны произойти следующие вещи: 1. Приложение предоставляет визуальную обратную связь, указывающую, были ли вы правы или нет 2. Доступен следующий обзор 3. Значение силы карты обновляется, если это необходимо 4.Количество доступных отзывов о колоде обновляется, при необходимости, если бы вы вышли из приложения Zebreto в середине отзыва, вы бы хотели, чтобы ваша информация сохранялась, поэтому все эти изменения состояния должны происходить каждый раз, когда вы выбираете отзыв. Давайте еще раз взглянем на дерево компонентов (рис. 9-11): Рис. 9-11. Компоненты, которым необходимо знать о проверке Компонент Zebreto верхнего уровня должен получить это обновление, как и компоненты <Обзор> и <Карточка просмотра>. Передача обратных вызовов вокруг doeне очень хорошо масштабируется для этого варианта использования, поэтому вместо этого мы будем использовать потокоподобную архитектуру данных. Поток - это скорее шаблон, чем формальная структура. Ключевая концепция - однонаправленный поток данных. В React реквизиты и состояние передаются от родительского элемента к дочернему; этот однонаправленный потокозначает, что рендеринг выполняется эффективно, и о состоянии нашего приложения легче думать. Передача большого количества обратных вызовов прерывает этот поток и, по сути, может привести к двусторонней привязке данных, при которой каскадные обновления могут запускаться непредсказуемымиспособами. Используя потокоподобную архитектуру приложения (проиллюстрированную на рис. 9-12), мы можем отделять изменения состояния приложения от частей пользовательского интерфейса, которые могут их инициировать, и поддерживать однонаправленный шаблон. Рис. 9-12. Распространение данных вархитектуре Flux С шаблоном Flux представления визуализируются на основе информации, которую они получают из своих хранилищ. Действия могут быть инициированы взаимодействием пользователя с представлением или другими событиями, такими как инициализация приложения. Диспетчер обрабатывает входящие действияи передает их в хранилища. Flux является официальной архитектурой Facebook для решения этой проблемы, но другие участники сообщества React создали библиотеки, вдохновленные Flux, которые стремятся решить многие из тех же проблем. Рефлюкс, проиллюстрированный на рисунке 9-13, является pочень популярным, и мы будем использовать его для Zebreto. Рисунок 9-13. Распространение данных в архитектуре Reflux С Reflux у вас нет концепции диспетчера. Существуют просто представления, хранилища и действия, и хранилища могут прослушивать действия напрямую.Добавить Reflux в проект React Native так же просто, как установить npm: установка npm --сохранить reflux с помощью Reflux в Zebreto Давайте посмотрим, как Reflux используется в нашем приложении. В Zebreto у нас есть несколько магазинов (показано на рис. 9-14): DeckMetaStore Содержитметаданные колоды, такие как количество ожидающих отзывов, CardsStore Содержит все карты, ReviewStore Содержит обзоры текущей колоды, магазины могут прослушивать друг друга. В Zebreto обзоры составляются на основе информации, полученной как от CARDSTOre, так и от DeckMetaStore, поэтому ReviewStore прислушивается к ним обоим. Эта взаимосвязь показана на рисунке 9-14. Рисунок 9-14. Для хранилищ, используемых в Zebreto, у нас также есть несколько действий, определенных в нашем файле actions.js: // src/actions.js импортируйте Reflux из 'reflux'; экспортируйте переменную DeckActions = Reflux.createActions([ 'createDeck', 'deleteDeck', 'reviewDeck', 'deleteAllDecks' ]); экспортируйте переменную CardActions = Reflux.createActions([ 'createCard', 'deleteCard', 'review', 'editCard', 'deleteAllCards' ]); Любой компонент может запуститьдействие, которое могут прослушивать хранилища, что затем может вызвать каскадные эффекты. Возвращаясь к нашему примеру с просмотром карточки, схема обратного потока данных работает следующим образом: пользователь выбирает ответ, который запускает действие CardActions.review. ReviewStore прослушивает действия CardActions.review и обрабатывает новую информацию. При необходимости ReviewStore запускает действие CardActions.editCard. CardsStore прослушивает CardActions.editCard actions. Соответствующее изменение сохранится в AsyncStorage, а затем запустится обновление. Компонент верхнего уровня <Zebreto> отслеживает обновления в CardsStore и соответствующим образом обновляет свое состояние. Рисунок 9-15. Обработка обновлений после просмотра карт В качестве другого примера, создание колоды работает следующим образом: кнопка create deck запускает действие DeckActions.createDeck. Кнопка "Создать колоду" также вызывает функцию обратного вызова, чтобы Навигатор перенес сцены на экран создания карты. DeckMetaStore прослушивает DeckActions.createDeck; он создает новую колодуи сохраняет ее в AsyncStorage. Сохранение, AsyncStorage и Reflux Сохраняют пользовательские данные Zebreto в AsyncStorage посредством простой сериализации JSON. Это решается через хранилища, поскольку хранилища являются центральным источником информации о состоянии приложений. Например, давайте посмотрим на CardsStore: // src/stores/CardsStore.js импортировать карту из './../data/Card'; импортировать Reflux из 'reflux'; импортировать _ из 'Lodash'; импортировать {CardActions} из './../actions'; импортировать React из 'react-native'; var { Асинхронноехранилище } = React; const CARD_KEY = 'zebreto-карты'; var cardsStore = Reflux.createStore({ init() { this._loadCards().готово(); this.listenTo(CardActions.createCard, this.createCard); this.listenTo(CardActions.Удалить все карточки, this.deleteAllCards); this.listenTo(CardActions.editCard, this.editCard); this._cards = []; this.emit(); }, async _loadCards() { try { var val = await AsyncStorage.GetItem(CARD_KEY); if (val !== null) { this._cards = JSON.parse(val).map((cardObj) => { return Card.fromObject(cardObj); });this.emit(); } else { console.info (\`$ {CARD_KEY} не найден на диске.\`); } } catch (ошибка) { console.error('Ошибка AsyncStorage: ', error.message); } }, async _writeCards() { try { await AsyncStorage.setItem(CARD_KEY, JSON.stringify(this._cards)); } catch (error) { console.error('Ошибка AsyncStorage: ', error.message); } }, deleteAllCards() { this ._cards = []; this.emit(); }, editCard(Новая карточка) { // Предположим newCard.id соответствует существующей карточке. пусть match = _.find(это._cards, (карточка) => { вернуть card.id === newCard.id ; }); match.setFromObject(newCard); this.emit(); }, createCard(front, back, deckID) { this._cards.push(новая карта(front, back, deckID)); this.emit(); }, emit() { this._writeCards().done(); this.trigger(this._cards); } }); экспортировать хранилище карт по умолчанию; Хранилище карт - единственная точка в приложении Zebreto, которая обрабатывает чтение и запись данных, относящихся к открытки. На данный момент это делается с помощью вызовов AsyncStorage в функциях _loadCards() и _writeCards(). Если бы мы хотели обновить способ хранения карточек — например,использовать вместо этого базу данных SQLite или извлекать данные с помощью сетевого вызова, — мы могли бы легко сделать это, обновив эти два метода. Также стоит отметить, что CardsStore загружает сохраненные данные при их инициализации в своем методе init(); и сохраняет cards в AsyncStorage всякий раз, когда они обновляются, в методе emit(). Таким образом, даже когда пользователь завершает работу с приложением, его данные будут сохранены. Использование навигатора Другим возможным интересным моментом является использование компонента <Navigator> в Zebreto. Давайтепосмотрим на исходный код корневого компонента: // src/components/Zebreto.js импортировать React из 'react-native'; var { таблица стилей, вид, навигатор } = React; импортировать Reflux из 'reflux'; импортировать {DeckActions} из './../actions'; импортировать колоды из './Decks'; imобзор портов из './Review'; импортировать NewCard из './NewCard'; импортировать заголовок из './Header'; импортировать CardsStore из './../stores /CardsStore'; импортировать DeckMetaStore из './../stores / DeckMetaStore' ; var Zebreto = React.createClass({ DisplayName: 'Zebreto', компоненты: [Reflux.connect(DeckMetaStore, 'deckMetas')], componentWillMount() { CardsStore.emit(); }, review(deckID) { DeckActions.reviewDeck(deckID); this.refs.navigator.push({ name: 'review', data: { deckID: deckID } }); }, createdDeck( deck) { this.refs.navigator.push({ имя: 'createCards', данные: { колода: deck } }); }, goHome() { this.refs.navigator.popToTop(); }, _renderScene(маршрут) { переключить (route.name ) { case 'decks': return <Обзор колод={this.review} createdDeck={this.createdDeck}/>; case 'createCards': return <Обзор новой карты={this.review} quit={this.goHome} nextCard={this.createdDeck} {...route.data}/>; case 'review': return <Обзор завершенной карты={this.goHome} {...route.data} />; по умолчанию: console.error('Обнаружен неожиданный маршрут: ' + route.name ); } return <Decks/>; }, render() { return ( <Стиль представления={стили.контейнер}> <Заголовок/> <Навигатор ref='navigator' initialRoute= renderScene={this._renderScene}/> </View> ); } }); var styles = таблица стилей.create({ контейнер: { flex: 1, marginTop: 30 } }); экспортируйте Ze по умолчанию вформат breto; В этом файле происходит изрядная работа, поэтому мы будем разбирать его по частям: Метод рендеринга на самом деле довольно мал. Мы оборачиваем все в <View>, затем визуализируем заголовок, содержащий логотип; и <Navigator>, который отображает соответствующую сценуe. Как мы можем видеть из метода _renderScene(), и как обсуждалось ранее, существует три возможных сцены: decks, createCards и review . Таким образом, на верхнем уровне приложение состоит из одного компонента-оболочки с двумя дочерними компонентами. _renderScene() также заботится о том, чтобы прикреплять соответствующие данные и обратные вызовы к каждой сцене в качестве реквизита. Для этого используется расширенный синтаксис. Если вы раньше не часто сталкивались с синтаксисом spread, то это приятная функция, позаимствованная из ES6. В качестве примера, если мы вызвали _renderScene() как follows , он вернет код, указанный в следующей выноске. _renderScene({ data: { someProp: 'whatever', anotherProp: 2 } }); Используя расширенный синтаксис, _renderScene() вернет эквивалент следующего: return ( <Review quit={this.goHome} someProp="whatever" anotherProp={2} />); Итак, вот наш корневой компонент <Zebreto>. Он содержит ссылку на компонент <Navigator> и управляет различными сценами. Однако по большей части более сложная функциональность предоставляется отдельным сценам. Помещаяон <Navigator> и логику _renderScene() в компонент верхнего уровня и передавая обратные вызовы, такие как goHome(), в качестве реквизита для отдельных сцен, самим сценам не нужно знать о структуре навигации. Вместо этого мы сохраняем всю логику рендеринга na,связанную с виджацией, в компоненте <Zebreto>. Если бы мы хотели заменить <Navigator> чем-то специфичным для платформы (например, компонентом <NavigatorIOS>), это было бы легко сделать, поскольку его использование ограничено только этим файлом. (Нампросто нужно было бы создать файл Zebreto.ios.js и Zebreto.android.js соответственно.) Несмотря на то, что прямо сейчас нам это не нужно, приятно иметь видимую и изолированную навигацию в компоненте верхнего уровня. Взгляд на зависимости сторонних производителей Нам также следует изучить внешние библиотеки, используемые в приложении. В Zebreto не так уж много зависимостей сторонних производителей, но некоторые у него есть. Взгляните на package.json: // package.json { "name": "Zebreto", "version": "0.0.1", "private": true, "scripts": { "start": "node_modules/react-native/packager/packager.sh " }, "зависимости": { "Lodash": "^3.10.1", "md5": "^2.0.0", "moment": "^2.10.6", "react": "^0.13.3", "react-native": "^0.11.2", "reflux": "^0.2.12" } } react-native и react являются очевидными зависимостями.Мы также рассмотрели reflux . moment используется для объектов даты, а md5 используется для вычисления идентификаторов карт и колоды. Наконец, Lodash предоставляет нам несколько полезных функций, и мы используем его для проверки перетасовки карт. Стоит отметить, что ни одна из этих библиотек не быларазработана с учетом React Native или mobile, и они работают как есть без каких-либо доработок. Ура! Адаптивный дизайн и размеры шрифта Для того, чтобы ваше приложение могло должным образом поддерживать несколько устройств, в вашем пользовательском интерфейсе необходимо будет учитывать некоторые различия вразмере шрифта. В некоторой степени стили на основе flexbox справляются с этим за вас, не уделяя особого внимания. Однако стили шрифтов часто требуют явных настроек в зависимости от размера экрана. Повторно используемые текстовые компоненты в Zebreto изменяют размер шрифта в зависимости от ширины экранаidth, чтобы соответствовать различным размерам устройств (рис. 9-16). Рис. 9-16. Размер шрифта на iPhone 4S и iPhone 6 немного отличается. Управлять разными размерами шрифта довольно просто. Давайте посмотрим, как выполняется масштабирование шрифта в Zebreto. В каталоге styles/ мы экспортируем таблицы стилей, связанные со шрифтами, из fonts.js, а также коэффициенты масштабирования для последующего использования: // src/styles/fonts.js импортируйте { таблицу стилей } из 'react-native'; var fonts = StyleSheet.create({ normal: { Размер шрифта: 24, семейство шрифтов: 'Avenir Medium' }, альтернативный: { Размер шрифта: 50, семейство шрифтов: 'Avenir Heavy', цвет: '#FFFFFF' }, большой: { Размер шрифта: 32, выровнять: 'center', семейство шрифтов: 'Avenir Medium' } }); var scalingFactors = { normal: 15, big: 7 }; модуль .exports = {шрифты, scalingFactors};n, в наших текстовых компонентах, таких как <NormalText>, мы получаем размеры экрана. API Dimensions доступен в виде полизаполнения, как только нам это потребуется: импортируйте Dimensions из 'Dimensions'; let {width, height} = Dimensions.get('window'); Теперь у нас есть варианты затемнения экрана для работы спараметрами, доступными в виде переменных width и height . Для <NormalText> мы используем только значение ширины в сочетании с нашим коэффициентом масштабирования для определения размера шрифта: var scaled = StyleSheet.create({ normal: { Размер шрифта: ширина / scalingFactors.normal } }); Затем мы используем эту таблицу стилей в нашем компоненте: // src/components/NormalText.js импортируйте React из 'react-native'; var { Таблица стилей, текст, вид } = React; импортируйте {шрифты, коэффициенты масштабирования} из './../стили/шрифты'; импортируйте размеры из 'Dimensions'; let {width} = Dimensions.get('window'); var NormalText = React.createClass({ DisplayName: 'NormalText', PropTypes: { style: View.PropTypes.style }, render() { return ( <Стиль текста={[this.props .style, fonts.normal, scaled.normal]}> {this.props.children} </Text> ); } }); var scaled = таблица стилей.create({ normal: { Размер шрифта: ширина / scalingFactors.normal } }); экспортируйте обычный текст по умолчанию; И все! Компонент <HeadingText> использует тот же подход, поэтому всякий раз, когда мы используем <HeadingText> или <NormalText> elseгде в приложении, размер шрифта должен быть соответствующим образом увеличен. Резюме и домашнее задание Приложение Zebreto предназначено для использования в качестве справочного материала. Во многих отношениях это “минимально жизнеспособный проект”, и есть множество способов улучшить его. Как быни было сказано, в кодовой базе еще много чего интересного, и я призываю вас углубиться в это. Если вы хотите еще немного попрактиковаться в работе в контексте React Native, я рекомендую вам ознакомиться с репозиторием GitHub и попробовать расширить Zebreto. Hвот несколько идей, которые помогут вам начать: Добавьте возможность удалять колоды, Добавьте экран, на котором вы можете просматривать все карты в колоде, покажите статистику о сильных сторонах карт в колоде, Поэкспериментируйте с разными стилями, Измените компонент "Колоды" на использование ListView Iв следующей главе мы рассмотрим процесс фактической отправки Zebreto — или вашего собственного приложения! — в App Store. Глава 10. Развертывание в iOS App Store Теперь, когда у вас есть совершенно потрясающее приложение, вам захочется, чтобы оно попало в руки ваших пользователей. Этот процесс зависит от платформы. В этой главе мы сосредоточимся на подробных шагах по загрузке приложения в iOS App Store. Как веб-разработчики, мы привыкли иметь больший контроль над процессами развертывания. Возможно, вы привыкли отправлять код в производство много раз за один день, и версии обычно не выпускаются. В iOS App Store развертывание значительно усложняется, а для выпуска новых версий обычно требуется 1-2 недели на проверку. Таким образом, важно учитывать процесс отправки и рецензирования в App Store на этапе планирования. Подготовка вашего проекта Xcode Ваш проект Xcode содержит множество метаданных о вашем приложении. React Native устанавливает для вас некоторые значения по умолчанию, но прежде чем мы отправимнаше приложение на проверку, нам нужно убедиться, что определенные атрибуты установлены правильно. В случае с Zebreto файл нашего проекта находится в iOS/Zebreto.xcodeproj. Если по какой-либо причине вы еще не сделали этого, убедитесь, что ваш файл Xcode project проверен в системе управления версиями. Нередки случаи, когда Xcode выходит из строя при попытке редактирования проекта, оставляя файл проекта в нерабочем состоянии. Откройте свой проект в Xcode (рис. 10-1). Вам нужно будет открыть левую панель и закрыть правую и нижние панели (элементы управления для этого находятся в правом верхнем углу). Рисунок 10-1. Откройте свой проект в Xcode, выбрав Поддерживаемые устройства и целевую версию iOS Вам нужно будет решить, на какую версию iOS должен быть нацелен ваш проект. Как ни странно, для этого есть два отдельных, но связанных параметра: базовая версия SDK и цель развертывания iOS. По умолчанию React Native устанавливает целевое значение развертывания равным 7.0 и использует последнюю версию iOS SDK (9.0). Целью развертывания является минимальная версия iOS, необходимая для запуска yнашего приложения, в то время как версия SDK определяет, на основе какой версии SDK будет создано ваше приложение. Разница в этих значениях задокументирована Apple. Для наших целей просто помните, что базовая версия SDK должна быть больше или равнадля целевого развертывания iOS. Если вы используете какие-либо API iOS, для которых требуется более высокая версия, чем указано по умолчанию, вам необходимо соответствующим образом изменить значение цели развертывания. Вы можете изменить это в меню Информация для вашего проекта (рис. 10-2). Fрисунок 10-2. Выбор целевой версии iOS Если вы хотите обновить базовую версию SDK, она указана в меню настроек сборки (рис. 10-3). Рисунок 10-3. Изменение базовой версии SDK Если вы выберете свое приложение (в разделе ЦЕЛИ) вместо своего проекта, вы также можете выбрать, какие устройства и ориентации экрана поддерживает ваше приложение. А именно, для проектов iOS вы можете обозначить свое приложение как предназначенное только для iPhone, только для iPad или Универсальное, что означает, что оно поддерживает как iPad, так и iPhone (рис. 10-4). Рисунок 10-4. Настройка целевых устройств После того, как вы определили, какие устройства вы хотите поддерживать, мы можем перейти к настройке изображения запуска и значков приложений. Изображения экрана запуска Изображение экрана запуска - это изображение-заполнитель, которое появляется, когда user запускает ваше приложение во время загрузки. Здесь есть несколько подходящих подходов. Некоторые приложения предпочитают использовать “заставку” с логотипом и названием своего приложения. Другие приложения выбирают экран, имитирующий интерфейс использования приложенияr, но без ввода каких-либо данных, чтобы переход выглядел более плавным. Независимо от того, какой подход вы выберете, вам необходимо будет предоставить изображение экрана запуска в размерах, соответствующих всем поддерживаемым вами устройствам. Начните с выбора каталога Image.xcassets/ вашего проектаect и создания нового набора изображений запуска (рис. 10-5). Рис. 10-5. Добавляйте изображения запуска Отсюда вам будет предоставлена возможность добавлять изображения запуска соответствующего размера для каждого соответствующего размера устройства (рис. 10-6). Фух! Этоочень много. Рисунок 10-6. Добавление изображений запуска для каждого размера и ориентации устройства Требуемые размеры зависят от устройства. Например, для iPhone 6 требуется файл размером 750 x 1334 пикселей для портретного режима и файл размером 1334 x 750px для альбомного режима. Для получения информации о конкретных требуемыхразмерах обратитесь к документации Apple. Xcode будет генерировать предупреждения, если вы укажете файл неправильного размера, поэтому вы также можете использовать это для руководства. Добавление значка вашего приложения Значок вашего приложения - это то, что отображается на главном экране пользователя, так же как мыделаем это в App Store. Как и на экране запуска, вы должны указать ресурсы значков приложений в размерах, соответствующих поддерживаемым вашим приложением устройствам, и сверить свои размеры с документацией Apple. В руководстве Apple по пользовательскому интерфейсу содержатся некоторые основные рекомендации. Значки приложений не должны содержать прозрачных областей и должны быть квадратными. (Apple применяет эффект закругленных углов к вашим значкам; вам не нужно делать это самостоятельно.) Нажмите кнопку "Плюс", пока выбрана ваша папка Image.xcassets /d, точно так же, как вы делали ранее для изображения запуска. Однако на этот раз вместо этого создайте новый значок приложения (рис. 10-7). Рис. 10-7. Добавление значков в свой проект Вы можете перетащить файлы сюда, чтобы добавить их в виде значков. Если вы удалите свое приложение из симулятора или со своего устройства, а затем переустановите его, теперь вы должны увидеть свой значок, как показано на рисунке 10-8. Рисунок 10-8. Установив пользовательский значок, вы увидите его на главном экране после установки вашего приложения даже во время разработки. Если по какой-либо причине ваш изображение запуска или значок приложения отображаются неправильно, обязательно проверьте значения в разделе Значки приложений и изображения запуска, которые вы найдете в меню Общих настроек. Рисунок 10-9. Дважды проверьте Исходный код значков приложений и Запустите исходные файлы изображений, установив Your Bundle Name Название пакета вашего проекта в Xcode определяет, как будет называться ваше приложение на устройстве пользователя, поэтому это очень важно. Обратите внимание, что Xcode иногда захлебывается при попытке переименования файлов и фактически может повредить файл вашего проекта. Убедитесь, что файл вашего проекта проверен в системе контроля версий, прежде чем пытаться использовать функцию переименования Xcode. Мы можем просмотреть и отредактировать это значение в разделе "Идентификатор и тип" на правой панели меню (рис. 10-10). Это значение яустановлю для вас при запуске react-native init, но если вы хотите изменить название, сейчас самое время это сделать. Рисунок 10-10. Имя в меню Identity and Type - "Обновление AppDelegate для пользователя".m Напомним, что в AppDelegate.m есть два способа указатьместоположение кода JavaScript: из связанного файла или с localhost. Запуск упаковщика React Native в процессе разработки - это нормально, но для развертывания нам потребуется сгенерировать связанный файл JavaScript. Прокомментируйте первый вариант, который использует localhost, и включите второй вариант, который загружается из связанного файла: // jsCodeLocation = // [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle "]; ... jsCodeLocation = [[NSBundle mainBundle] URLForResource:@"main" с расширением:@"jsbundle"]; Сделав это, нам нужно будет сгенерировать пакет. Из каталога вашего проекта запустите: react-native bundle --minify После этого рекомендуется убедиться, что ваше приложение все еще работает в симуляторе. Перезапустите симулятор и попробуйте запустить ваше приложение. Это должно работать как обычно. Установите схему для выпуска Далее нам нужно установить схему сборки для выпуска, а не для отладки. Как показано на рисунке 10-11, перейдите к Продукту → Схема → Редактировать схему.... Рисунок 10-11. Выберите опцию Редактировать схему ..., затем измените схему вашего проектаt на Release (рис. 10-12). Рис. 10-12. Установите для конфигурации сборки значение Release и снимите флажок “Отлаживать исполняемый файл”. Это означает, что такие вещи, как меню Debug, не будут отображаться при запуске вашего приложения. Загрузка приложения Итак, теперь, когда наш проектct должным образом настроен для выпуска, пришло время отправить его в Apple! Приведение в порядок документов Вы не сможете отправить заявку в App Store без учетной записи разработчика Apple, поэтому, если вы еще не зарегистрировались, сейчас самое время!Я! Это вернет вам 99 долларов за год. Кроме того, если вы зарегистрировались ранее, может оказаться, что вам потребуется подписать некоторые обновленные соглашения. Сообщения об ошибках, указывающие на это, не всегда легко разобрать, как вы можете видеть на рисунке 10-13. Рисунок 10-13. Если вы видите ошибку такого рода, сначала попытайтесь следовать предоставленным инструкциям, к сожалению, при посещении указанного URL-адреса иногда возникает аналогичная ошибка, как показано на рисунке 10-14. Рисунок 10-14. Если вы видите ошибку такого рода, посетите iTunes Connect aи проверьте наличие каких-либо невыполненных документов. Если вы столкнулись с подобными проблемами, сначала обратитесь в iTunes Connect, а не в Центр обслуживания пользователей. Оттуда выберите Соглашения, Налоговые и банковские услуги и заполните все оставшиеся формы. Создание архива Следующим шагом будет созданиеархива вашей заявки для отправки в App Store. Это действие находится в меню в разделе Продукт → Архив. Если значение Архив выделено серым цветом (как на рис. 10-15), это, вероятно, потому, что в качестве цели сборки выбран симулятор iOS. Figure 10-15. Если опция Архивирования отключена, попробуйте изменить цель сборки. Измените цель сборки на устройство iOS, и вы сможете выбрать "Архивировать" в меню. Рисунок 10-16. Выберите Продукт → Архив, чтобы начать процесс создания архива, если процесс пройдет успешно, появится экран Архивирования (рисунок 10-17). Рисунок 10-17. Выберите архив для загрузки в App Store Готовы нажать кнопку "Загрузить в App Store"? Дерзайте! Xcode выполнит несколько последних проверок, после чего вы сможете отправить свое приложениев Apple (рис. 10-18). Рис. 10-18. Нажмите "Отправить", чтобы отправить свой архив в App Store Создание приложения в iTunes Connect Если вы думали, что на этом закончили, извините, но это еще не все! Ваш архив заявки был загруженd, но теперь вам нужно подготовить фактическую отправку через iTunes Connect. Сюда входят важные метаданные о вашем приложении, такие как описание и скриншоты, которые будут доступны пользователю. Для получения более подробной информации об этом процессе вы можете ознакомиться с документацией Apple по созданию записи iTunes Connect. Сначала вам необходимо зарегистрировать идентификатор приложения в Центре разработчика. В форме вам потребуется ввести идентификатор пакета для вашего приложения (рисунок 10-19). Рисунок 10-19. Установка идентификатора пакета в Xcode Этот идентификатор должен соответствовать идентификатору пакета, указанному в вашем проекте Xcode (расположен в меню Identity); см. Рисунок 10-20. Рисунок 10-20. Идентификатор пакета в Центре разработчика должен совпадать с идентификатором пакета из Xcode BUNDLE IDENTIFIERS Если идентификаторы вашего пакета не совпадают, вы не сможете связать архив вашего приложения с его записью iTunes Connect. Обязательно перепроверьте! Далее мы можем создать новое приложение в iTunes Connect (рис. 10-21). Рис. 10-21. Выберите Новое приложение для iOS, чтобы создать новое приложение в iTunes Connect, снова появится идентификатор пакета. Выберите подходящее и перейдите к созданию своего приложения. Если загрузка архива вашего приложения прошла успешно, вы увидите, что ваша сборка отображается в приложении iTunes Connectt (рис. 10-22). Рис. 10-22. После загрузки архива вашего приложения оно появится здесь, под списком сборок. Если вы не видите здесь никаких сборок, попробуйте проверить следующее: совпадают ли идентификаторы пакетов в вашей записи iTunes Connect и Xcode project?d Xcode выдает какие-либо ошибки при попытке загрузить архив? Что происходит при повторной загрузке архива приложения? В iTunes Connect теперь вы сможете ввести информацию, относящуюся к списку вашего приложения в App Store (например, правильный центр сертификации, географию, описание и т.д.). Необходимо заполнить еще много информации, так что не торопитесь. Важное замечание: на этой странице также можно загружать скриншоты и видео-руководства по вашему приложению. Предоставление скриншотов хорошего качества является критическимфактором успеха вашего приложения в App Store. Как обычно, вам необходимо предоставить скриншоты соответствующего размера для каждого типа поддерживаемых устройств (рис. 10-23). Рис. 10-23. Загрузка скриншотов СКРИНШОТЫ И СИМУЛЯТОР IOS Вы можете использовать симулятор iOS, чтобы легко получать скриншоты подходящего размера. Загрузите каждый тип устройства и нажмите Command + S, чтобы сохранить снимок экрана. Бета-тестирование с помощью TestFlight Перед отправкой вашей заявки на проверку в App Store вам следует использовать TestFlight для бета-тестированияg. Даже если вы единственный “бета-тестировщик”, работа с TestFlight, а не с приложением в режиме разработки, дает вам более точное представление о том, каким будет ваше приложение после загрузки на устройство пользователя. TestFlight позволяет вамлегко отправлять пользователям приглашения на тестирование по электронной почте. Под записью вашего приложения в iTunes Connect выберите TestFlight и добавьте своих бета-тестеров (рисунок 10-24). Для этого вам понадобятся их адреса электронной почты. Рисунок 10-24. Экран TestFlight в iTunes Connect Вашим бета-тестировщикам сначала потребуется установить приложение TestFlight. Затем, как только они получат по электронной почте приглашение протестировать ваше приложение, TestFlight предоставит им возможность установить ваше приложение (рис. 10-25). После установки приложениебудет вести себя так же, как любое другое. Рисунок 10-25. Бета-тестировщики получат приглашение по электронной почте через TestFlight, которое позволит им установить приложение, отправив заявку на проверку После того, как вы будете удовлетворены отзывами бета-тестировщиков, ивы заполните всю необходимую информацию в iTunes Connect, вы сможете (наконец-то!) отправьте вашу заявку на рассмотрение. После отправки iTunes Connect отметит, что ваша заявка имеет статус “Ожидает рассмотрения” (рисунок 10-26). Рисунок 10-26. Ваш статус application доступен для просмотра в iTunes Connect. Вы будете получать обновления по электронной почте, как только ваша заявка попадет в начало очереди рассмотрения, а также как только она будет отклонена или принята. В среднем процесс проверки App Store занимает 1-2 недели, инет простого способа определить, на каком этапе находится ваше приложение. Сроки рассмотрения будут увеличиваться в наиболее загруженные периоды года, например, в сезон отпусков. Для справки: Zebreto был принят после восьмидневного ожидания. После того, как приложение аккepted, поздравляю; теперь он должен быть доступен для загрузки в магазине приложений. Краткое описание После напряженной работы по созданию вашего приложения, выпуск его для ваших пользователей может вызвать волнение! Однако выпуск вашего приложения - это только начало, поскольку вампридется поддерживать ваше приложение после выпуска. В отличие от Интернета, где вы можете развертывать часто и легко, новые версии iOS требуют времени и имеют более длительный срок службы. У многих пользователей iOS не включено автоматическое обновление, поэтому важна каждая версия. И, как минимум, вамнужно будет ждать, пока Apple рассмотрит вашу заявку каждый раз, когда вы захотите отправить обновление или исправление ошибки. (Для действительно важных исправлений вы можете запросить ускоренную проверку, но используйте их осторожно!) Кроме того, выпуски для iOS несколько рискованны с точки зрения рейтинга вашеговашего приложения. Ваш средний отзыв, отображаемый на странице приложения в App Store, основан на текущей версии, а не на ее общей оценке, поэтому выпуск с ошибками может серьезно навредить вам. Помните, тестирование - ваш друг! Когда вам нужно отправить новую версию вашегоприложения, процесс очень похож на процесс первоначальной загрузки. Измените версию вашего приложения в Xcode, затем отправьте новый архив. Вы найдете варианты отправки новой сборки на проверку в iTunes Connect. Теперь, когда мы рассмотрели, как отправитьbmit ваше приложение в iOS App Store, в следующей главе мы обратим внимание на то, как аналогичный процесс работает для Android. Глава 11. С развертыванием приложений для Android все в порядке! Вы зашли так далеко; готовы развернуть свое приложение для Android и передать его в руки ваших пользователей? Если вы уже проходили процесс отправки приложений для iOS, многое здесь покажется знакомым, хотя, к счастью, процесс утверждения в Play Store проще. Рассмотрение также происходит быстрее: вы можете ожидать, что одобрение вашейзаявки займет 1-2 рабочих дня. В этой главе мы расскажем, что вам нужно сделать, чтобы создать готовый к развертыванию APK-файл вашего приложения React Native, как распространить его среди бета-тестировщиков и как отправить его в Google Play Store для проверки. ОЗНАКОМЬТЕСЬ СЭтой ДОКУМЕНТАЦИЕЙ! Здесь мы подробно расскажем о том, как развернуть ваше приложение для Android, но вам всегда захочется ознакомиться с официальной документацией для получения наиболее актуальных процедур. Настройка значка приложения Хотя значок Android по умолчанию довольно симпатичный, вам захочется заменить его значком пользовательского приложения перед развертыванием вашего приложения. Значок приложения указан в android/app/src/main/AndroidManifest.xml: android:icon="@mipmap/ic_launcher", Этот путь к файлу ссылается на путь внутри android/app/src/main/res/. Возможно, вы помните из главы 3, что ресурсы изображений Android расположены в разных папках в зависимости от их разрешения. Файл значков ничем не отличается. Вы заметите, что значок по умолчанию уже присутствует в вашем приложении (рис. 11-1). Рис. 11-1. Файловая структура файлов значков приложений Вы можете просто заменить эти файлы напрямую или изменить путь к значку в вашем приложении AndroidManifest.xml, чтобы он указывал на другое местоположение. При переустановке приложения на устройство вы увидите, что в нем используется ваш новый значок (рис. 11-2). Рис. 11-2. Просмотр наших установленных приложений, теперь с пользовательским значком для Zebreto Если создание значков приложений в различных разрешениях кажется утомительным, попробуйте воспользоваться инструментом, который создает подходящие для вас размеры. Я лично являюсь поклонником проекта romannurik. Создание APK для выпуска Чтобы развернуть приложение для Android, нам нужно сгенерировать релизный APK (APK - это файл пакета приложений для Android, формат, используемый для распространения приложений для Android). Здесь есть пять bшагов asic: 1. Сгенерируйте ключ подписи. 2. Настройте переменные gradle. 3. Добавьте конфигурацию подписи в конфигурацию gradle приложения. 4. Создайте release APK. 5. Установите release APK на устройство. Мы рассмотрим их один за другим. Вы также можете прочитать иофициальный обзор публикации roid для получения дополнительной информации. Сначала вам нужно сгенерировать ключ подписи для вашего приложения. Вы можете использовать keytool для генерации хранилища ключей и ключа: $ keytool -genkey -v -хранилище ключей my-release-key.keystore \ -псевдоним my-key-alias -keyalg RSA -размер ключа 2048 -срок действия 10000 В документах Android содержится дополнительная информация о подписании приложения. Android использует подпись сертификата для идентификации автора приложения. Не забудьте свою кодовую фразу и не потеряйте свой ключ. Они вам понадобятся, чтобыупростить обновление вашего приложения! Предыдущая команда сгенерирует файл my-release-key.keystore. Переместите его в каталог android /app / вашего проекта. Затем создайте или отредактируйте файл ~/.gradle/gradle.properties и добавьте код, приведенный в примере 11-1. Пример 11-1. Добавьте эти переменные в ~/.gradle/gradle.properties MYAPP_RELEASE_STORE_FILE=my-release-key.keystore MYAPP_RELEASE_KEY_ALIAS=my-key-alias MYAPP_RELEASE_STORE_PASSWORD=**** MYAPP_RELEASE_KEY_PASSWORD=***** Замените звездочки на password, который вы использовали при вызове keytool ранее. Помещая их в наш файл ~/.gradle / gradle.properties, мы включаем их в нашу общую конфигурацию gradle. (Помните, gradle - это система сборки, используемая в наших проектах React Native.) БУДЬТЕ ОСТОРОЖНЫ Со СВОИМИВАШИМИ КЛЮЧАМИ! Не проверяйте пароли к ключам в системе управления версиями! И не потеряйте свои ключи. После публикации вашего приложения, если вы захотите использовать новый ключ, вам нужно будет создать новую запись в Play Store, и вы потеряете всю статистику загрузок и обзоры. Теперь, когда мы настроили наши переменные gradle, нам нужно добавить нашу конфигурацию подписи в конфигурацию gradle нашего приложения. Откройте файл android/app/build.gradle и добавьте конфигурацию подписи (пример 11-2). Пример 11-2. Изменения в android /app/build.gradle ... android { ... defaultConfig { ... } signingConfigs { release { Файл storeFile(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS ключевое слово MYAPP_RELEASE_KEY_PASSWORD } } Типы сборки { release { ... signingConfig signingConfigs.release } } } ... Обратите внимание, что здесь мы используем переменные, определенные ранее в ~/.gradle/gradle.properties . ХОРОШО! Теперь мы готовы сгенерировать наш подписанный APK-файл. Запустите React Native Packager в вашем терминале из корня проекта: $ npm начните снова из корня проекта, выполните следующие команды: $ mkdir -p android/app/src/main/assets $ curl \ "localhost: 8081/index.android.bundle?platform = android&dev= false&minify=true" \ -o "android / app/ src/main/assets /index.android.bundle" $ cd android && ./gradlew assembleRelease Вау, что здесь происходит? Сначала мы создаем ресурсы / каталог для хранения нашего связанного JavaScript. Затем мы извлекаем связанный JavaScript из React Native Packager с помощью команды curl. Наконец, мы используемg gradlew для сборки нашего релиза APK. ЭТА ПРОЦЕДУРА МОЖЕТ ИЗМЕНИТЬСЯ! Команда React Native указала, что эта процедура может измениться в будущих версиях React Native, поскольку скручивание специального URL-адреса - не самый интуитивно понятный процесс. Как всегда, обратитесь к официальнойдокументации. После этого вы можете отключить упаковщик React Native; ваш связанный JavaScript сохранен на диске. Из каталога android / вашего проекта выполните следующую команду, чтобы установить подписанный APK: ./gradlew installRelease Это позволит установить подписанный APK на ваше устройство. Как всегда, перед развертыванием вам нужно протестировать свое приложение. Для начала вы можете загрузить этот APK-файл на эмулятор или подключенное физическое устройство с помощью команды gradlew installRelease. Распространение по электронной почте или другимиспособами Знаете ли вы, что на самом деле вам не нужно развертывать свое приложение в Play Store, чтобы распространять его среди пользователей Android? В крайнем случае — или для тестирования — вы можете просто распространить APK-файл среди пользователей по электронной почте. Открытие электронного письма с Android-устройства Device даст пользователям возможность установить его. Ваш APK-файл находится по адресу android/app/build/outputs/apk/app-release.apk. Вы можете подтвердить, что ваш релиз APK был успешно собран, проверив существование файла: $ ls android/app/build/outputs /apk/ app-debug-unaligned.apk app-debug.apk app-release-unaligned.apk app-release.apk Отправка этого файла по электронной почте вашим пользователям позволит им загрузить и установить его. Фактически, ссылка на этот APK из любого места и открытие этой ссылки с Android позволят пользователям iустановить ваше приложение. Одно предостережение: сначала вам нужно разрешить установку приложений из неизвестных источников. Проверьте документы Android в неизвестных источниках для получения дополнительной информации. Отправка приложения в Play Store После того, как у вас будет некоторое время протестировать свойr release APK на реальном устройстве (или, надеюсь, на нескольких устройствах), вы готовы к развертыванию в Google Play Store. Хорошо! Этот процесс относительно безболезненный, и проверка тоже происходит довольно быстро; вы можете рассчитывать на развертывание вашего приложения в течение 24 часовпосле отправки. Для начала перейдите на страницу http://developer.android.com и щелкните Консоль разработчика в правом верхнем углу страницы (рис. 11-3). Рисунок 11-3. Перейдите в консоль разработчика по ссылке http://developer.android.com Если у вас еще неготова учетная запись разработчика, вам необходимо ее создать и принять условия Google. Затем щелкните значок Android в меню слева, чтобы просмотреть меню приложений. Нажмите кнопку “+ Добавить новое приложение”, чтобы создать свое приложение (рисунок 11-4). Рисунок 11-4. При добавлении нового приложения Здесь вам будет предоставлена возможность либо сначала загрузить APK-файл, либо отредактировать список в Play Store. Подойдет и то, и другое. Чтобы загрузить свой APK—файл, найдите релизный APK-файл в вашей файловой системе - он должен быть в Android/app/build/outputs/apk/app-release.apk (рис. 11-5). Рисунок 11-5. Выберите файл app-release.apk После загрузки файла APK вы можете заполнить оставшуюся часть списка в Play Store или настроить бета-тестирование. Бета-тестирование через Play Store Хранилище Google Playe предоставляет простую функциональность бета-тестирования. После загрузки APK выберите вкладку бета-тестирование, чтобы начать добавлять бета-тестеров (рис. 11-6). Рисунок 11-6. Варианты бета-тестирования в Play Store Здесь у вас есть несколько вариантов: Открытое бета-тестирование С помощью этой опции пользователи могут присоединиться к программе по специальной ссылке Закрытое бета-тестирование Позволяет добавлять отдельных пользователей по их адресу электронной почты Бета-тестирование С использованием групп Google или сообществ Google+ Эта опция позволяет членам вашей специальной группы Google присоединиться кбета-тестированию, после чего Google упрощает распространение вашего APK среди этих пользователей. Даже в большей степени, чем в случае с iOS, для Android вам захочется, чтобы ваше приложение попало в руки как можно большего числа пользователей, потому что устройства так сильно различаются. Например, Zebreto, приложение React Native, созданное с настройками по умолчанию, указано как совместимое с 7 867 различными устройствами в соответствии с Play Store (рис. 11-7). Ого! Рисунок 11-7. Play Store услужливо укажет, какие устройства поддерживает ваше приложениеили Разные устройства означают разные размеры экрана и разрешения, разные функции и даже различия в оформлении — некоторые производители применяют свои собственные скины поверх пользовательского интерфейса Android по умолчанию. Воспользуйтесь возможностью бета-тестирования! Список Play Store Список Play Store содержит важную информацию о вашем приложении (например, его название, описание, категорию, рейтинг контента и т.д.). Вам потребуется заполнить большинство этих полей, чтобы выпустить ваше приложение. Консоль разработчика легкопредоставит вам список оставшихся задач, если вы нажмете на ссылку “Почему я не могу опубликовать?” (рис. 11-8). Рисунок 11-8. Незавершенные задачи, которые необходимо выполнить перед публикацией По мере выполнения различных необходимых задач флажки в меню с левой стороны станут зелеными. Наконец, как только вы выполните все необходимые шаги, кнопка “Опубликовать приложение” будет включена. Необходимые ресурсы для размещения в Play Store В рамках размещения в Play Store вам необходимо загрузить некоторые ресурсы с изображениями (рис.e 11-9). К ним относятся: Как минимум два снимка экрана из вашего приложения; версия значка вашего приложения в формате PNG размером 512x512 пикселей; “Функциональное изображение” в формате JPG или PNG размером 1024x500 пикселей для Play Store (рисунок 11-9). Загрузка графики в список Play Store Там есть также некоторые другие необязательные изображения, такие как промо-графика и промо-видео. Помните, что эти ресурсы имеют решающее значение для успеха вашего приложения в Play Store! Если у вас еще нет скриншотов, самое время их сделать. Здесь у вас есть два варианта : делать скриншоты с физического устройства или использовать эмулятор. Вы можете делать снимки экрана на физическом устройстве, удерживая кнопки питания и уменьшения громкости одновременно. Делать снимки экрана с помощью эмулятора немного сложнее. Во-первых, убедитесь, что в вашем эмуляторе выделено хранилище для файла на SD-карте. (Вы можете сделать это, запустив Android avd, а затем выбрав “Редактировать”, чтобы просмотреть спецификации эмулятора.) Затем вы можете делать скриншоты с помощью оболочки adb: adb shell screencap -p / sdcard /screen.png adb pull / sdcard /screen.png adb shell rm / sdcard / screen.png Эти команды сделают снимок экрана, а затем перенесут его в вашу локальную файловую систему. Если вы предпочитаете однострочный вариант, попробуйте следующую команду:1 adb shell screencap -p | perl -pe 's / \ x0D\ x0A / \ x0A / g' > screen.png Это скопирует ваш снимок экрана в screen.png в вашей локальной файловой системе. Публикация заявки Готовы отправить заявку? Как показано на рисунке 11-10, продолжайте и нажмите кнопку “Опубликовать приложение”! Рисунок 11-10. Публикация yнашего приложения в Play Store После отправки вашей заявки на рассмотрение статус вашей заявки изменится на ожидающий, как вы можете видеть на рисунке 11-11. Рисунок 11-11. Заявка, ожидающая рассмотрения, как правило, должна быть рассмотрена в течение 24 часов. После Ward ваша заявка будет доступна для широкой публики через Play Store — поздравляем! Смотрите рисунок 11-12. Продолжайте и насладитесь великолепием вашего общедоступного полноценного приложения для Android. Рисунок 11-12. Приложение Zebreto, доступно в Play StoreКраткое описание К этому моменту вы должны быть готовы выпускать свои приложения React Native как в Google Play Store, так и в iOS App Store! Вообще говоря, процесс выпуска приложений для Android быстрее и проще по сравнению с обычным процессом выпуска приложений. Однако, как и в случае с iOS, развертывание вашего приложения - это только начало. Вам следует спланировать, как вы будете поддерживать свое приложение для Android после выпуска, и, как и в случае с iOS, вы не должны предполагать, что у пользователей будет включено автоматическое обновление для вашего приложения. Кроме того, у пользователей Android есть огромный выбор устройств с различными спецификациями, поэтому пользовательское тестирование каждой версии на Android еще более важно. 1версия с одной строкой предоставлена нам благодаря блогу shvestov. Направляйтесь туда, если вам интересно, зачем нам нужно использовать Perl. Заключение Если вы зашли так далеко, поздравляю! Мы прошли путь от создания вашего самого первого приложения React Native до развертывания кроссплатформенного приложения как в iOS App Store, так и в Google Play Store. Для этого мы начали с изучения базовых компонентов React Native и того, как их стилизовать. Мы узнали, как работать с сенсорными и платформенными API, такими как Camera Roll и Geolocation API. Мы рассмотрели, как устранятьошибки в приложениях React Native с помощью инструментов разработчика и как развертывать ваши приложения на реальных устройствах. Что касается функциональности, выходящей за рамки стандартной библиотеки React Native, мы также увидели, как использовать собственные модули Objective-C и Java, а также criptбиблиотеки JavaSсторонних производителей с использованием npm. Ваши знания JavaScript и React в сочетании с темами, которые мы рассмотрели в этой книге, должны позволить вам быстро и эффективно писать кроссплатформенные мобильные приложения для Android и iOS. Конечно, еще многомупредстоит научиться, и в одной этой книге невозможно охватить все, что вам нужно знать для разработки мобильных приложений с использованием React Native. Если вы застряли или у вас возникли вопросы, обратитесь к сообществу, будь то через Stack Overflow или IRC (irc: // chat.freenode.net/reactnative). Оставайтесь на связи! Присоединяйтесь к списку рассылки Learning React Native по адресу LearningReactNative.com для получения дополнительных ресурсов и обновлений, связанных с книгой. Вы также можете найти меня в Twitter под именем @brindelle. Наконец, и это самое главное, получайте удовольствие! Яс нетерпением жду возможности увидеть, что вы создадите. Приложение A. Синтаксис ES6 В некоторых примерах кода в этой книге используется так называемый синтаксис ES6. Если вы не знакомы с синтаксисом ES6, не волнуйтесь — это довольно простой перевод с JavaScript, к которому вы, возможно, привыкли. ES6 относится к ECMAScript 6, также известному как “Harmony”, готовящейся версии ECMAScript. JavaScript - это реализация ECMAScript. За этими соглашениями об именовании стоит много интересной истории, но что вам нужно знать: ES6 - это “новая” версия JavaScript, которая расширяет существующую спецификацию некоторыми полезными новыми функциями. React Native использует Babel, компилятор JavaScript, для преобразования нашего кода JavaScript и JSX. Одной из особенностей Babel является его способность cпреобразовывать синтаксис ES6 в JavaScript, совместимый с ES5, поэтому мы можем использовать синтаксис ES6 во всей нашей базе кода React. Деструктурирование Назначения деструктурирования предоставляют нам удобное сокращение для извлечения данных из объектов. Возьмем этот фрагмент, соответствующий ES5: var myObj = {a: 1, b: 2}; var a = myObj.a; var b = myObj.b; Мы можем использовать деструктурирование, чтобы сделать это более кратко: var {a, b} = {a: 1, b: 2}; Вы часто увидите, что это используется с инструкциями require . Когда нам требуется React, мы фактически получаем объект. Мы могли бы называть компоненты, используя синтаксис, как показано в примере A-1. Пример A-1. Импорт компонента <View> без деструктурирования var React = require('react-native'); var View = React.Вид, но гораздо приятнее использовать деструктурирование, как показано в примере A-2. Рассмотримтаблицу A-2. Использование деструктурирования для импорта компонента <View> var { View } = require('react-native'); Импорт модулей Обычно мы можем использовать синтаксис модуля CommonJS для экспорта наших компонентов и других модулей JavaScript (пример A-3). В этой системе мы используем require для импорта других модулей и присваиваем значение module.exports, чтобы сделать содержимое файла доступным для других модулей. Пример A-3. Запрашивание и экспорт модулей с использованием синтаксиса CommonJS var OtherComponent = require('./other_component'); var MYComponent = React.createClass({ ... }); module.exports = MyComponent; Используя синтаксис модуля ES6, мы можем использовать вместо него команды экспорта и импорта. В примере A-4 показан эквивалентный код, использующий синтаксис модуля ES6. Пример А-4. Импорт и экспорт модулей uсинтаксис модуля ES6 импорт другого компонента из './other_component'; var MyComponent = React.createClass({ ... }); экспортировать MyComponent по умолчанию; Сокращение функции Сокращение функции ES6 также удобно. В JavaScript, совместимом с ES5, мы определяем функциюs, как показано в примере A-5. Пример A-5. Отображение объявления функции в формате Longhand: function() { return <Text>Hi</Text>; } Повторное написание функции может раздражать. Пример A-6 показывает ту же функцию, на этот раз с применением сокращения функции ES6. Пример A-6. Краткое объявление функции render() { return <Text>Hi</Text>; } Функции с жирной стрелкой В JavaScript, совместимом с ES5, нам часто приходится привязывать наши функции, чтобы убедиться, что их контекст (т. Е. Значение this) соответствует ожидаемому (пример A-7). Это особенно часто встречается при работе с обратными вызовами. Пример A-7. Привязка функций вручную с помощью JavaScript var callbackFunc = function(val) { console.log('Сделай что-нибудь'); }.bind(this); Функции с жирной стрелкой привязываются автоматически, поэтому намне нужно делать это самим (пример A-8). Пример А-8. Используя функцию с жирной стрелкой для привязки var callbackFunc = (val) => { console.log('Сделай что-нибудь'); }; Интерполяция строк В JavaScript, совместимом с ES5, мы могли бы создать строку, используя такой код, как that в примере A-9. Пример А-9. Конкатенация строк в JavaScript, совместимом с ES5, var API_KEY = 'abcdefg'; var url = 'http://someapi.com/request&key =' + API_KEY; ES6 предоставляет нам временные строки, которые поддерживают многострочные строки и строковую интерполяцию. Заключив строку в обратные метки, мы можем вставить значения других переменных, используя синтаксис $ {} (пример A-10). Пример A-10. Интерполяция строк в ES6 var API_KEY = 'abcdefg'; var url = \`http://someapi.com/request&key = $ {API_KEY}\`; Приложение B. КомандыРуководство по быстрому запуску d Это приложение служит справочником по некоторым удобным командам при работе с проектами React Native. Создание нового проекта react-native init MyProject, работающего на iOS, откройте ios/MyProject.xcodeproj в Xcode. Нажмите кнопку Воспроизведения слева направо. Должен запуститься упаковщик React Native, а также симулятор iOS. При создании снимков экрана на iOS из iOS simulator нажатие Command + S сохранит снимок экрана на вашем рабочем столе. На физическом устройстве нажмите кнопки питания и "Домой" одновременно. При запуске на Android сначала убедитесь, что у вас доступно соответствующее устройство. Чтобы запустить эмулятор, выполните команду: android avd, либо создайте новое виртуальное устройство Android, либо выберите существующее и нажмите кнопку "Пуск ...". В качестве альтернативы вы можете подключить устройство кia USB с включенной отладкой по USB. Чтобы включить отладку по USB, перейдите в Настройки → О телефоне → Номер сборки. Нажмите на номер сборки семь раз, пока устройство не спросит, хотите ли вы включить режим разработки, и выберите “да”. После выполнения любого из этих шагов запустите: react-native run-android Это установит ваше приложение на устройство и запустит React Native Packager. Создание снимков экрана на Android Вы можете делать снимки экрана на физическом устройстве, удерживая одновременно кнопки питания и уменьшения громкости доns. Чтобы делать скриншоты из эмулятора: убедитесь, что в вашем эмуляторе включено хранилище на SD-карте. Затем используйте оболочку adb: adb shell screencap -p /sdcard/screen.png adb pull /sdcard/screen.png adb shell rm /sdcard/screen.png В качестве альтернативы, используйте следующую сокращенную команду: adb shell screencap -p | perl -pe 's /\ x0D \ x0A / \x0A / g' > screen.png Запуск упаковщика React Native Если по какой-либо причине вам необходимо запустить упаковщик React Native вручную, перейдите в корневой каталог вашего проекта и запустите: npm start Index Symbols @ файлы с разрешением 2x и @3x, Компонент изображения @ReactProp decorator, Android-реализация LinearGradient абсолютного позиционирования, Использование действий абсолютного позиционирования в приложении Zebreto, Использование Reflux в элементах выравнивания Zebreto свойства, Макеты с Flexbox Android добавление изображений в проекты, Добавление фонового изображения прикрепление компонента React к представлению, Прикрепление компонента к представлению общие проблемы с, Распространенные проблемы с Android развертывание приложений, Развертывание приложения для Androidинструкции-Краткое описание создание APK для выпуска, Создание APK для выпуска распространение по электронной почте или другим ссылкам, Распространение по электронной почте или другим ссылкам официальная документация, Развертывание приложений Android настройка значка приложения, Настройка значка приложения отправка приложений в Google Play Store, отправка вашего приложения в Play Store-Краткое описание настройки среды разработки, Зависимости Android Java API, вызываемый React Native bridge, что такое React Native? родной модули, собственные модули для Android-дроид для осуществления LinearGradient платформы отдельных компонентов, для iOS - или Android-только для компонентов, работающих реагировать родной приложения для запуска реагировать родное приложение для Андроид АВД команду, работающем на Android Андроид руководство по проектированию, других илиорганизационные компоненты пакета SDK для Android для диспетчера, открытия, Андроид зависимостей пакета SDK для Android, установка, Андроид зависимостей виртуальное Android-устройств (виртуальных), Андроиде зависимости андроид.графический пакет, при установке стороннего компонента для Андроид.утиль.файл журнала, Анатомия Ява собственного модуля AndroidManifest.xml Файл Настройки Приложения значок ANDROID_HOME переменная, общей Android проблемы при экспорте, Андроид зависимостей APK файл для версии Android приложений, создание APK для выпуска электронной почте пользователям, Дистрираспространение через электронную почту или другие ссылки загрузки на Google магазин игры, представив свои приложения в магазине Play файле AppDelegate.M файл, прикрепив компонент вид крепления компонента к мнению, присоединение компонента к просмотру объявления корневое представление вttaching компонент в представление jsCodeLocation, загрузка на ваши устройства iOS, обновление файле AppDelegate.м учетную запись разработчика Apple, получив ваши документы в целях проверки, если все в порядке, то вопросы развертывания на устройство iOS разработчиков Apple, Регистрация детиски с, загрузка на ваши iOS устройства, значок приложения для Android приложения, установив значок приложения для iOS, добавив свой значок приложения AppRegistry, присоединение компонента к просмотру импорта в реагировать родной код, импорт в реагировать родной AppRegistrг.registerComponent(), крепления компонента в представлении "архив" приложения, для iOS магазин приложений, создание архива массив объектов, атрибут style прием, стиль объединение активов добавление к проектам, добавив, фоновое изображение проблемы с размером в Xcode в Xcode распространенных проблем требуется для игровой магазин список, необходимых активов для магазина листинг AsyncStorage модуль, хранение постоянных данных с AsyncStore хранения ключей, хранение постоянных данных с AsyncStore АВД (Android виртуального устройства), человек- эйджер, Андроид зависимостей, начиная, Работает родное приложение реагировать на виртуальных Андроид (Android виртуального устройства), зависимостей в Android API в "плеере АВ" (для iOS), осуществление RCTVideo Б Бабель, синтаксис ES6 в .babelrc файл, структура проекта фоновое изображение объявлениеДин в приложение Погода, добавив фоновое изображение применении в реагировать родной, изображение компонента фон-свойство изображения, изображение компонента лучших продавцов приложения, используя ListView с использованием элемента управления ListView BookListV2.js и BookItem.js файлы, используя ListView с заголовком и FooteР компонент, используя ListView с ListView, и с помощью, используя ListView для обновления отображения функции для coverURL, автору и названию реквизита, используя ListView с бета-тестирование приложения для iOS, используя TestFlight как приложение, бета-тестирование с помощью TestFlight на Google Play магазин, Бета-тестирование через Play Маркет растровые графические ресурсы (Андроид), добавив фоновое изображение дна собственность, используя абсолютное позиционирование варить доктору, общее развитие окружающей среды квас, чтобы быть в курсе, общее развитие окружающей среды моста, как реагировать родной работу? вызывая собственные API рендеринга, что такое React Native? сборка.Gradle в файл (для Android), установка сторонних компонентов подписания конфигурации, построении APK для выпуска идентификатор пакета (для iOS), создание приложения в iTunes подключите имя пакета для Xcode проектов, настройка имя пакета кнопки кнопки компонента, SmarterWeather приложение, кнопка компонент Button компонент, Zebreto приложение, компонент иерархии объединения кнопку и accentText стили для AccentButton компонента, стиль объединение Кондитдополнительные стили, подача заявления на кнопку компонента, стиль объединение LocationButton компонент, SmarterWeather приложения, обновление погоды применения, В LocationButton компонент с CAGradientLayer по API (Андроид), установка сторонних компонентов камеры, доступНГ доступа пользователя изображений и камеры фоток модуль, модуль фоток и фоток.getPhotos функции, фоток и модуль отображения списка пользовательских фотографий, отображения списка фотографий, рендеринга фотографий, полученных с камеры ролл, отображение изображения с камеры ролл с просьбой изображений с getPhotoParams, с просьбой изображений с GetPhotoParams создания карты, Zebreto приложение, применение Флэш компонента дерева, иерархию компонентов, карты, Zebreto приложение, применение Флэш componЛОР дерево, иерархию компонентов компоненты нужно знать о обзор потока данных, архитектура: рефлюкс и поток обработки обновлений, после обзора, С помощью рефлюкса в Zebreto сертификаты для Android приложений, создание APK для релиза для Apple разработчика асв счет, отправка с Вашего iOS устройства проблемы с подписанной версией Android-приложение, общей Android проблемы хром инструменты разработчика, активировать Параметры разработчика-отладка, отладки с консоли.войдите, используя отладчик JavaScript, используя отладчик JavaScript ЧРОме расширение, реагировать инструменты разработчика, работает с реагировать инструменты разработчика Java-классы, Анатомия Java собственный модуль Objective-С, Анатомия Objective-С родного модуля реагировать родной, РКИ префикс, присоединение компонента к просмотру cloneWithRows меняметод (источник данных), используя ListView для повторного использования кода с реагировать родной, повторного использования кода и обмена знаниями, использование стилей, повторное использование и обмен стили команд, команды и краткое руководство пользователя компоненты для мобил, Комплектующие для мобильных резюме аналогий между HTML элементами, между элементами HTML и родной компоненты, связи между компонентами потока данных, архитектура: рефлюкс и поток иерархию компонентов в Zebreto приложение, иерархию компонентов на касания и жесты, работа с касания и жесты деciding как прикосновения, выбирая, как справиться с сенсорной GestureResponder системы, GestureResponder системы-GestureResponder системы PanResponder класса, PanResponder-выбирая способ обработки касания TouchableHighlight компонент, используя TouchableHighlight ямаг компонент, компонент изображения организационные компоненты, Работа с организационными компонентами-другие организационные компоненты с помощью штурманов, штурманов с использованием платформы, платформы, комплектующие-когда использовать специфичный для платформы компонентх, когда использовать, когда использовать платформы, компоненты, получающих стиль объекты через реквизит, проходя стилей в качестве реквизита текстовый компонент, компонент текста, веб-приложения и, аналогий между HTML-элементов, и собственные компоненты сцепления, стили, стиль Concatenaного условные стили, стиль объединение консоли.войдите, отладки, отладки с консоли.журнал содержит (resizeMode), изображение компонента создания контента, Zebreto приложение, применение Флэш крышки (resizeMode), изображение компонента кроссплатформенного наприменение комплектующих с конкретной платформы версии, компонентов на платформе-специальные версии собственных модулей кросс-платформенной модули CSS вложенность и переопределение классов стиля и стиля сцепления, стиль объединение позиционирование техники, Пositioning и разработка макетов проблемы с традиционных стилей, объявления и манипулируя стилями укладки реагировать родной компонент, стайлинг родной компоненты D потока данных архитектура, рефлюкс и поток, Поток данных архитектура: рефлюкс и вновь поток черезпоток в Zebreto приложение, используя рефлюкса в Zebreto моделирования данных, Zebreto приложение, моделирования и хранения данных колоды и карты-классы, моделирование и хранение данных dataSource опора (в ListView), используя ListView с даты объекты, моделирование и хранение данных DatePickerIOS составляющая, работа с представлениями отладки, отладки и инструменты разработчика-резюме активировать Параметры разработчика, активировать Параметры разработчика на JavaScript за пределами, за пределы отладки кода JavaScript Андроид проблемы, общей Android проблемы развития окружающей среды, Коммна развитие окружающей среды симуляторе iOS, странности в поведении, симулятор поведения реагировать родное приложение в реагировать родной упаковщик в Xcode проблемы, общие проблемы Xcode для отладки JavaScript, JavaScript отладки практики, переведенные выхода на реагировать родной общины, когда вы застряли реагировать родной отладки, реагировать родной отладки осмотрите элемент, с помощью инспектировать элемент красный экран смерти, красный экран смерти тестирования кода, тестирование кода с помощью консоли.журнал отладки с консоли.войдите, используя отладчик JavaScript, используя JavaScript-отладчик работает с реагировать инструменты разработчика, работает с реагировать инструменты разработчика палубе создание, Zebreto приложение иерархию компонентов, компонент иерархии рефлюкс потока данных, используя рефлюкса в Zebreto дependencies внешних, установка, Установка библиотек JavaScript с помощью npm в Андоид сборки.Gradle в файл, установив сторонний компонент отсутствует, Андроид зависимостей, общей Android проблемы внешних библиотек, используемых в Zebreto приложение, взглянуть на сторонних деpendencies проблем, общего развития и окружающей среды развертывания приложений Android приложений, развертывание приложений Android-резюме строительство АПК освобождения, дом APK для выпуска распространять через электронную почту или другие ссылки, раздачи через электронную почту или другие ссылки для публикации на Google магазин игры, публикуя свой Настройки Приложения значок приложения, Настройки Приложения значок отправки в Google Play магазин, Отправка вашего приложения в магазине Play - резюме на iOS магазин приложений, развертывание на iOS наПП, магазин-Краткая загрузки приложения, загрузки приложений, рекомендации по проектированию, платформы компонентов, другие организационные компоненты деструктурируется в ЕС6, импорт в реагировать родной разработчика, опыт, совершенствование, разработчика опытсе разработчика счета (для iOS), МО зависимостей получение сертификата для загрузки на устройства iOS среды разработки проблем, общего развития экологии настройка, Настройка среда-Android зависимостей Андроид dependencieс Андроид установка зависимостей реагировать родной, установив реагировать родной iOS зависимостей для iOS зависимости габариты API-интерфейс, адаптивный дизайн и размеры шрифтов DisplayName для компонентов, работающих с реагировать инструменты разработчика элемент div, импорта реагировать наные аналогии, чтобы смотреть компонент, аналогий между HTML-элементов, и собственные компоненты в DOM (объектной модели документа), как реагировать родной работу? Компонент DrawerLayoutAndroid, Другие организационные компоненты, эмуляторы (Android), Сбой при запуске зависимостей Androide, проблема с, Распространенные проблемы Android при запуске и запуске приложения React Native, Запуск приложения React Native для Android, делающий скриншоты через, Необходимые ресурсы для размещения в магазине, Делающий скриншоты в сообщениях об ошибках Android, ябеспокоюсь, на красном экране смерти, На красном экране смерти Синтаксис ES6, Синтаксис ES6-интерполяция строк, деструктурирование назначений, деструктурирование функций fat arrow, функции Fat Arrow, сокращение функций, импорт и экспорт модулей, Импорт модулей, интерполяция строк , Интерполяция строк в Facebook, Что такое React Native? Принести с API, получение данных из интернета о структуре файлов проектов, создание нового приложения отдельные папки для компонентов и стилей, повторное использование и обмен стили Zebreto флэш приложение, структура проекта FirstProject компонента, FirstProject компонента Flex собственность, макеты на основе технологии Flex-Start и Flex в конец значения, макеты на основе адаптируемых блоков, схемы, спецификации Flexbox макет в FirstProject компонентовНТ в FirstProject свойства компонента доступны, макеты на основе соответствующих ценностей, влияющих макет, макеты на основе flexDirection собственность, макеты на основе столбца, Положить его вместе укладки фоновые изображения, добавление фона ямаг потока, настройки среды потока библиотека, типа проверки, вида проверки с подачей потока (потока данных архитектура), данные потока архитектура: рефлюкс и поток данных животных в поток данных архитектура: рефлюкс потока и размеров шрифта, регулировка в Зе- Бре приложение, адаптивный дизайн и размеры шрифтов-отзывчивый дизайн и размеры шрифта свойство fontstyle атрибут, текстовый компонент свойство fontweight атрибут, текстовый компонент прогноз компонент (приложение погоды), Отображение данных, требующих и добавления в приложения выносят функцию, Дisplaying данных г определение местоположения с помощью API (для iOS), ограничения геолокации, с помощью геолокации, получение местоположения пользователя, получение местоположения пользователя ограничения, ограничения разрешения для местоположения данных, обработка разрешения тестирование в симуляторе iOS, тестирование геолокацию в симуляторе iOS, используя в SmarterWeather приложения, обновление погоды приложения-обновить приложение weather смотрите местоположения пользователя, просмотра местоположения пользователя API геолокации веб-спецификации, с помощью геолокации geoOptions объекта, Получение местоположения пользователя GestureResponder системы, GestureResponder системы-GestureResponder системы, Выбор способа обработки сенсорного документации, GestureResponder системы gestureState объекта, PanResponder getCurrentPosition функция, получение местоположения пользователя разрешения, обработку, обработку разрешений getInitialState функции, обработки пользовательского ввода, добавив макет данных в приложение погоды, отображение данных в ListView.Источник данных, используя ListView для обновления, чтобы устранить макет прогнозных данных, выборки данных из насб getPhotoParams объекта, запрашивающего изображений с просьбой изображений с GetPhotoParams приступая к работе, создание приложений, создание вашего первого приложения-резюме создании нового приложения, создание новых приложений, работающих реагировать родное приложение для Android, работает с реагировать родной приложение для Android работает реагируют родное приложение для iOS, под управлением реагировать родное приложение для iOS-загрузка с Вашего iOS устройства загрузки к устройству iOS просмотр примеров кода Исследуя образец трескиэлектронной крепления компонента React с тем, присоединение компонента к просмотру FirstProject компонента, FirstProject компонент импорта в реагировать родной, импорт в реагировать родной настройка среды разработки, настройка среда-Android Dependencieс приложением, Дом погодного приложения-резюме добавления фонового изображения, добавление фонового изображения, отображение данных отображение данных получение данных из интернет, получение данных из интернета обработки пользовательского ввода, обработки пользовательского ввода, если сложить все вместе, Ударего вместе Google магазин игры список приложений на Play магазин с перечислением требуемых активы, имущество, необходимое для магазина включении бета-тестирования приложения через, бета-тестирование через Play Маркет публикации приложений, публикуя свой применения внесенфитинг Андроид приложения в, Подать заявку на Play Маркет градиентной составляющей, установка сторонних компонентов на Android и iOS, кросс-платформенные собственные модули Gradle в (система сборки для Android), установка сторонних компонентов градля.узнаютучастники файла, создание APK для выпуска сек .H (заголовочный файл) (цель-с), Анатомия Objective-С родного модуля handleTextChange обратного вызова компонента TextInput, обработки пользовательского ввода изменив запрос OpenWeatherMap API-интерфейсу, получение данных из интернета заголовок электронныхрасчетов (Н1, Н2 и т. д.), Текстовый компонент колонтитулы рендеринга для элемента управления ListView, ListView с помощью доморощенного менеджер пакетов, настройки среды, сохраняя варить до даты, общее развитие окружающей среды хоста API платформы, Хоста API платформыс элементами HTML аналогий между реагировать родной компонент и, аналогий между HTML-элементов, и собственные компоненты CSS и, объявив, и манипулируя стилями замена платформы реагировать компоненты, работа с представлениями человека интерфейс guidelinES для iOS и Android, для того, чтобы использовать платформо-зависимые компоненты я иконки приложения для Android значок, Установка иконку приложения в iOS значок приложения, добавив свои приложения значок изображения компонента, при добавлении фонового изображения, Изображения, исходный компонент собственность, отображение изображения с камеры ролл ImagePickerIOS модуль отображения списка фотографий ImagePickerIOS.openSelectDialog, в котором отображается список фотографий, изображений доступа пользователя изображений, доступ пользователя, изображения и камеры визуализации изображений, получаемых отМ рулон камеры, отображение изображения с камеры ролл загрузке изображений на сервер, при попытке загрузить изображение на сервер, используя getPhotoParams, с просьбой изображений с GetPhotoParams добавление к проектам, добавив, фоновое изображение иконки приложений, Приложения для iOS, надстройкаг ваш значок приложения, включая веб-изображений источников, компонент изображения запуска экрана картинки для приложений iOS, запустите экран изображений неправильного размера, В Xcode предупреждение о том, распространенных в Xcode проблем заменить компонент изображения в SmarterWeather с PhotoBackdrop, то фоток модуль-элемент img, аналогия компонент изображения, аналогий между HTML-элементов, и собственные компоненты неизменности, проблемы с таблицами стилей укладки с объектами импорта в реагировать родной, импорт в реагировать родной index.android.js файл меняется для отображения градиента компонент, устанавливая сторонний компонент, исследовав содержание, FirstProject компонент для приложения Погода, здание погода приложение index.ios.js файл исследовав содержание, объем импорта в реагировать родной для приложения Погода, Дом приложении погоды вначальном государственного значения реагировать компоненты, обработки пользовательского ввода встроенные стили, укладка собственные компоненты, встроенные стили преимущества и ограничения, встроенные стили стиль ввода, обработки пользовательского ввода осмотрите элемент, используя в отладке, с помощью инспектировать элемент винтерфейсной ошибка (в Xcode), общие проблемы в Xcode для iOS, добавив изображения активы на проекты, добавив фоновое изображение AsyncStorage АПИ сохранение постоянных данных с AsyncStore крепления компонента React вид крепления компонента до просмотра фоток модульалименты, Фоток модуль среды разработки, настройка iOS и зависимостей, определение местоположения интерфейс API, ограничения, геолокации поддержки, используя геолокацию собственные модули для собственных модулей для iOS-осуществление RCTVideo цель-интерфейса API для C ссылаться на реагировать родной бхребта, что реагировать родной? средство выбора фотографий, отображение списка фотографий компоненты, зависящие от платформы, компоненты только для iOS или Android проблемы с развертыванием на устройстве iOS, Проблемы с развертыванием на устройстве iOS, на котором запущено приложение React Native, Запуск приложения React Native для приложения настроек iOS, Использование навигаторов целевой версии iOS для Xcode project, Выбор поддерживаемых устройств и целевой версии iOS UIImagePickerController, отображение списка фотографий, загружающих приложение React Native на устройство, Загрузка для Вашего iOS устройства iOS магазин приложений, развертывание приложений для развертывания в магазине приложений Apple-резюме бета-тестирование с помощью TestFlight, бета-тестирование с помощью TestFlight готовит свой проект Xcode, готовит свой проект Xcode значок приложения, добавив свои приложенияного значок имя пакета, установив имя пакета запуск снимков экрана, запуск снимков экрана выбора поддерживаемых устройств, выбрав поддерживаемых устройств и целевой версии iOS выбора целевой версии iOS, выбрав поддерживаемых устройств и целевой версии iOS брусчаткаИнг построить схему выхода, Набор схем для освобождения подачи Вашего заявления на рассмотрение, подав заявление о пересмотре загрузки приложения, загрузки приложений создать приложение в iTunes подключить, создание приложения в iTunes подключите КРест архиве, создание архива становится все в порядке с документами, получая документы в порядке iOS устройств человеко-машинного интерфейса руководящих принципов, других организационных компонентов SDK для iOS, ОС iOS зависимостей API, предоставляемые, Анатомия Objective-С родной модуль базовый пакет SDK версии, выбор поддерживаемых устройств и ориентированные на iOS iOS версии симуляторов для iOS зависимости странности в поведении, Симулятор поведения тестирование геолокации в, тестирование геолокации в iOS симулятор IP-адрес, с получением за свой компьютер, загрузить на устройства iOS в iTunes подключить, вопросы развертывания на устройство iOS приложения статус, представив заявление о пересмотре создать приложение, создания приложения в iTunes подключите документов для представления приложения в магазине iOS, получив ваши документы ян с целью использовать TestFlight, бета-тестирование с помощью TestFlight Дж Java собственный модуль, Анатомия, Анатомия Java родной модуля Java API для отрисовки в Android компонентов, Как Реагировать Родной Работу? JavaScript, Что такое React Native? добавление интерфейсов JavaScript к существующимAPI Objective-C, Инструменты и методы отладки модулей, Методы отладки JavaScript, Переведенный импорт пакета LinearGradient, Установка стороннего компонента, установка библиотек с помощью npm, Установка библиотек JavaScript с помощью npm JSX versus, Использование тестируемого кода JSX, тестирование вашего кода JDK (Java Development Kit), установка зависимостей Android Jest, тестирование кода с помощью, Тестирование с помощью Jest jsCodeLocation, Загрузка на ваше устройство iOS, Подключение компонента к обновлению представления для развертывания приложения, обновление AppDelegate.m JSON с Запрос OpenWeatherMap API, выборка данных из веб-приложения pesistence в приложении Zebreto, сохранение, AsyncStorage и хранилища Reflux JSX, что такое React Native? используя, используя JSX к ключей, создание APK для выпуска знаниякрай обмена среди застройщиков, повторного использования кода и обмена знаниями L запуска снимков экрана (iOS приложения), запустите экран изображение макета режимов, макеты на основе макетов и позиционирования, разработки, позиционирования и разработка макетов собираем все вместе, положить его вместе с адаптируемых блоков, макеты на основе имущества, используя абсолютное позиционирование меньше, объявления и манипулируя стилями ли элемент управления ListView компонент аналогии, аналогий между HTML-элементов, и собственные компоненты LinearGradient компонент, Модулиtalling сторонних компонентов, установка сторонних компонентов, кросс-платформенные собственные модули для Андроид осуществления, Андроид осуществления LinearGradient LinearGradientManager класса (в Java), Android реализация LinearGradient LinearGradientPackage.java, Android реализация LinearGradient управления ListView компонент, используя ListView с использованием ListView с аналогией ул, ол, и Li элементы, аналогий между HTML-элементов, и собственные компоненты dataSource и renderRow реквизит, используя ListView с источником данных, вitializing и обновления, с помощью элемента управления ListView header и footer, перевода, Использование элемента управления ListView, используя в cameraroll, чтобы отобразить список пользовательских фотографий, отображения списка фотографий с помощью штурманов, используя навигаторов местоположения (см. геолокацию) откуда выбора, тестирования Гэolocation в симуляторе iOS LocationButton компонент, обновлении приложения с прогнозом погоды в LocationButton компонент библиотеки lodash, установки библиотеки JavaScript с помощью npm войти объекта (Андроид), Анатомия Java собственный модуль logcat и команды, Анатомия о.Ф Java в собственный модуль, отладки с консоли.войдите м .файл м (цель-с), Анатомия Objective-С родной главного модуля.jsbundle файл, вопросы развертывания на iOS-устройстве MainActivity.java файл прикрепить компонент к просмотру импорта сторонних componлор в, установка сторонних компонент свойство margin, позиционирование и разработка макетов МДН API геолокации веб-спецификации, с помощью геолокации МДН запрос, спецификации, отправка изображения на сервер методов @ReactMethod декоратор, анатомг Java в собственный модуль на Java, Анатомия Java собственный модуль Objective-С, экспорт в JavaScript, Анатомия Objective-С родного модуля мобильные API Хост-платформы API для мобильных платформ, поддержка родной реагировать, что реагировать родной? моделирование данных в Zebreto приложение, моделирование и хранение данных модуль, присоединение компонента к просмотру модули, модули-резюме кросс-платформенной модули кросс-платформенные собственные модули установки библиотеки JavaScript с НПМ установки библиотеки JavaScript с помощью npm наонных модулей ФО анатомии для iOS Objective-С родного модуля, Анатомия Objective-С родного модуля собственные модули для Android, собственные модули для Android-Android реализация LinearGradient Анатомия Java собственный модуль, Анатомия Java собственный модуль установки сторонних компонентов, установка стороннего компонента собственные модули для iOS, собственные модули для iOS-осуществление RCTVideo в том числе и сторонних компонентов, в том числе стороннего компонента RCTVideo, внедрение, реализация в RCTVideo живописи Мондриана, подражая в макет, положить его вместе MP4 видео файлы, импортировать в проект Xcode, в том числе стороннего компонента Н нативного Android-компоненты пользовательского интерфейса, документации, Андроид осуществления LinearGradient собственные модули кросс-платформенный, Кросс-платформенные собственные модули определения Ojective-C и собственного модуля, Анатомия Objective-С родной модуль для Android, собственные модули для Android-Android реализация LinearGradient Анатомия Java собственный модуль, Анатомия Ява собственный модуль установки сторонних компонентов, установка сторонних компонентов для iOS, собственные модули для iOS-осуществление RCTVideo Анатомия Objective-С родного модуля, Анатомия Objective-С родной модуль, в том числе стороннего компонента, В том числе стороннего компонента RCTVideo, осуществление, реализация RCTVideo навигатор компонент, используя навигаторы, используя в Zebreto приложение, с помощью навигатора-с помощью навигатора навигатор.функция геолокации, получение местоположения пользователя НавиtorIOS компонент, используя навигаторы сетевые API в реагировать родной, извлечения данных из веб-Нью-Йорк Таймс бестселлер список (см. Приложение бестселлер) узлов, настройке среды Node.js, НПМ менеджер пакетов, установка библиотек JavaScript с помощью npm НПМ менеджер пакетов добавления сторонних компонентов проекта, в том числе стороннего компонента установки библиотеки JavaScript с установкой библиотек JavaScript с помощью npm проблемы с реагировать родной упаковщик реестра Используя компонент "видео" НПМ стерпким команду, управляя реагировать родной упаковщик НС префикс Ojctive-c типов, Анатомия Objective-С родной модуль Objective-С анатомии Objective-С родного модуля, Анатомия Objective-С родным модулем условия для объективных-C и модули должны быть доступныв реагировать родной, Анатомия Objective-С родной модуль Objective-С API для добавления JavaScript-интерфейсы, модули визуализации для iOS компоненты, как реагировать родной работу? ол элемент управления ListView компонент аналогии, аналогии между элементами HTML и Naонных компонентов onLongPress, используя TouchableHighlight onMoveShouldSetResponder, в GestureResponder системы onMoveShouldSetResponderCapture, в GestureResponder системы onPressIn, используя TouchableHighlight onPressOut, используя TouchableHighlight onResponderGraНТ в GestureResponder системы onResponderMove, в GestureResponder системы onResponderRevoke, в GestureResponder системы onResponderTerminationRequest, в GestureResponder системы onStartShouldSetResponder, в GestureResponder системы onStartShouldSetResponderCapture, в GestureResponder системы OpenWeatherMap API-интерфейс, извлечения данных из веб-запросов по широте и долготе, обновление приложения "Погода" организационные компоненты, Работа с организационной компоненты-других организационных компонентовс ListView, и с помощью элемента управления ListView, используя ListView с помощью навигатора компоненты, используя навигаторы другое, другие организационные компоненты П П элемент аналогии, чтобы смотреть компонент, аналогий между HTML-элементов, и собственные компоненты упаковки заявление (Ява), Анатомия Java в собственный модуль, пакет.JSON-файла, установка библиотек JavaScript с помощью npm упаковщик проверка на проблемы, общие ошибки в Xcode, чтобы загрузить файлы на устройство iOS, вопросы развертывания на устройство iOS и проблемы с реагировать родной упаковщик пакетстарения Android приложений, создание APK для освобождения упаковщик (реагировать), запустить реагировать родной приложение для iOS пакеты, отсутствующие пакеты Андроид, общей Android проблемы с зависимостями, общее развитие окружающей среды обивка собственность, пос.itioning и разработка макетов PanResponder класса, GestureResponder системы, PanResponder, Выбор способа обработки сенсорного разрешения для местоположения данных, манипулирование, обработку разрешений настойчивость, в Zebreto приложение, настойчивость, AsyncStorage, и рефлюкс - магазинах цены палитр отображения списка фотографий PhotoBackdrop компонент, фоток модуля, PhotoBackdrop компонент платформы Апис с iOS - или Android-только компоненты, API платформы - резюме доступа пользователя изображений и камеры, зайдя на пользователя, изображения и модуль камеры фоток, фоток и модуль отображения списка фотографий, Отображение списка фотографий, загрузка изображений на сервер, при попытке загрузить изображение на сервер, геолокации, используя, с помощью геолокации, получение местоположения пользователя, получаю Тего местоположение пользователя обращении разрешения, обработку разрешений ограничения, геолокации, ограничения SmarterWeather приложения, обновление погоды приложение-обновление погоды тестирования приложений геолокации в iOS симулятор, тестирование геолокации в iOS симулятор смотрите местоположения пользователя, просмотра местоположения пользователя сохранение постоянных данных других вариантов хранения, других вариантов хранения с AsyncStorage, Сохранение постоянных данных с AsyncStore платформу-специальные компоненты, специфичные для платформы компоненты-когда использовать платформо-зависимые компоненты с платформы версии, компоненты с платформы версии разработать руководящие принципы, другие организационные составляющие iOS - или Android-специфический, для iOS - или Android-только компоненты для использования, жкурица использовать платформо-зависимые компоненты платформы, компонентов и API-интерфейсов, работа с представлениями располагать объекты, получение местоположения пользователя имущественном положении, установка на абсолютную, Используя абсолютное позиционирование позиционирование абсолютное позиционирование, использование, Усинг абсолютного позиционирования положить расположение и компоновку методов, поставив его вместе реагировать родной и CSS, подходы к позиционированию и разработке проектных структура, Zebreto приложение, структура проекта реквизит контроля рендеринга изображений в реакцииТ родной, изображение компонента прохождения стили, как, проходя стилей в качестве реквизита для конкретной платформы, в компонентах, а iOS - или Android-только компоненты, проверка через propTypes, используя таблицу стилей.Создайте префикс RCT для классов, прикрепив компонент к View RCTBridгеМодуль, Модули, объявляющие, что модуль реализует интерфейс, Анатомию встроенного модуля Objective-C, импортирующего заголовочный файл, Анатомию встроенного модуля Objective-C, Реализацию встроенного модуля RCTVideo RCTVideo, Реализацию встроенного компонента RCTVideo UI, Реализацию файла RCTVideo RCTVideo.h, импортирующего из Objective-C, Реализацию RCTVideo RCTVideoManager, Реализацию экспортированных свойств и констант RCTVideo, Реализацию файла RCTVideo RCTViedo.m, импортирующего из Objective-C, Реализация RCTVideo RCTViewManager, Реализация макроса RCTVideo RCT_EXPORT_METHOD, Анатомия встроенного модуля Objective-C RCT_EXPORT_MODULE(), Анатомия встроенного модуля Objective-C RCT_REMAP_METHOD macro, Анатомия Objective-C Native модуля React Developer Tools, Работа с инструментами разработчика React, просмотр компонентов и свойств, Работа с инструментами разработчика React React Native о том, что такое React Native? преимущества, Преимущества React Native создание компонентов, СозданиеКомпонентов в React Native работа с представлениями, Работа с API-интерфейсами платформы хостинга Views, Установка API-интерфейсов платформы хостинга, Установка официального сайта документации React Native, Настройка вашей среды обращение к сообществу, Когда вы застряли риски и недостатки, Риски и недостатки обновление, поддержание brew и node в актуальном состоянии, Общие проблемы среды разработки, Работа с React Native как это работает, Как работает React Native? жизненный цикл рендеринга, команда Rendering Lifecycle react-native bundle —minify, проблемы с развертыванием на устройстве iOS команды react-native init MyProject, запуск на iOS команды react-native run-android, запуск на Android пакета react-native-linear-gradient, установка для Android, установка стороннего компонента, компонента react-native-video, установка собственных модулей для iOS с помощью npm, включая сторонний компонент React.NativeModules object, Анатомия Java Native Module ReactContextBaseJavaModule, Анатомия Java Native Module ReactInstanceManager, Приостановке стороннего компонента, добавляющего HelloWorldPackage, Анатомия Java Native Module Red Screen of Death, Красный экран смерти Reflux (архитектура потока данных), Архитектура потока данных: распространение данных Reflux и Flux в, Архитектура потока данных: использование Reflux и Flux в приложении Zebreto, Использование Reflux в потоке данных Zebreto, Использование Reflux в Zebreto registerComponent(), присоединяющий компонент к функции отображения вида, как работает React Native? крепления PanResponder, чтобы смотреть на, PanResponder погода АПп окончательной версии, собирая его замены, оказываемых прогноз компонент с содержанием, извлечения данных из веб-WeatherProject компонент, добавляя фоновое изображение жизненного цикла рендеринга, визуализации жизненного цикла renderRow опора (в ListView), используя ListView с Требповторного заявления в реагировать родной, импорт в реагировать родной сбросить контент и настройки (имитатор iOS), симулятор поведения размеры (resizeMode), изображение компонента resizeMode опора, изображение компонента адаптивного дизайна в Zebreto приложение, Отзывчивый дизайн и шрифт размеры-отзывчивый дизайн и размеры шрифтов повторное использование стилизованных компонентов, повторного использования и обмена стили право собственности, используя абсолютное позиционирование риски и недостатки реагировать родной, риски и недостатки, корень вид, объявив в iOS/файле AppDelegate.м, крепления компонентовНТ мнение rowHasChanged способ (источник данных), используя элемент управления ListView с помощью Sass, объявления и манипулируя стилями скриншоты для Google Play Маркет перечень, имущество, необходимое для магазина листинг обеспечение для iOS приложение в магазине приложений, создающий приложения в iTunes подключите принимая на Android, снятия скриншотов на Android SegmentedControlIOS компонент, другие организационные компоненты настройках приложения (для iOS), с помощью навигаторов настройки.Gradle в файл (для Android), установка сторонних компонент обмена стилей, повторного использования и обмена стильЭс подписания Android приложений, создание APK для выпуска SmarterWeather приложения, обновление погоды приложение-обновление приложения с прогнозом погоды в SmarterWeather применения-PhotoBackdrop компонент Button компонента, компонента button получаете Forecast по координатам и на молнии, обновление погодных приложения нагрузки почтовый индекс информацией с AsyncStore, хранение постоянных данных с AsyncStore LocationButton компонент, обновлении приложения с прогнозом погоды в LocationButton компонент PhotoBackdrop компонент, Компонент PhotoBackdrop замене верхнего уровня изображения с PhotoBackdrop компонент фоток WeatherProject модуля, WeatherProject компонент-источник имущества (компонент Image), добавление фонового изображения, изображение компонента этого.государство.photoSource, отображение изображения с камеры ролл система разнесенными повторения (SRS), применение Флэш пролет элемента, FirstProject компонент сравнению с текстовым компонентом, аналогий между HTML-элементов, и собственные компоненты государственного значения для РЭАКТ компоненты, начальное состояние, обработки пользовательского ввода, хранения ключей, AsyncStorage, хранение постоянных данных с AsyncStore хранения постоянных данных в Zebreto приложение AsyncStorage и рефлюкс-магазинах, настойчивость, AsyncStorage, и рефлюкс-магазинов различных магазинах лисtening друг к другу, используя рефлюкса в Zebreto других вариантов хранения, Другие варианты хранения с AsyncStorage, хранение постоянных данных с AsyncStore структуры более крупного приложения, исследовав, все это вместе-итоги и уроки моделирования и Санкт -оринг данных, моделирования и хранения данных-настойчивость, AsyncStorage, и рефлюкс магазинах потока данных архитектура, отлива и потока, потока данных архитектура: рефлюкс и поток адаптивный дизайн и размеры шрифтов, адаптивный дизайн и размеры шрифтов-отзывчивый дизайн и размеры шрифтов от сторонних зависимостей, взгляд на сторонних зависимостей, используя навигатор в Zebreto приложение, С помощью навигатора-с помощью навигатора Zebreto флэш-приложения, Флэш-приложения иерархию компонентов, компонент иерархии проекта структуры, проектной структуре атрибутивного стиля принимать массив объектов стиль, Стиль объединение принимая объект, укладки с объектами стиля объектов, укладки собственные компоненты, объявления и манипулируя стилями разрешения конфликтов, стиль объединение в FirstProject компонента, FirstProject смешивая компонент с встроенные стили, стиль объединение стилей, стилей-резюме объявления и манипулирования, объявления и манипулируя стилями объединяя стили, стиль объединение встроенные стили, Встроенные стили проблемы с помощью CSS стилей, объявления и манипулирования с предметами стилей укладки, укладки с объектами, используя таблицу стилей.создать функцию, используя таблицу стилей.Создание организации и наследования, Экспорт объектов стилей организации и наследования, Расширениеобъектов стилей, передача стилей в качестве реквизита, Передача стилей в качестве реквизита, повторное использование стилей и совместное использование стилей, Повторное использование стилей и совместное использование стилей, позиционирование и проектирование макетов абсолютное позиционирование, Использование макетов абсолютного позиционирования с помощью flexbox, Макеты с Flexbox объединение всего этого, Объединение сообщений об ошибках, связанных со стилем, Красный экран таблицы стилей смерти, импорт в React Native code, Импорт в React Native StyleSheet.создайте функцию, обрабатывающую пользовательский ввод, преимущества использования организации и наследования, Использование таблицы стилей.Создавать проблемы с неизменяемостью, стилизацией с помощью стилизации объектов в React Native, добавлением стиля ввода в компонент TextInput, обработкой изображений пользовательского ввода, Компонента изображения в компоненте FirstProject, FirstProject Component text, Текстовый компонент Switch component, Компоненты с версиями для конкретной платформы SwitchAndroid component, создание кроссплатформенной версии, Компоненты с версиями для конкретной платформы SwitchIOS component, создание кроссплатформеннойrm-версии, Компоненты с версиями для конкретной платформы, синтаксические ошибки, Красный экран смерти T TabBarIOS component, Другие организационные компоненты TestFlight, бета-тестирование приложений iOS, бета-тестирование с помощью TestFlight, тестирование кода JavaScript, Тестирование вашего Coпроверка типов с помощью Flow, Проверка типов с помощью Flow с помощью Jest, Тестирование с помощью Jest Text component, Аналог компонента FirstProject для элементов span и p, аналогии между элементами HTML и нативными компонентами, создающими стилизованные компоненты, Текстовый компонент, который забыли импортировать, сообщение об ошибке от, Красный экран смерти в приложении weather, отображение информации о почтовом индексе, Обработка текста пользовательского ввода с помощью встроенных стилей, Текстовый компонент text components в приложении Zebreto, адаптивный дизайн и размеры шрифта Text.propTда.Введите стиль, используя таблицу стилей.Создание компонента TextInput, обработки пользовательского ввода, изменения обратного вызова для запроса OpenWeatherMap API-интерфейсу, получение данных из интернета onSubmitEditing собственность, обратного вызова, переданной в качестве, обработки пользовательского ввода платформы реквизит, для iOS - илиndroid-только компоненты сторонних компонентов, в том числе для iOS, в том числе стороннего компонента установка для Android, установка сторонних компонент.реквизит.стиль, проходящий стилей в качестве реквизита тайм-аут (geoOptions), получение местоположения пользователя ToolbarAndroid составляющей, другими организационными подразделениями топ собственность, используя абсолютное позиционирование касания и жесты, работа с касания и жесты решить, как обрабатывать, как обрабатывать касания GestureResponder системы, GestureResponder системы-гestureResponder системы PanResponder класса, PanResponder-выбирая способ обработки касания TouchableHighlight компонент, используя TouchableHighlight события касания объектов, GestureResponder системы сенсорных событий этапах жизненного цикла, в GestureResponder система с сенсорным вновьsponders, В GestureResponder система обработчиков событий, в GestureResponder системы TouchableHighlight компонент, используя TouchableHighlight, выбирая, как обрабатывать прикосновения в Tumblr фотографию выбора отображения списка фото в "Твиттере" фотографию выбора отображения списка фотографий тип проверки JavaScript-кода в поток, тип-проверка с потока * UDID или получения для устройств iOS, загрузка на ваши iOS устройства, компоненты пользовательского интерфейса, родной, создании, осуществлении RCTVideo, Андроид осуществления LinearGradient UIExplorer приложения, Работа с представлениями в том числе веб-изображения соус, изображение компонента resizeMode, размер, обложка, и содержит изображение компонентов с использованием фоток и производить изготовленный на заказ вид из библиотеки фотографий, отображения списка фотографий, то XHR пример загрузки изображений ссервер, при попытке загрузить изображение на сервер UIImagePickerController (для iOS), отображение списка фотографий RCTVideo класс-наследник UIView подкласс, реализации RCTVideo вид на способ, осуществление RCTVideo для UIViewController, присоединение компонента к мнению, ул Эль -ать аналогия в ListView компонент, аналогий между HTML-элементов, и собственные компоненты универсального приложения (iOS), Добавление фонового изображения цикла обновления, преимущества реагировать родной пользовательского ввода, обработки в приложение Погода, обработки пользовательского ввода в validatiо, стили, созданные с помощью таблицы стилей.создавать, используя таблицу стилей.Создайте переменные, пытающиеся использовать без импорта или определения, Видеокомпонент Red Screen of Death, Собственные модули для iOS, Используя импорт компонента просмотра видеокомпонента в коде React Native, Импорт компонента React Native в компоненте FirstProject, Элемент просмотра компонента FirstProject, Работу с Views view manager, Реализацию RCTVideo View.PropTypes.Введите стиль, используя таблицу стилей.Создание, Передача стилей в качестве реквизита ViewManager, Android Реализация LinearGradient views, Работа с представлениями, к которым прикрепляется компонент, Прикрепление компонента к представлению, позиционирование и проектирование макетов, Макеты с сенсорными ответчиками Flexbox, Виртуальный DOM системы GestureResponder, Как работает React Native? W watchman, Настройка приложения погоды в вашей среде, создание, Создание приложения погоды -объединение, обновление приложения погоды (см. Также приложение SmarterWeather) добавление фонового изображения, Добавление фонового изображения, отображающего данные, Отображение вg Data выборка данных из Интернета, Выборка данных из веб-окончательной версии, объединение их обработка пользовательского ввода, Обработка пользовательского ввода компонент WeatherProject, приложение SmarterWeather, компонент WeatherProject веб-приложения визуализируют собственные компоненты и, анализируютразличия между элементами HTML и веб-представлениями о собственных компонентах, преимущества React Native X Xcode, Зависимости iOS добавление графического ресурса в проект, Добавление фонового изображения добавление вашей учетной записи в панели настроек, Загрузка на ваше устройство iOS распространенных проблемс помощью консоли "Общие проблемы Xcode", Отладка с помощью консоли.войдите получение сертификата разработчика от Apple, загрузка на ваши iOS устройства, в том числе сторонние библиотеки в проект, в том числе стороннего компонента подготовке проекта по развертыванию, подготовке вашего проекта в Xcode значок приложения, добавив свои приложения значок имя пакета, установив имя пакета запуск снимков экрана, запуск снимков экрана выбора поддерживаемых устройств iOS, выбрав поддерживаемых устройств и целевой версии iOS выбирая щитТ iOS версии, выбор поддерживаемых устройств и целевой версии iOS установка построить схему освободить, установить схему для релиза обновления файле AppDelegate.файл м, обновления файле AppDelegate.м опции развертывания цели, загрузки на устройства iOS установка идентификатор пакета, ссоздание приложения в iTunes подключите то XHR модуль загрузки изображений функциональности, загрузка изображения на сервер XMLHttpRequest объекта, при попытке загрузить изображение на сервер (см. также используем XHR-модуль) з Zebreto флэш-приложения, Флэш-приложения компонент hierarchy, иерархию компонентов взаимодействия потоков, применение Флэш основной видом, Флэш приложения для моделирования и хранения данных, моделирования и хранения данных-настойчивость, AsyncStorage, и рефлюкс магазинах потока данных архитектура, Отлива и потока данных потока архитектура: рефлюкс и поток проекта структура проекта структура адаптивный дизайн и размеры шрифтов, адаптивный дизайн и размеры шрифтов-отзывчивый дизайн и размеры шрифтов от сторонних зависимостей, взгляд на сторонних зависимостей, используя навигатор, используя навигатор-с помощью навигатора Об авторе Бонни Айзенман является инженер-программист в Twitter с опытом работы на Codecademy, Google и тумана крик программного обеспечения. Она выступала на нескольких конференциях по темам, варьирующимся от React до музыкальной прогиramming и Arduinos. В свободное время она увлекается изготовлением электронных музыкальных инструментов, лазерной резкой шоколада и изучением языков. Колофон Животное на обложке Learning React Native - это кольцехвостый опоссум (Pseudocheirus peregrinus), марсианскийпиал, обитающий в Австралии. Кольцехвостые опоссумы травоядны и обитают в основном в лесных районах. Он назван так из-за своего цепкого хвоста, кончик которого часто свернут кольцом. Кольцехвостые опоссумы серо-коричневого цвета и могут вырасти до 35 сантиметров в длину. Рацион кольцехвостого опоссума состоит из разнообразных листьев, цветов и фруктов. Они ведут ночной образ жизни и живут в общих гнездах, известных как дрейсы. Как сумчатые, кольцехвостые опоссумы вынашивают своих детенышей в мешочках, пока те не разовьются достаточно, чтобывыживать самостоятельно. Популяция кольчатохвостого опоссума резко сократилась в 1950-х годах, но в последние годы восстановилась. Тем не менее, они по-прежнему подвергаются риску потери среды обитания из-за вырубки лесов. Многие животные на обложках O'Reilly находятся под угрозой исчезновения; все ониважны для мира. Чтобы узнать больше о том, как вы можете помочь, перейдите по ссылке animals.oreilly.com. Изображение на обложке взято из книги Шоу "Зоология". Шрифты на обложке - URW Typewriter и Guardian Sans. Шрифт текста - Adobe Minion Pro; шрифт заголовка - Adobe Myriad Condensed; а шрифт кода - Ubuntu Mono Далтона Маага. Предварительные условия Соглашения, используемые в этой книге, с использованием примеров кода Safari® Книги онлайн Как связаться с нами Ресурсы Благодарности 1. Что такое React Native? Преимущества React Native Developer EОпыт повторного использования кода и обмена знаниями, риски и недостатки Резюме 2. Работа с React Native Как работает React Native? Жизненный цикл рендеринга Создание компонентов в React Native Работа с представлениями с использованием JSX Styling Native Components Host Platform APIКраткое описание 3. Создание вашего первого приложения Настройка среды Установка зависимостей React Native для iOS Зависимости от Android Создание нового приложения Запуск приложения React Native для iOS Загрузка на ваше устройство iOS Запуск приложения React Native Приложение для Android Краткое описание: Создание и запуск проектов Изучение примера кода Прикрепление компонента к представлению Импорт в React Native Компонента FirstProject Создание приложения погоды Обработка пользовательского ввода Отображение данных Добавление фонового изображенияe Извлечение данных из Интернета Объединение резюме 4. Компоненты для мобильных устройств Аналогии между элементами HTML и собственными компонентами Текстовый компонент Компонент изображения Работа с касаниями и жестами С помощью TouchableHighlight Системныйответчик жестов Работа с компонентами организации с использованием ListView Использование навигаторов Другие компоненты организации Компоненты, зависящие от платформы Компоненты, доступные только для iOS или Android Компоненты с версиями, зависящими от платформы Когда следует использовать компоненты, зависящие от платформы Краткое описание 5. .......... Стили, объявляющие стили и манипулирующие ими, Стилизуют встроенные стили с объектами с помощью таблицы стилей.Создание объединения стилей Организация и наследование Экспорт объектов стилей Передача стилей в качестве реквизита Повторное использование стилей и совместное использование стилей Позиционирование и разработка макетов Макеты с Flexbox С использованием абсолютного позиционирования Сведение воедино Резюме 6. API платформы С использованием геолокации Получение разрешений на обработку местоположения пользователя Тестирование геолокации В симуляторе iOS Просмотр ограничений местоположения пользователяОбновление погодного приложения Доступ к изображениям и камере пользователя Модуль CameraRoll Запрашивает изображения с помощью GetPhotoParams Рендеринг изображения с фотопленки Отображение списка фотографий Загрузка изображения на сервер Хранение постоянныхданных с помощью AsyncStore Другое хранилище Опции Приложение SmarterWeather Компонент WeatherProject Компонент Forecast Компонент Button Компонент LocationButton Компонент PhotoBackdrop Сводка компонентов 7. Модули Установка библиотек JavaScript с помощью встроенных модулей npm для iOS, включая компонент сторонних производителей, с использованием видеокомпонента Анатомия встроенного модуля Objective-C Реализация встроенных модулей RCTVideo для Android Установка стороннего компонента Анатомия встроенного модуля Javadroid Реализация кроссплатформенных встроенных модулей LinearGradient Сводка 8. Отладка и инструменты разработчика Методы отладки JavaScript, переведенные в активацию опций разработчика Отладка с помощью консоли.журнал С использованием отладчика JavaScript, работающего с инструментами разработчика React, инструментами отладки React Native С использованием элемента Inspect, Красным экраном смерти, отладкой за пределами JavaScript, распространенными проблемами среды разработки, распространенными проблемами Xcode, распространенными проблемами Android, проблемами с упаковщиком React Native При развертывании на устройстве iOS, поведением симулятора, проверяющим тип вашего кода с помощью Flow, Тестированием с помощью Jest, когда вы застряли, с помощью Jest, когда вы застряли, Резюме 9. Сведение всего этого воедино, Моделирование структуры проекта приложения Flashcard, иерархии компонентов и хранения данных, Архитектура потока данных: Reflux и Flux С использованием Reflux в Zebreto Persistence, AsyncStorage и хранилищ Reflux с использованием Navigator Обзор зависимостей сторонних производителей, адаптивный дизайн и размеры шрифтов, краткое описание и домашнее задание 10. Развертывание в iOS App Store Подготовка вашего проекта Xcode Выбор поддерживаемых устройств и целевой версии iOS Изображения экрана запуска Добавление значка вашего приложения Настройка названия пакета Обновление AppDelegate.m Настройка схемы выпуска Загрузка вашего приложения Приведение в порядок документов Создание архива Создание приложения в iTunes Connect Бета-тестирование с помощью TestFlight Отправка приложения на проверку Резюме 11. Развертывание приложений для Android, настройка значка приложения, создание APK для выпуска, распространение по электронной почте или другим ссылкам, отправка Yнашего приложения в Play Store, бета-тестирование через Play Store, Перечисление необходимых ресурсов для магазина, Публикация резюме вашего приложения A. Разрушение синтаксиса ES6, Импорт модулей, Сокращение функций жирными стрелками, Функции String Interpolation B. Команды и краткое руководство по запуску, создание нового проекта, работающего на iOS, Создание скриншотов на iOS, работающего на Android, Создание скриншотов на Android, Запуск индекса React Native Packager 

`