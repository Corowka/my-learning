export type DataItem = {
  sentence: string,
  posd?: number,
  score?: number
}

const oddWords = ['и', 'в', 'на', 'что', 'он', 'я', 'с', 'так', 'это', 'все', 'они', 'как', 'а', 'но', 'то', 'ты', 'да', 'мы', 'к', 'у', 'же', 'его', 'ее', 'от', 'до', 'за', 'те', 'ся', 'бы', 'более', 'менее', 'также', 'однако', 'например', 'особенно', 'поэтому', 'хотя', 'когда', 'где', 'по', 'через', 'для', 'без', 'между', 'из', 'под', 'над', 'про', 'во', 'вот', 'тот', 'этот', 'какой', 'какая', 'какое', 'какие', 'который', 'которая', 'которое', 'которые', 'сам', 'самый', 'самая', 'самое', 'самие', 'очень', 'очень', 'совсем', 'вообще', 'абсолютно', 'совершенно', 'практически', 'почти', 'вполне', 'достаточно', 'весьма', 'крайне', 'чрезвычайно', 'именно', 'только', 'лишь', 'просто', 'всего', 'лишь', 'только', 'также', 'даже', 'еще', 'ни', 'не', 'нет', 'никогда', 'ничего', 'никто', 'нигде', 'никогда', 'никому', 'ничем', 'никогда', 'ничего', 'никто', 'нигде', 'никогда', 'никому', 'ничем', 'так что', 'потому что', 'для того чтобы', 'чтобы', 'если', 'тогда', 'хотя бы', 'по крайней мере', 'как минимум', 'как максимум', 'в связи с', 'в отношении', 'в целях', 'вследствие', 'благодаря', 'из-за', 'по причине', 'в результате', 'в зависимости от', 'в соответствии с', 'согласно', 'относительно', 'касательно', 'что касается', 'по поводу', 'по вопросу', 'в связи с тем', 'в том числе', 'так называемый', 'так называемая', 'так называемое', 'так называемые', 'иной', 'иная', 'иное', 'иные', 'другой', 'другая', 'другое', 'другие', 'разный', 'разная', 'разное', 'разные', 'один', 'одна', 'одно', 'одни', 'два', 'две', 'три', 'четыре', 'пять', 'шесть', 'семь', 'восемь', 'девять', 'десять', 'первый', 'второй', 'третий', 'четвертый', 'пятый', 'шестой', 'седьмой', 'восьмой', 'девятый', 'десятый', 'после', 'перед', 'между', 'вокруг', 'через', 'выше', 'ниже', 'левее', 'правее', 'внутри', 'снаружи', 'рядом', 'далеко', 'близко', 'быстро', 'медленно', 'хорошо', 'плохо', 'много', 'мало', 'большой', 'маленький', 'высокий', 'низкий', 'же', 'бы', 'ли', 'ведь', 'вот', 'только', 'лишь', 'даже', 'все-таки', 'все равно', 'все-таки', 'все же', 'ах', 'ох', 'ух', 'эх', 'ну', 'вот', 'значит', 'стало быть', 'конечно', 'правда', 'может быть', 'вероятно', 'возможно', 'кстати', 'вообще говоря', 'собственно говоря', 'по сути', 'таким образом', 'итак', 'значит', 'следовательно', 'например', 'к примеру', 'допустим', 'скажем', 'в общем', 'короче говоря', 'одним словом', 'прежде всего', 'во-первых', 'во-вторых', 'в-третьих', 'наконец', 'в заключение', 'так сказать', 'так называемый', 'очень', 'весьма', 'крайне', 'чрезвычайно', 'исключительно', 'просто', 'прямо', 'совершенно', 'абсолютно', 'безусловно', 'никак не', 'ни в коем случае', 'типа', 'как бы', 'вот это вот', 'ну', 'короче', 'в общем-то', 'знаете ли'];

export const posd = (sentences: string[], i: number, d: number): number => {
  const bd = sentences.slice(0, i).reduce((sum, s) => sum + s.length, 0)
  return 1 - bd / d
}

export const tf = (t: string, s: string): number => {
  const words = s.split(" ").filter(w => !oddWords.includes(w))
  return (words.filter(w => w === t).length / words.length)
}

export const w = (t: string, D: string, tfMax: number): number => {
  return 0.5 * (1 + tf(t, D) / tfMax)
}

export const score = (s: string, D: string, tfMax: number) => {
  const words = s.split(" ").filter(w => !oddWords.includes(w))

  return words
    .map(word => tf(word, s) * w(word, D, tfMax))
    .reduce((s, scr) => s + scr, 0)
}

export const refereeing = (text: string) => {
  const n = 10;

  text = text
    .split(/\r?\n/)
    .join(" ")
    .replace(/[^а-яА-ЯёЁ,.!?;:-\s]/g, '')

  const sentences = text
    .split(/\s*[.!?]\s*/)
    .filter(s => s)
    .map(s => s
      .replace(/[^а-яА-Я\s]+/g, '')
      .trim()
      .toLowerCase())

  const d = text.length;
  const D = text.replace(/[^а-яА-Я\s]+/g, '').toLowerCase()


  const df = 1
  const keys = [...new Set(D.split(" ").filter(k => k))].sort()
  const tfs = keys.map(k => tf(k, text))
  const tfMax = tfs.reduce((m, tf) => (tf > m ? tf : m), 0)
  const DB = 1

  const data: DataItem[] = sentences.map((s, i) => ({
    score: score(s, D, tfMax),
    sentence: s.at(0)?.toUpperCase() + s.slice(1, s.length) + ".",
    posd: posd(sentences, i, d)
  }))
    .sort((a, b) => b.score - a.score)
    .filter(d => d.sentence.length > 5)
    .slice(0, n)
    .sort((a, b) => a.posd - b.posd)

  return data
}